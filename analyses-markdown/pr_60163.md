# PR #60163: Fix conversion from `K"meta"` to `Expr`

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60163
- **Merged**: 2025-11-18 21:25 UTC
- **Labels**: `compiler:lowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60163.diff

## Scope

### Files Touched
- `JuliaLowering/src/ast.jl`
- `JuliaLowering/src/kinds.jl`
- `JuliaLowering/src/linear_ir.jl`
- `JuliaLowering/test/hooks.jl`
- `JuliaSyntax/src/integration/expr.jl`
- `JuliaSyntax/src/julia/kinds.jl`

### Components
- JuliaSyntax
- JuliaLowering

### Pipeline Stages
- Parsing
- Lowering
- CodeInfo/IR

## Analysis

### Intent

Normalize `K"meta"` nodes when converting to `Expr`, and clean up related test coverage and metadata handling in JuliaLowering.

### Direct Changes

#### 1. `K"meta"` nodes converted to `Expr` now unquote `QuoteNode(Symbol)` arguments to match `Expr(:meta, ...)` expectations.

**Component**: JuliaSyntax integration

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/integration/expr.jl:630-644**
[View on GitHub](https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaSyntax/src/integration/expr.jl#L630-L644)
```julia
elseif k == K"meta"
    # Expr uses plain identifiers, but JuliaSyntax uses quoted (Symbol) identifiers
    for (i, a) in enumerate(args)
        if a isa QuoteNode && a.value isa Symbol
            args[i] = a.value
        end
    end
end
```

</details>

#### 2. `meta` is now registered as a JuliaSyntax kind in the base Julia syntax list.

**Component**: JuliaSyntax kinds

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/julia/kinds.jl:1026-1036**
[View on GitHub](https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaSyntax/src/julia/kinds.jl#L1026-L1036)
```julia
"char"           # A char string node (containing delims + char data)
"macrocall"
"parameters"     # the list after ; in f(; a=1)
"toplevel"
"tuple"
"ref"
"vect"
"parens"
"importpath"
"meta"
# Concatenation syntax
```

</details>

#### 3. Lowering collects `K"meta"` hints into `ctx.meta`, then materializes `CompileHints` for `K"code_info"` metadata.

**Component**: JuliaLowering linear IR

<details>
<summary>Evidence</summary>

**JuliaLowering/src/linear_ir.jl:807-816**
[View on GitHub](https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaLowering/src/linear_ir.jl#L807-L816)
```julia
elseif k == K"meta"
    @chk numchildren(ex) >= 1
    if ex[1].name_val in ("inline", "noinline", "propagate_inbounds",
                          "nospecializeinfer", "aggressive_constprop", "no_constprop")
        for c in children(ex)
            ctx.meta[Symbol(c.name_val)] = true
        end
    elseif ex[1].name_val === "purity"
        ctx.meta[Symbol(ex[1].name_val)] = ex[2].value::Base.EffectsOverride
    else
        emit(ctx, ex)
    end
```

**JuliaLowering/src/linear_ir.jl:1105-1112**
[View on GitHub](https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaLowering/src/linear_ir.jl#L1105-L1112)
```julia
code = renumber_body(ctx, ctx.code, slot_rewrites)
meta = CompileHints()
for (k, v) in ctx.meta
    meta = CompileHints(meta, k, v)
end
@ast ctx ex [K"code_info"(is_toplevel_thunk=ex.is_toplevel_thunk,
                          slots=slots, meta=meta)
```

</details>

#### 4. Integration test now exercises the `@propagate_inbounds @inline` meta form via JuliaLowering activation, covering the prior meta conversion edge case.

**Component**: JuliaLowering tests

<details>
<summary>Evidence</summary>

**JuliaLowering/test/hooks.jl:27-84**
[View on GitHub](https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaLowering/test/hooks.jl#L27-L84)
```julia
function jeval(str)
    prog = parseall(Expr, str)
    local out
    try
        JL.activate!()
        out = Core.eval(test_mod, prog)
    finally
        JL.activate!(false)
    end
end
@testset "integration: `JuliaLowering.activate!`" begin
    out = jeval("global asdf = 1")
    @test out === 1
    @test isdefined(test_mod, :asdf)

    out = jeval("module M; x = 1; end")
    @test out isa Module
    @test isdefined(test_mod, :M)
    @test isdefined(test_mod.M, :x)

    @test jeval("@ccall jl_value_ptr(nothing::Any)::Ptr{Cvoid}") isa Ptr{Cvoid}

    # Tricky cases with symbols
    out = jeval("""module M2
            Base.@constprop :aggressive function f(x); x; end
            const what = ccall(:jl_value_ptr, Ptr{Cvoid}, (Any,), Core.nothing)
        end""")
    @test out isa Module
    @test isdefined(test_mod, :M2)
    @test isdefined(test_mod.M2, :f)
    @test isdefined(test_mod.M2, :what)

    out = jeval(""" "docstring" module M3 end """)
    @test out isa Module
    @test isdefined(test_mod, :M3)

    # Macros may produce toplevel expressions.  Note that julia handles
    # this case badly (macro expansion replaces M5_inner with a
    # globalref) and we handle esc(:M5_inner) badly
    out = jeval("""module M5
        macro newmod()
            return quote
                let a = 1
                    $(Expr(:toplevel,
                           Expr(:module, true, :M5_inner,
                                Expr(:block, :(global asdf = 1)))))
                end
            end
        end
        @newmod()
        end""")
    @test out isa Module
    @test isdefined(test_mod, :M5)
    @test isdefined(test_mod.M5, :M5_inner)
    @test isdefined(test_mod.M5.M5_inner, :asdf)

    @test jeval("Base.@propagate_inbounds @inline meta_double_quote_issue(x) = x") isa Function
end
```

</details>

### Secondary Effects

#### `Expr(:meta, ...)` arguments produced via JuliaSyntax no longer retain quoted symbols, which stabilizes meta-processing during lowering and macro expansion.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
node_to_expr(...) converts SyntaxNode -> Expr  [JuliaSyntax/src/integration/expr.jl:225-299]
  -> parseargs!(...) builds Expr args with fixup_Expr_child  [JuliaSyntax/src/integration/expr.jl:200-215]
  -> _node_to_expr(...) handles kind-specific rewrites  [JuliaSyntax/src/integration/expr.jl:317-330]
    -> K"meta" branch unquotes QuoteNode(Symbol) to Symbol  [JuliaSyntax/src/integration/expr.jl:630-643]
```
</details>

**Downstream Surfaces:**
- Macro expansion paths that expect Expr(:meta, :inline, ...)
- JuliaLowering activation that evaluates Expr ASTs via parseall(Expr, ...)

#### `CodeInfo.meta` is now materialized by folding `ctx.meta` into `CompileHints`, which keeps metadata in an ImmutableDict and avoids passing a raw Dict downstream.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
compile(...) records meta hints into ctx.meta  [JuliaLowering/src/linear_ir.jl:807-816]
-> compile_lambda(...) folds ctx.meta into CompileHints  [JuliaLowering/src/linear_ir.jl:1105-1112]
-> K"code_info" node stores meta=CompileHints(...)  [JuliaLowering/src/linear_ir.jl:1110-1112]
```
</details>

**Downstream Surfaces:**
- Core.Compiler / tooling that reads CodeInfo.meta (JET, IRTools, GPUCompiler)

### Compatibility

#### Internal API Changes
- **CodeInfo.meta (CompileHints)**: Metadata is constructed by iterating ctx.meta into CompileHints rather than via direct Dict conversion.

#### Behavioral Changes
- Quoted symbols in K"meta" are normalized to plain Symbol arguments in Expr form.

### Performance

**Compile Time:**
- ESTIMATED: O(n) fold over ctx.meta entries per lambda to build CompileHints; n is number of meta hints (typically small).

**Runtime:**
- No runtime changes expected; metadata conversion is compile-time only.

### Risk Assessment

**Level**: low

**Rationale:**
- Change is limited to metadata conversion and JuliaSyntax Expr normalization.
- Added test exercises the previously problematic meta conversion path.

### Recommendations

- Downstream tools should treat Expr(:meta, ...) arguments as plain Symbols rather than QuoteNodes.
- When constructing CompileHints, follow the iterative pattern used in compile_lambda instead of passing raw Dicts.
