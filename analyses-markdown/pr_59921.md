# PR #59921: Set types of boxed variables in `abstract_eval_nonlinearized_foreigncall_name`

## Metadata

- **Author**: JamesWrigley
- **URL**: https://github.com/JuliaLang/julia/pull/59921
- **Merged**: 2025-10-24 14:56 UTC
- **Diff**: https://github.com/JuliaLang/julia/pull/59921.diff

## Scope

### Files Touched
- `Compiler/src/abstractinterpretation.jl`

### Components
- Compiler.AbstractInterpretation

### Pipeline Stages
- TypeInference

## Analysis

### Intent

Avoid invalidations in the inference path for nonlinearized foreigncall names by giving boxed closure variables concrete Future types.

**Related Issues:**
- https://github.com/JuliaLang/julia/pull/59165

### Direct Changes

#### 1. Annotate the captured locals `ai` and `res` inside `abstract_eval_nonlinearized_foreigncall_name` as `Future`, preventing them from being boxed as `Any` in the evalargs closure.

**Component**: Compiler.AbstractInterpretation

<details>
<summary>Evidence</summary>

**Compiler/src/abstractinterpretation.jl:3451-3486**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3aea6638141da3169d9384ba1c20997bcd774486/Compiler/src/abstractinterpretation.jl#L3451-L3486)
```julia
function abstract_eval_nonlinearized_foreigncall_name(
        interp::AbstractInterpreter, @nospecialize(e), sstate::StatementState, sv::InferenceState
    )
    if isexpr(e, :call)
        n = length(e.args)
        argtypes = Vector{Any}(undef, n)
        callresult = Future{CallMeta}()
        i::Int = 1
        nextstate::UInt8 = 0x0
        local ai::Future, res::Future
        function evalargs(interp, sv)
            if nextstate === 0x1
                @goto state1
            elseif nextstate === 0x2
                @goto state2
            end
            while i <= n
                ai = abstract_eval_nonlinearized_foreigncall_name(interp, e.args[i], sstate, sv)
                if !isready(ai)
                    nextstate = 0x1
                    return false
                    @label state1
                end
                argtypes[i] = ai[].rt
                i += 1
            end
            res = abstract_call(interp, ArgInfo(e.args, argtypes), sstate, sv)
            if !isready(res)
                nextstate = 0x2
                return false
                @label state2
            end
            callresult[] = res[]
            return true
        end
        evalargs(interp, sv) || push!(sv.tasks, evalargs)
        return callresult
    else
        return Future(abstract_eval_basic_statement(interp, e, sstate, sv))
    end
end
```

</details>

#### 2. Call sites for `abstract_eval_nonlinearized_foreigncall_name`, showing its use from the foreigncall path and recursive evaluation.

**Component**: Compiler.AbstractInterpretation

<details>
<summary>Evidence</summary>

**Compiler/src/abstractinterpretation.jl:3447-3499**
```julia
3447:abstract_eval_nonlinearized_foreigncall_name(
3451:function abstract_eval_nonlinearized_foreigncall_name(
3468:                ai = abstract_eval_nonlinearized_foreigncall_name(interp, e.args[i], sstate, sv)
3497:        abstract_eval_nonlinearized_foreigncall_name(interp, callee.args[2], sstate, sv)
3499:            abstract_eval_nonlinearized_foreigncall_name(interp, callee.args[3], sstate, sv)
```

</details>

#### 3. Existing inference test that exercises foreigncall IR, providing a baseline behavior example (no change expected from this PR).

**Component**: Compiler.AbstractInterpretation

<details>
<summary>Evidence</summary>

**Compiler/test/inference.jl:3318-3322**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3aea6638141da3169d9384ba1c20997bcd774486/Compiler/test/inference.jl#L3318-L3322)
```julia
bar_inlining_apply() = Core._apply_iterate(iterate, Core._apply_iterate, (iterate,), (foo_inlining_apply,), ((1,),))
let ci = code_typed(bar_inlining_apply, Tuple{})[1].first
    @test length(ci.code) == 2
    @test ci.code[1].head === :foreigncall
end
```

</details>

### Secondary Effects

#### Lower chance of inference invalidations triggered by the evalargs task closure for nonlinearized foreigncall names, because captured slots are concretely typed as `Future` instead of `Any`.

**Likelihood**: medium | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
abstract_eval_foreigncall(...)  [abstractinterpretation.jl:3493-3503]
  -> abstract_eval_nonlinearized_foreigncall_name(...)  [abstractinterpretation.jl:3497-3499]
     defines evalargs closure with captured locals ai/res  [abstractinterpretation.jl:3460-3486]
     -> captured slots now typed as Future (ai::Future, res::Future)
This reduces boxed-Any slot types in the closure environment, stabilizing inference for the evalargs task.
```
</details>

**Downstream Surfaces:**
- Core.Compiler.AbstractInterpreter task scheduling
- Inference cache stability for foreigncall name evaluation

### Compatibility

#### Behavioral Changes
- No user-visible semantic change expected; this is a type-annotation in an internal inference helper.

### Performance

**Compile Time:**
- ESTIMATED: no measurable compile-time cost; adds only concrete type annotations for captured locals.

**Runtime:**
- ESTIMATED: reduces invalidation churn from inference tasks that traverse nonlinearized foreigncall names.

### Risk Assessment

**Level**: low

**Rationale:**
- Single-line type annotation in an internal inference helper; no control-flow changes.
- No tests were modified; change is intended to stabilize inference state for existing behavior.

### Recommendations

- Consider adding a targeted inference invalidation test around foreigncall name evaluation to prevent regressions.
- If future refactors remove the evalargs closure (as suggested in the PR description), verify that task scheduling still preserves this concrete typing.
