# PR #60257: [JuliaLowering] `ccall((lib,sym)...)` and `cfunction` fixes

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60257
- **Merged**: 2025-12-01 22:15 UTC
- **Labels**: `compiler:lowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60257.diff

## Scope

### Files Touched
- `JuliaLowering/src/desugaring.jl`
- `JuliaLowering/src/eval.jl`
- `JuliaLowering/src/syntax_macros.jl`
- `JuliaLowering/test/function_calls_ir.jl`
- `JuliaLowering/test/misc.jl`
- `JuliaLowering/test/misc_ir.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering
- IR Construction

## Analysis

### Intent

Fix lowering for (sym, lib) tuples in ccall/cglobal and align @cfunction handling with Base by quoting non-interpolated callables.

**Related Issues:**
- https://github.com/JuliaLang/JuliaLowering.jl/pull/36

### Direct Changes

#### 1. `expand_C_library_symbol` now wraps tuple arguments in `K"static_eval"` with per-child expansion, ensuring tuple syntax is preserved for ccall/cglobal library specs.

**Component**: JuliaLowering/src/desugaring.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/desugaring.jl:1725-1733**
[View on GitHub](https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/src/desugaring.jl#L1725-L1733)
```julia
# Expand the (sym,lib) argument to ccall/cglobal
function expand_C_library_symbol(ctx, ex)
    if kind(ex) == K"tuple"
        return @ast ctx ex [K"static_eval"(meta=name_hint("function name and library expression"))
            mapchildren(e->expand_forms_2(ctx,e), ctx, ex)
        ]
    end
    return expand_forms_2(ctx, ex)
end
```

**JuliaLowering/test/function_calls_ir.jl:366-374**
[View on GitHub](https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/test/function_calls_ir.jl#L366-L374)
```julia
# ccall with library name as a global var
ccall((:strlen, libc), Csize_t, (Cstring,), "asdfg")
#---------------------
1   TestMod.Cstring
2   (call top.cconvert %₁ "asdfg")
3   (call top.unsafe_convert %₁ %₂)
4   (foreigncall (static_eval (tuple-p :strlen TestMod.libc)) (static_eval TestMod.Csize_t) (static_eval (call core.svec TestMod.Cstring)) 0 :ccall %₃ %₂)
5   (return %₄)
```

</details>

#### 2. `_to_lowered_expr` handles `K"static_eval"` tuple/function payloads explicitly and treats `K"cfunction"` as a normal head for IR construction.

**Component**: JuliaLowering/src/eval.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/eval.jl:413-445**
[View on GitHub](https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/src/eval.jl#L413-L445)
```julia
elseif k == K"static_eval"
    @assert numchildren(ex) == 1
    if kind(ex[1]) === K"tuple"
        # Should just be ccall library spec
        @assert numchildren(ex[1]) === 2
        Expr(:tuple, _to_lowered_expr(ex[1][1], stmt_offset),
             _to_lowered_expr(ex[1][2], stmt_offset))
    elseif kind(ex[1]) === K"function"
        QuoteNode(Expr(ex))
    else
        _to_lowered_expr(ex[1], stmt_offset)
    end
else
    # Allowed forms according to https://docs.julialang.org/en/v1/devdocs/ast/
    #
    # call invoke static_parameter `=` method struct_type abstract_type
    # primitive_type global const new splatnew isdefined
    # enter leave pop_exception inbounds boundscheck loopinfo copyast meta
    # lambda
    head = k == K"call"      ? :call       :
           k == K"new"       ? :new        :
           k == K"splatnew"  ? :splatnew   :
           k == K"="         ? :(=)        :
           k == K"leave"     ? :leave      :
           k == K"isdefined" ? :isdefined  :
           k == K"latestworld"       ? :latestworld       :
           k == K"pop_exception"     ? :pop_exception     :
           k == K"captured_local"    ? :captured_local    :
           k == K"gc_preserve_begin" ? :gc_preserve_begin :
           k == K"gc_preserve_end"   ? :gc_preserve_end   :
           k == K"foreigncall"       ? :foreigncall       :
           k == K"cfunction"         ? :cfunction         :
           k == K"new_opaque_closure" ? :new_opaque_closure :
           nothing
```

**JuliaLowering/test/function_calls_ir.jl:519-525**
[View on GitHub](https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/test/function_calls_ir.jl#L519-L525)
```julia
# cglobal special support for (sym, lib) tuple
cglobal((:sym, lib), Int)
#---------------------
1   TestMod.Int
2   (call core.cglobal (static_eval (tuple-p :sym TestMod.lib)) %₁)
3   (return %₂)
```

</details>

#### 3. `@cfunction` now wraps non-interpolated callables in `K"inert"` with `CompileHints(:as_Expr, true)` to preserve expression form.

**Component**: JuliaLowering/src/syntax_macros.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/syntax_macros.jl:80-110**
[View on GitHub](https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/src/syntax_macros.jl#L80-L110)
```julia
function Base.var"@cfunction"(__context__::MacroContext, callable, return_type, arg_types)
    if kind(arg_types) != K"tuple"
        throw(MacroExpansionError(arg_types, "@cfunction argument types must be a literal tuple"))
    end
    arg_types_svec = @ast __context__ arg_types [K"call"
        "svec"::K"core"
        children(arg_types)...
    ]
    if kind(callable) == K"$"
        fptr = callable[1]
        typ = Base.CFunction
    else
        # Kinda weird semantics here - without `$`, the callable is a top level
        # expression evaluated within the module where the `@cfunction` is
        # expanded into.
        fptr = @ast __context__ callable [K"inert"(
                meta=CompileHints(:as_Expr, true))
            callable
        ]
        typ = Ptr{Cvoid}
    end
    @ast __context__ __context__.macrocall [K"cfunction"
        typ::K"Value"
        fptr
        [K"static_eval"(meta=name_hint("cfunction return type"))
            return_type
        ]
        [K"static_eval"(meta=name_hint("cfunction argument type"))
            arg_types_svec
        ]
        "ccall"::K"Symbol"
    ]
end
```

**JuliaLowering/test/misc_ir.jl:354-359**
[View on GitHub](https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/test/misc_ir.jl#L354-L359)
```julia
# @cfunction expansion with global generic function as function argument
@cfunction(callable, Int, (Int, Float64))
#---------------------
1   (cfunction Ptr{Nothing} (inert callable) (static_eval TestMod.Int) (static_eval (call core.svec TestMod.Int TestMod.Float64)) :ccall)
2   (return %₁)
```

</details>

### Secondary Effects

#### `ccall`/`cglobal` library tuple specs are emitted as tuple syntax instead of a Core.Tuple call, aligning IR shape with Base and preserving literal tuple intent.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
expand_C_library_symbol(ctx, ex) [desugaring.jl:1726-1733]
  returns K"static_eval" over tuple children
-> expand_ccall emits K"foreigncall" with expand_C_library_symbol(ctx, cfunc_name)
   [desugaring.jl:1840-1845]
-> _to_lowered_expr handles K"static_eval" tuple payloads as Expr(:tuple)
   [eval.jl:413-419]
rg results for callers:
  JuliaLowering/src/desugaring.jl:1726:function expand_C_library_symbol(ctx, ex)
  JuliaLowering/src/desugaring.jl:1843:            expand_C_library_symbol(ctx, cfunc_name)
  JuliaLowering/src/desugaring.jl:1908:            expand_C_library_symbol(ctx, ex[2])
```
</details>

**Downstream Surfaces:**
- IR pattern matchers that expect Core.Tuple in foreigncall/cglobal paths
- FFI wrapper generators relying on lowering IR shapes

#### Non-interpolated `@cfunction` callables are now preserved as quoted expressions, improving hygiene and enabling function literal callables in lowering.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
@cfunction macro wraps callable in K"inert" with CompileHints(:as_Expr, true)
  [syntax_macros.jl:80-100]
-> _to_lowered_expr handles K"inert" by emitting QuoteNode(Expr(e1)) when :as_Expr is true
  [eval.jl:369-371]
-> cfunction IR now carries (inert callable), keeping the expression form
  [misc_ir.jl:354-359]
```
</details>

**Downstream Surfaces:**
- Macro expansions that depend on @cfunction hygiene in nested modules
- Users passing anonymous/quoted functions to @cfunction

### Compatibility

#### Behavioral Changes
- Static eval now yields tuple syntax (tuple-p) rather than Core.Tuple calls.
- Hygiene follows Base behavior; non-interpolated symbol resolves in the expansion module, and quoted function literals are accepted.

### Performance

**Compile Time:**
- ESTIMATED: negligible

**Runtime:**
- ESTIMATED: none

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are localized to JuliaLowering desugaring and eval paths.
- New tests cover ccall/cglobal tuple IR and @cfunction hygiene/quoted callables.

### Recommendations

- Downstream IR analyzers should accept tuple syntax (tuple-p) for ccall/cglobal library specs instead of matching Core.Tuple calls.
- Macro tooling that inspects @cfunction callables should handle inert/quoted expressions (QuoteNode(Expr(...))).
