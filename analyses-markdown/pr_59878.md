# PR #59878: fix accidental save (and restore) of sigmask when interpreting try

## Metadata

- **Author**: vtjnash
- **URL**: https://github.com/JuliaLang/julia/pull/59878
- **Merged**: 2025-10-19 00:55 UTC
- **Labels**: `system:mac`, `backport 1.10`, `backport 1.11`
- **Diff**: https://github.com/JuliaLang/julia/pull/59878.diff

## Scope

### Files Touched
- `src/interpreter.c`

### Components
- Interpreter

### Pipeline Stages
- Interpreter
- ExceptionHandling

## Analysis

### Intent

Stop the interpreter's try handling from saving/restoring the signal mask when entering :enter blocks, avoiding unintended sigmask restoration and potential overhead.

**Related Issues:**
- https://github.com/ericphanson/LicenseCheck.jl/issues/11#issuecomment-3417207015

### Direct Changes

#### 1. Interpreter :enter handling now calls jl_setjmp with save_sigmask=0 for both scoped and unscoped try blocks.

**Component**: Interpreter

<details>
<summary>Evidence</summary>

**src/interpreter.c:540-560**
[View on GitHub](https://github.com/JuliaLang/julia/blob/cc49ff5e586bbf6af9f8bcad769083f74a4e7796/src/interpreter.c#L540-L560)
```julia
s->locals[jl_source_nslots(s->src) + ip] = jl_box_ulong(jl_excstack_state(ct));
if (jl_enternode_scope(stmt)) {
    jl_value_t *scope = eval_value(jl_enternode_scope(stmt), s);
    JL_GC_PUSH1(&scope);
    ct->scope = scope;
    if (!jl_setjmp(__eh.eh_ctx, 0)) {
        ct->eh = &__eh;
        eval_body(stmts, s, next_ip, toplevel);
        jl_unreachable();
    }
    JL_GC_POP();
}
else {
    if (!jl_setjmp(__eh.eh_ctx, 0)) {
        ct->eh = &__eh;
        eval_body(stmts, s, next_ip, toplevel);
        jl_unreachable();
    }
}
```

</details>

#### 2. Unix jl_setjmp resolves to sigsetjmp(a, b), so the second argument controls signal-mask saving.

**Component**: Runtime

<details>
<summary>Evidence</summary>

**src/julia.h:2379-2388**
[View on GitHub](https://github.com/JuliaLang/julia/blob/cc49ff5e586bbf6af9f8bcad769083f74a4e7796/src/julia.h#L2379-L2388)
```julia
// determine actual entry point name
#if defined(sigsetjmp)
#define jl_setjmp_f    __sigsetjmp
#define jl_setjmp_name "__sigsetjmp"
#else
#define jl_setjmp_f    sigsetjmp
#define jl_setjmp_name "sigsetjmp"
#endif
#define jl_setjmp(a,b) sigsetjmp(a,b)
```

</details>

#### 3. Interpreter try/finally coverage in tests (used as a concrete before/after example of interpreter try behavior).

**Component**: Tests

<details>
<summary>Evidence</summary>

**test/interpreter.jl:5-19**
[View on GitHub](https://github.com/JuliaLang/julia/blob/cc49ff5e586bbf6af9f8bcad769083f74a4e7796/test/interpreter.jl#L5-L19)
```julia
# interpreted but inferred/optimized top-level expressions with vars
let code = """
           while true
               try
                   this_is_undefined_29213
                   ed = 0
                   break
               finally
                   break
               end
           end
           print(42)
           """
    @test read(`$(Base.julia_cmd()) --startup-file=no --compile=min -e $code`, String) == "42"
end
```

</details>

### Secondary Effects

#### Interpreter-executed try blocks no longer save/restore the POSIX signal mask when entering the handler.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
eval_body(...) enter handling  [src/interpreter.c:540-560]
  -> jl_setjmp(__eh.eh_ctx, 0)  [src/interpreter.c:548,556]
  -> jl_setjmp macro maps to sigsetjmp(a, b) on Unix  [src/julia.h:2379-2388]
  -> b=0 prevents saving/restoring the signal mask (inferred from sigsetjmp semantics)
```
</details>

**Downstream Surfaces:**
- Signal handling behavior during interpreter-executed try/catch
- Interpreter performance for code with frequent try blocks
- macOS-specific signal mask behavior (label system:mac)

### Compatibility

#### Behavioral Changes
- Interpreter exceptions no longer restore a saved signal mask when unwinding through :enter blocks.

### Performance

**Runtime:**
- {'change': 'Avoids sigsetjmp signal-mask save/restore in interpreter try handling.', 'estimate': 'ESTIMATED: small reduction in overhead per interpreted try/enter on Unix/macOS.'}

### Risk Assessment

**Level**: low

**Rationale:**
- Change is a small argument tweak in interpreter-only control-flow setup.
- Scoped/unscoped try paths both updated consistently to avoid divergence.

### Recommendations

- Consider adding a regression test that validates signal mask state around interpreter-executed try/catch on macOS.
- If regressions appear, audit other jl_setjmp call sites that still pass save_sigmask=1 in interpreter paths.
