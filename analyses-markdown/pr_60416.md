# PR #60416: lowering: Fix `@nospecialize` on unnamed arguments

## Metadata

- **Author**: aviatesk
- **URL**: https://github.com/JuliaLang/julia/pull/60416
- **Merged**: 2026-01-07 17:50 UTC
- **Diff**: https://github.com/JuliaLang/julia/pull/60416.diff

## Scope

### Files Touched
- `src/julia-syntax.scm`
- `Compiler/test/inline.jl`

### Components
- JuliaSyntax
- Compiler.test

### Pipeline Stages
- Parsing
- Lowering

## Analysis

### Intent

Ensure @nospecialize annotations on unnamed positional and keyword arguments are bound to the generated argument names during lowering.

**Related Issues:**
- https://github.com/JuliaLang/julia/issues/44428

### Direct Changes

#### 1. For keyword methods, fill in missing argument names inside @nospecialize metadata before extracting annotations, so the annotations reference the generated name rather than the placeholder.

**Component**: JuliaSyntax

<details>
<summary>Evidence</summary>

**src/julia-syntax.scm:463-479**
[View on GitHub](https://github.com/JuliaLang/julia/blob/764725073af129a6423aeeca95fec1d8a221a2f1/src/julia-syntax.scm#L463-L479)
```julia
(define (keywords-method-def-expr name sparams argl body rett)
  (let* ((kargl (cdar argl))  ;; keyword expressions (= k v)
         ;; fill in missing argnames for nospecialize-wrapped args first,
         ;; so that annotations reference the correct generated names
         (kargl (map (lambda (a)
                       (if (nospecialize-meta? a)
                           (let ((inner (caddr a)))  ;; the (kw ...) expression
                             `(meta ,(cadr a) (,(car inner)
                                               ,(fill-missing-argname (cadr inner) #f)
                                               ,@(cddr inner))))
                           a))
                     kargl))
         (annotations (map (lambda (a) `(meta ,(cadr a) ,(arg-name (cadr (caddr a)))))
                           (filter nospecialize-meta? kargl)))
         (kargl (map (lambda (a)
                       (if (nospecialize-meta? a) (caddr a) a))
                     kargl))
```

</details>

#### 2. For positional arguments in function definitions, fill in missing argnames inside @nospecialize metadata before stripping the annotation and emitting meta nodes into the body.

**Component**: JuliaSyntax

<details>
<summary>Evidence</summary>

**src/julia-syntax.scm:1214-1230**
[View on GitHub](https://github.com/JuliaLang/julia/blob/764725073af129a6423aeeca95fec1d8a221a2f1/src/julia-syntax.scm#L1214-L1230)
```julia
((eq? (car name) 'call)
 (let* ((raw-typevars (or where '()))
        (sparams (map analyze-typevar raw-typevars))
        (argl    (cdr name))
        ;; fill in missing argnames for nospecialize-wrapped args first,
        ;; so that annotations reference the correct generated names
        (argl    (map (lambda (a)
                        (if (nospecialize-meta? a)
                            `(meta ,(cadr a) ,(fill-missing-argname (caddr a) #f))
                            a))
                      argl))
        ;; strip @nospecialize
        (annotations (map (lambda (a) `(meta ,(cadr a) ,(arg-name (caddr a))))
                          (filter nospecialize-meta? argl)))
        (body (insert-after-meta (caddr e) annotations))
        (argl (map (lambda (a)
                     (if (nospecialize-meta? a) (caddr a) a))
                   argl))
```

</details>

#### 3. Add compiler test coverage asserting that @nospecialize on unnamed arguments forces invoke-based calls in typed IR.

**Component**: Compiler.test

<details>
<summary>Evidence</summary>

**Compiler/test/inline.jl:2348-2362**
[View on GitHub](https://github.com/JuliaLang/julia/blob/764725073af129a6423aeeca95fec1d8a221a2f1/Compiler/test/inline.jl#L2348-L2362)
```julia
# @nospecialize annotation on uunamed arguments
# https://github.com/JuliaLang/julia/issues/44428
@noinline _issue44428_1(@nospecialize _::Any) = println(Base.inferencebarrier(0))
@noinline _issue44428_2(@nospecialize ::Any) = println(Base.inferencebarrier(0))
@noinline _issue44428_3(@nospecialize _) = println(Base.inferencebarrier(0))
function issue44428(x)
    _issue44428_1(x)
    _issue44428_2(x)
    _issue44428_3(x)
end
let src = code_typed1(issue44428, (Any,))
    @test count(isinvoke(:_issue44428_1), src.code) == 1
    @test count(isinvoke(:_issue44428_2), src.code) == 1
    @test count(isinvoke(:_issue44428_3), src.code) == 1
    @test count(x->Meta.isexpr(x,:call), src.code) == 0
end
```

</details>

### Secondary Effects

#### @nospecialize on unnamed positional arguments now reliably attaches to the synthesized argument name, preventing accidental specialization of those parameters.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
expand-function-def-  [src/julia-syntax.scm:1214-1230]
  fills missing argnames inside (meta :nospecialize ...) forms
-> annotations extracted via (arg-name (caddr a)) and inserted into body
   with insert-after-meta  [src/julia-syntax.scm:1225-1228]
-> lowering emits meta nodes that the compiler honors for specialization
```
</details>

**Downstream Surfaces:**
- Method specialization (inference uses @nospecialize meta)
- Inlining heuristics (invoke vs call selection)

#### @nospecialize on unnamed keyword arguments is normalized before keyword method expansion, so annotations reference generated keyword arg symbols instead of placeholders.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
keywords-method-def-expr  [src/julia-syntax.scm:463-479]
  rewrites (meta :nospecialize (kw name ...)) by filling missing argnames
-> annotations list is built from the rewritten keyword arguments
-> keyword-lowering uses these annotations when emitting methods
```
</details>

**Downstream Surfaces:**
- Keyword sorter dispatch (specialization hints)
- Method cache invalidation patterns for kw wrappers

### Compatibility

#### Behavioral Changes
- Typed IR for functions with unnamed @nospecialize arguments now uses invokes for those calls; prior to the fix, missing argnames could drop the annotation and produce direct calls.

### Performance

**Compile Time:**
- ESTIMATED: O(n) additional map over arg lists in lowering for each function definition and keyword method; negligible compared to overall lowering cost.

**Runtime:**
- ESTIMATED: Restores expected de-specialization, which may reduce method proliferation and cache pressure in code that used unnamed @nospecialize arguments.

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are localized to argument list preprocessing in the scheme lowerer and validated by new tests.

### Recommendations

- Downstream tools that inspect method IR for invoke vs call patterns (e.g., static analyzers) should add coverage for @nospecialize on unnamed args to match the new test behavior.
