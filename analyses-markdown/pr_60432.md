# PR #60432: [JuliaLowering] fix `@nospecialize` on unnamed arguments

## Metadata

- **Author**: aviatesk
- **URL**: https://github.com/JuliaLang/julia/pull/60432
- **Merged**: 2025-12-22 18:47 UTC
- **Diff**: https://github.com/JuliaLang/julia/pull/60432.diff

## Scope

### Files Touched
- `JuliaLowering/src/desugaring.jl`
- `JuliaLowering/src/linear_ir.jl`
- `JuliaLowering/test/functions.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering
- LinearIR

## Analysis

### Intent

Propagate @nospecialize metadata for placeholder (unnamed) arguments through lowering and linear IR so the resulting Method nospecialize bitset matches user annotations.

**Related Issues:**
- https://github.com/JuliaLang/julia/issues/44428

### Direct Changes

#### 1. Desugaring now copies :nospecialize metadata onto synthesized placeholder argument bindings so unnamed arguments preserve @nospecialize during lowering.

**Component**: JuliaLowering desugaring

<details>
<summary>Evidence</summary>

**JuliaLowering/src/desugaring.jl:2330-2339**
[View on GitHub](https://github.com/JuliaLang/julia/blob/b7a217c55c07d7c975b2d1250f832731c2053284/JuliaLowering/src/desugaring.jl#L2330-L2339)
```julia
elseif k == K"Placeholder"
    # Lowering should be able to use placeholder args as rvalues internally,
    # e.g. for kw method dispatch.  Duplicate positional placeholder names
    # should be allowed.
    is_nospecialize = getmeta(ex, :nospecialize, false)
    name = if is_kw
        @ast ctx ex ex=>K"Identifier"
    else
        new_local_binding(ctx, ex, "#arg$(string(arg_id))#"; kind=:argument,
                          is_nospecialize=is_nospecialize)
    end
```

</details>

#### 2. Linear IR slots for placeholder arguments now read :nospecialize metadata directly, ensuring CodeInfo meta is emitted for unnamed arguments.

**Component**: JuliaLowering linear_ir

<details>
<summary>Evidence</summary>

**JuliaLowering/src/linear_ir.jl:1065-1070**
[View on GitHub](https://github.com/JuliaLang/julia/blob/b7a217c55c07d7c975b2d1250f832731c2053284/JuliaLowering/src/linear_ir.jl#L1065-L1070)
```julia
for arg in children(lambda_args)
    if kind(arg) == K"Placeholder"
        # Unused functions arguments like: `_` or `::T`
        push!(slots, Slot(arg.name_val, :argument, getmeta(arg, :nospecialize, false),
                          false, false, false, false))
```

</details>

### Secondary Effects

#### @nospecialize on unnamed arguments now survives all the way to emitted CodeInfo meta, so Method.nospecialize bitsets reflect placeholder annotations.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
expand_function_arg(...) [desugaring.jl:2330-2339]
  -> new_local_binding(..., is_nospecialize=...) [bindings.jl:132-143]
  -> compile_lambda(...) builds Slot(..., is_nospecialize=...) for placeholders [linear_ir.jl:1065-1070]
  -> _to_codeinfo emits Expr(:meta, :nospecialize, Core.SlotNumber(i)) when slot.is_nospecialize [eval.jl:246-250]
```
</details>

**Downstream Surfaces:**
- Method.nospecialize bitset
- CodeInfo :nospecialize meta on placeholder slots

### Compatibility

#### Internal API Changes
- **Field**: 

#### Behavioral Changes
- {'impact': 'User code with @nospecialize on unnamed arguments now produces the expected nospecialize bitmask in tests, aligning runtime specialization behavior with annotations.', 'evidence': [{'source': 'test', 'path': 'JuliaLowering/test/functions.jl', 'loc': '328-334', 'url': 'https://github.com/JuliaLang/julia/blob/b7a217c55c07d7c975b2d1250f832731c2053284/JuliaLowering/test/functions.jl#L328-L334', 'snippet': '# @nospecialize on unnamed arguments (issue #44428)\nJuliaLowering.include_string(test_mod, """\nfunction f_nospecialize_unnamed(@nospecialize(::Any), @nospecialize(x::Any))\n    x\nend\n""")\n@test only(methods(test_mod.f_nospecialize_unnamed)).nospecialize == 0b11\n'}]} *(Impact: User code with @nospecialize on unnamed arguments now produces the expected nospecialize bitmask in tests, aligning runtime specialization behavior with annotations.)*

### Performance

**Compile Time:**
- ESTIMATED: slightly reduced specialization work for methods that use unnamed @nospecialize arguments (now correctly marked), which can lower method instance churn in codegen.

**Runtime:**
- ESTIMATED: no runtime behavior change beyond honoring the existing @nospecialize annotation; specialization decisions align with user intent.

### Risk Assessment

**Level**: low

**Rationale:**
- Change is limited to propagating existing metadata for placeholder arguments and is guarded by tests for Method.nospecialize.
- No changes to inference or optimization passes beyond carrying metadata into slots.

### Recommendations

- Downstream tooling that inspects Method.nospecialize should include placeholder (unnamed) arguments in its expectations going forward.
