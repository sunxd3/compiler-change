# PR #60646: [JuliaLowering] Avoid analyzing variables 'owned' by outer closures

## Metadata

- **Author**: topolarity
- **URL**: https://github.com/JuliaLang/julia/pull/60646
- **Merged**: 2026-01-12 21:47 UTC
- **Labels**: `JuliaLowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60646.diff

## Scope

### Files Touched
- `JuliaLowering/src/binding_analysis.jl`
- `JuliaLowering/test/closures.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering

## Analysis

### Intent

Skip def-use analysis for variables that belong to an outer lambda so closure boxing decisions are not based on inner-lambda captures of outer-owned locals.

**Related Issues:**
- https://github.com/JuliaLang/JuliaLowering.jl/issues/134#issuecomment-3739626003

### Direct Changes

#### 1. Filter def-use candidates to exclude locals captured from an outer lambda; only analyze locals owned by the current lambda that are captured and single-assigned.

**Component**: JuliaLowering/src/binding_analysis.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/binding_analysis.jl:65-83**
[View on GitHub](https://github.com/JuliaLang/julia/blob/65eade52d8cabc43d1f8be4a9f7781b6e66eed7e/JuliaLowering/src/binding_analysis.jl#L65-L83)
```julia
function _analyze_lambda_vars!(ctx, ex)
    lambda_bindings = ex.lambda_bindings

    # Collect candidate variables: captured and single-assigned
    candidates = Set{IdTag}()
    for (id, from_outer_lambda) in lambda_bindings.locals_capt
        binfo = get_binding(ctx, id)
        maybe_boxed = binfo.is_captured && binfo.kind in (:local, :argument)
        safe_to_analyze = binfo.is_assigned_once
        if !from_outer_lambda && maybe_boxed && safe_to_analyze
            push!(candidates, id)
            # For arguments, reset is_always_defined so we can determine if the
            # outer-scope assignment dominates the capture. Arguments start with
            # is_always_defined=true, but if they're reassigned inside a closure
            # (not in outer scope), we need the def-use analysis to decide.
            if binfo.kind == :argument
                binfo.is_always_defined = false
            end
        end
    end
```

</details>

#### 2. Add a regression test ensuring an outer local mutated inside an inner closure stays boxed and the outer value updates correctly.

**Component**: JuliaLowering/test/closures.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/test/closures.jl:475-488**
[View on GitHub](https://github.com/JuliaLang/julia/blob/65eade52d8cabc43d1f8be4a9f7781b6e66eed7e/JuliaLowering/test/closures.jl#L475-L488)
```julia
JuliaLowering.include_string(test_mod, """
function f_update_outer_capture()
    local response # declare outside closure
    f = ()->begin
        response = 1
    end
    f()
    return (f, response)
end
""")
let (f, response) = test_mod.f_update_outer_capture()
    @test f.response isa Core.Box
    @test response == 1
end
```

</details>

### Secondary Effects

#### Outer-scope locals that are only captured by inner lambdas are no longer reclassified as 'always defined' by def-use analysis, so they remain boxed in closure conversion.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
analyze_def_and_use!(ctx, ex)  [binding_analysis.jl:39-52]
  -> _analyze_lambda_vars!(ctx, ex)  [binding_analysis.jl:65-85]
     skips locals_capt entries where from_outer_lambda=true
  -> is_boxed(binfo)  [closure_conversion.jl:304-317]
     uses is_always_defined && is_assigned_once to suppress boxing
  -> closure_type_fields(...)  [closure_conversion.jl:234-279]
     field_is_box = is_boxed(ctx, id) for captured variables
```
</details>

**Downstream Surfaces:**
- Closure field layout (boxed vs unboxed captures)
- OpaqueClosure capture representation

### Compatibility

#### Internal API Changes
- **BindingInfo.is_always_defined**: Flags for outer-scope captured locals are no longer recalculated by _analyze_lambda_vars!, so tooling that inspects binding flags will see fewer 'always defined' captures for those cases.

#### Behavioral Changes
- Captures of outer-scope locals mutated inside an inner closure remain boxed; regressions are covered by the new f_update_outer_capture test.

### Performance

**Compile Time:**
- ESTIMATED: negligible; candidate filtering is a constant-time predicate on existing locals_capt entries.

**Runtime:**
- ESTIMATED: slight increase in boxing (allocations) for the corrected outer-capture case, offset by correctness.

### Risk Assessment

**Level**: low

**Rationale:**
- Change is localized to candidate selection in binding analysis and adds a targeted regression test.

### Recommendations

- Downstream tooling that assumes unboxed captures for single-assigned locals should account for outer-scope captures remaining boxed in this pattern.
