# PR #60567: [JuliaLowering] Implement flisp-compatible Box optimization

## Metadata

- **Author**: aviatesk
- **URL**: https://github.com/JuliaLang/julia/pull/60567
- **Merged**: 2026-01-10 01:21 UTC
- **Labels**: `JuliaLowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60567.diff

## Scope

### Files Touched
- `JuliaLowering/src/JuliaLowering.jl`
- `JuliaLowering/src/binding_analysis.jl`
- `JuliaLowering/src/scope_analysis.jl`
- `JuliaLowering/src/closure_conversion.jl`
- `JuliaLowering/test/closures.jl`
- `JuliaLowering/test/closures_ir.jl`
- `JuliaLowering/test/scopes_ir.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering
- ClosureConversion

## Analysis

### Intent

Implement a JuliaLowering def-use pass that mirrors flisp's lambda-optimize-vars! so captured, single-assigned locals/arguments avoid Core.Box allocations and reduce false-positive boxed-variable diagnostics.

**Related Issues:**
- https://github.com/aviatesk/JETLS.jl/pull/452
- https://github.com/JuliaLang/julia/issues/37690

### Direct Changes

#### 1. Added a new tree-based def/use pass (analyze_def_and_use!) that tracks captured single-assigned locals/arguments and marks them is_always_defined when proven always-defined and not modified after capture.

**Component**: JuliaLowering/binding_analysis

<details>
<summary>Evidence</summary>

**JuliaLowering/src/binding_analysis.jl:28-88**
[View on GitHub](https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/binding_analysis.jl#L28-L88)
```julia
"""
    analyze_def_and_use!(ctx, ex)

Perform tree-based def-use analysis to find captured variables that are
assigned before any closure captures them (never-undef) and not modified
afterward. For such variables, as an abuse of binding flags we can mark them
as `is_always_defined=true` to avoid unnecessary `Core.Box` allocations during
closure conversion.

This is called on the outermost lambda, and recursively processes nested lambdas.
"""
function analyze_def_and_use!(ctx, ex)
    k = kind(ex)
    if k != K"lambda"
        return
    end

    # First, recursively analyze nested lambdas (depth-first)
    if numchildren(ex) >= 3
        _analyze_nested_lambdas!(ctx, ex[3])
    end

    # Now analyze this lambda
    _analyze_lambda_vars!(ctx, ex)
end

function _analyze_lambda_vars!(ctx, ex)
    lambda_bindings = ex.lambda_bindings

    # Collect candidate variables: captured and single-assigned
    candidates = Set{IdTag}()
    for (id, _) in lambda_bindings.locals_capt
        binfo = get_binding(ctx, id)
        if (binfo.is_captured && binfo.is_assigned_once &&
            (binfo.kind == :local || binfo.kind == :argument))
            push!(candidates, id)
            if binfo.kind == :argument
                binfo.is_always_defined = false
            end
        end
    end
    isempty(candidates) && return
```

**JuliaLowering/src/binding_analysis.jl:111-152**
[View on GitHub](https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/binding_analysis.jl#L111-L152)
```julia
# At CFG merge points, we lose certainty about which path was taken,
# so variables assigned in one branch may not have been assigned.
function kill!()
    union!(unused, live)
    empty!(live)
end

# Restore live to a previous state, moving new additions back to unused
function restore!(prev)
    for id in decl_outside_loop
        if (id in prev) && !(id in unused)
            delete!(prev, id)
        end
    end
    for id in live
        if !(id in prev)
            push!(unused, id)
        end
    end
    empty!(live)
    union!(live, prev)
end

# At the beginning of a loop, move all active decls into the "decl_outside_loop" set.
function enter_loop!()
    prev_decl_outside_loop = decl_outside_loop
    decl_outside_loop = decl
    decl = copy(decl)
    return prev_decl_outside_loop
end

# At the end of a loop, restore the previous set of "declared" variables.
function leave_loop!(prev_decl_outside_loop)
    decl = decl_outside_loop
    decl_outside_loop = prev_decl_outside_loop
end
```

**JuliaLowering/src/binding_analysis.jl:262-338**
[View on GitHub](https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/binding_analysis.jl#L262-L338)
```julia
elseif k in KSet"if elseif trycatchelse tryfinally"
    prev = copy(live)
    has_label = false
    for child in children(e)
        has_label |= visit(child)
        kill!()
    end
    if has_label
        return true
    else
        restore!(prev)
        return false
    end

elseif k in KSet"_while _do_while"
    prev = copy(live)
    old_decl = enter_loop!()
    has_label = false
    for child in children(e)
        has_label |= visit(child)
    end
    leave_loop!(old_decl)
    if has_label
        kill!()
        return true
    else
        restore!(prev)
        return false
    end
end

# Variables in live or unused (that were seen assigned) are never-undef
for id in union(live, unused)
    if id in seen
        get_binding(ctx, id).is_always_defined = true
    end
end
```

</details>

#### 2. Scope resolution now runs analyze_def_and_use! after analyze_variables!, and the new binding_analysis pass is included in JuliaLowering.jl.

**Component**: JuliaLowering/scope_analysis

<details>
<summary>Evidence</summary>

**JuliaLowering/src/JuliaLowering.jl:26-38**
[View on GitHub](https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/JuliaLowering.jl#L26-L38)
```julia
_include("kinds.jl")
_register_kinds()

_include("ast.jl")
_include("bindings.jl")
_include("utils.jl")

_include("macro_expansion.jl")
_include("desugaring.jl")
_include("scope_analysis.jl")
_include("binding_analysis.jl")
_include("closure_conversion.jl")
```

**JuliaLowering/src/scope_analysis.jl:711-718**
[View on GitHub](https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/scope_analysis.jl#L711-L718)
```julia
@fzone "JL: resolve_scopes" function resolve_scopes(ctx::DesugaringContext, ex)
    ctx2 = ScopeResolutionContext(ctx, ex)
    ex2 = resolve_scopes(ctx2, reparent(ctx2, ex))
    ctx3 = VariableAnalysisContext(
        ctx2.graph, ctx2.bindings, ctx2.mod, ctx2.scopes, ex2.lambda_bindings)
    analyze_variables!(ctx3, ex2)
    analyze_def_and_use!(ctx3, ex2)
    ctx3, ex2
end
```

**rg output:analyze_def_and_use**
[View on GitHub](https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/scope_analysis.jl#L717)
```julia
julia/JuliaLowering/src/scope_analysis.jl
717:    analyze_def_and_use!(ctx3, ex2)

julia/JuliaLowering/src/binding_analysis.jl
29:    analyze_def_and_use!(ctx, ex)
39:function analyze_def_and_use!(ctx, ex)
57:        analyze_def_and_use!(ctx, ex)
```

</details>

#### 3. Closure boxing decisions now treat captured single-assigned locals/arguments marked is_always_defined as unboxed, altering whether Core.Box is used in closure conversion.

**Component**: JuliaLowering/closure_conversion

<details>
<summary>Evidence</summary>

**JuliaLowering/src/closure_conversion.jl:304-316**
[View on GitHub](https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/src/closure_conversion.jl#L304-L316)
```julia
function is_boxed(binfo::BindingInfo)
    # No box needed for:
    # * :argument when it's not reassigned
    # * :static_parameter (these can't be reassigned)
    defined_but_not_assigned = binfo.is_always_defined && !binfo.is_assigned
    # * Single-assigned variables (local or argument) assigned before any closure captures them
    #   (identified by liveness analysis in optimize_captured_vars!)
    #   For arguments, the liveness analysis resets is_always_defined and only sets it back
    #   if the outer-scope assignment dominates all captures. This distinguishes arguments
    #   reassigned in outer scope (no box) from those reassigned only inside closures (needs box).
    single_assigned_never_undef = binfo.kind in (:local, :argument) &&
                                  binfo.is_always_defined && binfo.is_assigned_once
    return binfo.is_captured && !defined_but_not_assigned && !single_assigned_never_undef
end
```

</details>

#### 4. New IR tests demonstrate unboxed captures for control-flow patterns (if, ternary, guard) and show labels still require boxing.

**Component**: JuliaLowering/tests

<details>
<summary>Evidence</summary>

**JuliaLowering/test/closures_ir.jl:779-821**
[View on GitHub](https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/test/closures_ir.jl#L779-L821)
```julia
########################################
# Assignment after if statement doesn't need Box (flisp-compatible save/restore)
function f_after_if(cond)
    if cond
        println("hello")
    end
    y = 1
    () -> y
end
#---------------------
20  --- method core.nothing %₁₉
    slots: [slot₁/#self#(!read) slot₂/cond slot₃/y(single_assign)]
    1   (gotoifnot slot₂/cond label₄)
    2   TestMod.println
    3   (call %₂ "hello")
    4   (= slot₃/y 1)
    5   TestMod.#f_after_if#->##0
    6   (call core.typeof slot₃/y)
    7   (call core.apply_type %₅ %₆)
    8   (new %₇ slot₃/y)
    9   (return %₈)
```

**JuliaLowering/test/closures_ir.jl:976-1008**
[View on GitHub](https://github.com/JuliaLang/julia/blob/8ca9bc66edc471d265657eca9e5682e343e16d4d/JuliaLowering/test/closures_ir.jl#L976-L1008)
```julia
########################################
# Label can be jumped to, bypassing assignment - needs Box
let
    @goto L
    y = 1
    @label L
    ()->y
end
#---------------------
1   (= slot₁/y (call core.Box))
2   (goto label₆)
3   1
4   slot₁/y
5   (call core.setfield! %₄ :contents %₃)
6   (call core.svec :y)
7   (call core.svec true)
8   (call JuliaLowering.eval_closure_type TestMod :#->##1 %₆ %₇)
9   latestworld
10  TestMod.#->##1
11  slot₁/y
12  (new %₁₀ %₁₁)
13  TestMod.#->##1
14  (call core.svec %₁₃)
15  (call core.svec)
16  SourceLocation::5:5
17  (call core.svec %₁₄ %₁₅ %₁₆)
18  --- method core.nothing %₁₇
    slots: [slot₁/#self#(!read) slot₂/y(!read,maybe_undef)]
    1   (call core.getfield slot₁/#self# :y)
    2   (call core.isdefined %₁ :contents)
    3   (gotoifnot %₂ label₅)
    4   (goto label₇)
    5   (newvar slot₂/y)
    6   slot₂/y
    7   (call core.getfield %₁ :contents)
    8   (return %₇)
```

</details>

### Secondary Effects

#### Captured locals/arguments that are single-assigned can now become unboxed, changing closure field layout (boxed vs unboxed fields) and the IR for closure construction.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
resolve_scopes(...) runs analyze_def_and_use!(ctx3, ex2)  [scope_analysis.jl:711-718]
  -> analyze_def_and_use! marks get_binding(ctx, id).is_always_defined = true for seen single-assign captures  [binding_analysis.jl:334-338]
  -> is_boxed(binfo) treats is_always_defined && is_assigned_once as unboxed  [closure_conversion.jl:304-316]
  -> closure_type_fields(...) collects field_is_box = is_boxed(...) for closure layout  [closure_conversion.jl:275-282]
  -> type_for_closure uses field_is_box to build the closure type  [closure_conversion.jl:288-300]
```
</details>

**Downstream Surfaces:**
- Closure field layout (boxed vs unboxed captured vars)
- OpaqueClosure type parameters and capture allocation
- Lowered IR in JuliaLowering/test/closures_ir.jl

#### isdefined checks and newvar emission for captured locals can change when variables become unboxed and always-defined, affecting diagnostics and IR shape for closure bodies.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
is_boxed(binfo) uses is_always_defined to decide boxing  [closure_conversion.jl:304-316]
  -> _convert_closures treats captured unboxed vars as always defined and returns `true` for isdefined  [closure_conversion.jl:363-377]
  -> local declarations emit newvar only when !binfo.is_always_defined  [closure_conversion.jl:409-416]
```
</details>

**Downstream Surfaces:**
- Lowering consumers that inspect isdefined/newvar patterns
- JET/diagnostic tooling that flags boxed captures

### Compatibility

#### Internal API Changes
- **BindingInfo.is_always_defined**: Now reset for captured arguments and recomputed by analyze_def_and_use! before closure conversion, widening the set of captured vars treated as always-defined.

#### Behavioral Changes
- Captured single-assigned locals/arguments are unboxed in more control-flow patterns, reducing Core.Box allocations and changing closure field layout.
- Code paths containing symbolic labels still force boxing to preserve correctness when assignments can be bypassed.

### Performance

**Compile Time:**
- ESTIMATED: Adds an extra tree-walk per lambda (analyze_def_and_use!), O(n) in AST size.

**Runtime:**
- Reduced Core.Box allocations for captured single-assigned locals/arguments in common control-flow patterns (e.g., if/ternary/guard), improving closure allocation behavior.

### Risk Assessment

**Level**: medium

**Rationale:**
- Changes when captured variables are boxed/unboxed; incorrect dominance handling could change semantics or produce invalid IR.
- Adds control-flow-sensitive state (live/unused/decl_outside_loop) which must stay in sync with JuliaLowering AST kinds.

### Recommendations

- Downstream tooling that assumes captured locals are boxed should consult closure field metadata (field_is_box/is_boxed) rather than the presence of Core.Box in IR.
- Consider adding regression tests for try/catch/label interactions to ensure kill!/restore! remains sound for new syntax kinds.
