# PR #60501: Test: add context arg for `@test` etc.

## Metadata

- **Author**: IanButterworth
- **URL**: https://github.com/JuliaLang/julia/pull/60501
- **Merged**: 2025-12-31 09:21 UTC
- **Labels**: `testsystem`
- **Diff**: https://github.com/JuliaLang/julia/pull/60501.diff

## Scope

### Files Touched
- `Compiler/test/inference.jl`
- `Compiler/test/inline.jl`
- `NEWS.md`
- `stdlib/FileWatching/test/runtests.jl`
- `stdlib/InteractiveUtils/test/runtests.jl`
- `stdlib/Test/src/Test.jl`
- `stdlib/Test/test/runtests.jl`
- `test/bitarray.jl`
- `test/cmdlineargs.jl`
- `test/math.jl`
- `test/strings/basic.jl`

### Components
- Test stdlib
- Test system
- Test suites

### Pipeline Stages
- Testing/Diagnostics

## Analysis

### Intent

Add a `context` keyword to @test, @test_throws, and @test_broken so failures can report extra debugging information (including when tests are marked broken).

### Direct Changes

#### 1. `@test` and `@test_broken` now parse a `context=...` keyword and pass the evaluated context through to the test execution helpers.

**Component**: Test stdlib

<details>
<summary>Evidence</summary>

**stdlib/Test/src/Test.jl:524-599**
[View on GitHub](https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L524-L599)
```julia
macro test(ex, kws...)
    # Collect the broken/skip/context keywords and remove them from the rest of keywords
    broken = [kw.args[2] for kw in kws if kw.args[1] === :broken]
    skip = [kw.args[2] for kw in kws if kw.args[1] === :skip]
    context = [kw.args[2] for kw in kws if kw.args[1] === :context]
    kws = filter(kw -> kw.args[1] âˆ‰ (:skip, :broken, :context), kws)
    # Validation of broken/skip/context keywords
    for (kw, name) in ((broken, :broken), (skip, :skip), (context, :context))
        if length(kw) > 1
            error("invalid test macro call: cannot set $(name) keyword multiple times")
        end
    end
    if length(skip) > 0 && length(broken) > 0
        error("invalid test macro call: cannot set both skip and broken keywords")
    end

    # Build the test expression
    test_expr!("@test", ex, kws...)

    result = get_test_result(ex, __source__)

    ex = Expr(:inert, ex)
    ctx = length(context) > 0 ? esc(context[1]) : nothing
    result = quote
        if $(length(skip) > 0 && esc(skip[1]))
            record(get_testset(), Broken(:skipped, $ex))
        else
            let _do = $(length(broken) > 0 && esc(broken[1])) ? do_broken_test : do_test
                _do($result, $ex, $ctx)
            end
        end
    end
    return result
end

macro test_broken(ex, kws...)
    # Extract context keyword if present
    context = [kw.args[2] for kw in kws if isa(kw, Expr) && kw.head === :(=) && kw.args[1] === :context]
    kws = filter(kw -> !(isa(kw, Expr) && kw.head === :(=) && kw.args[1] === :context), kws)
    test_expr!("@test_broken", ex, kws...)
    result = get_test_result(ex, __source__)
    ctx = length(context) > 0 ? esc(context[1]) : nothing
    # code to call do_test with execution result and original expr
    ex = Expr(:inert, ex)
    return :(do_broken_test($result, $ex, $ctx))
end
```

</details>

#### 2. `do_test`, `do_broken_test`, and `do_test_throws` now stringify context with `sprint(show, ...)` and attach it to Fail/Error results, enabling consistent context display in failure output.

**Component**: Test stdlib

<details>
<summary>Evidence</summary>

**stdlib/Test/src/Test.jl:781-825**
[View on GitHub](https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L781-L825)
```julia
function do_test(result::ExecutionResult, @nospecialize(orig_expr), context=nothing)
    # get_testset() returns the most recently added test set
    # We then call record() with this test set and the test result
    context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)
    if isa(result, Returned)
        # expr, in the case of a comparison, will contain the
        # comparison with evaluated values of each term spliced in.
        # For anything else, just contains the test expression.
        # value is the evaluated value of the whole test expression.
        # Ideally it is true, but it may be false or non-Boolean.
        value = result.value
        testres = if isa(value, Bool)
            # a true value Passes
            value ? Pass(:test, orig_expr, result.data, value, result.source) :
                    Fail(:test, orig_expr, result.data, value, context_str, result.source, false)
        else
            # If the result is non-Boolean, this counts as an Error
            Error(:test_nonbool, orig_expr, value, nothing, result.source, context_str)
        end
    else
        # The predicate couldn't be evaluated without throwing an
        # exception, so that is an Error and not a Fail
        @assert isa(result, Threw)
        testres = Error(:test_error, orig_expr, result.exception, result.current_exceptions, result.source, context_str)
    end
    isa(testres, Pass) || trigger_test_failure_break(result)
    record(get_testset(), testres)
end

function do_broken_test(result::ExecutionResult, @nospecialize(orig_expr), context=nothing)
    testres = Broken(:test, orig_expr)
    context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)
    # Assume the test is broken and only change if the result is true
    if isa(result, Returned)
        value = result.value
        if isa(value, Bool)
            if value
                testres = Error(:test_unbroken, orig_expr, value, nothing, result.source, context_str)
            end
        else
            # If the result is non-Boolean, this counts as an Error
            testres = Error(:test_nonbool, orig_expr, value, nothing, result.source, context_str)
        end
    end
    record(get_testset(), testres)
end
```

**stdlib/Test/src/Test.jl:942-955**
[View on GitHub](https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L942-L955)
```julia
function do_test_throws(result::ExecutionResult, @nospecialize(orig_expr), extype, pattern=nothing, context=nothing)
    context_str = context === nothing ? nothing : sprint(show, context; context=:limit => true)
    if isa(result, Threw)
        # Check that the right type of exception was thrown
        success = false
        message_only = false
        exc = result.exception

        # Handle three-argument form (type + pattern)
        if pattern !== nothing
            # In 3-arg form, first argument must be a type
            if !isa(extype, Type)
                testres = Fail(:test_throws_wrong, orig_expr, extype, exc, context_str, result.source, false, "First argument must be an exception type in three-argument form")
                record(get_testset(), testres)
                return
            end
```

</details>

#### 3. Failure rendering for `Test.Fail` and `Test.Error` now appends a Context line whenever `context` is present.

**Component**: Test stdlib

<details>
<summary>Evidence</summary>

**stdlib/Test/src/Test.jl:174-207**
[View on GitHub](https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L174-L207)
```julia
function Base.show(io::IO, t::Fail)
    printstyled(io, "Test Failed"; bold=true, color=Base.error_color())
    print(io, " at ")
    printstyled(io, something(t.source.file, :none), ":", t.source.line, "\n"; bold=true, color=:default)
    print(io, "  Expression: ", t.orig_expr)
    value, data = t.value, t.data
    if t.test_type === :test_throws_wrong
        # An exception was thrown, but it was of the wrong type
        if t.message_only
            print(io, "\n    Expected: ", data)
            print(io, "\n     Message: ", value)
        else
            print(io, "\n    Expected: ", data)
            print(io, "\n      Thrown: ", value)
            print(io, "\n")
            if t.backtrace !== nothing
                # Capture error message and indent to match
                join(io, ("      " * line for line in filter!(!isempty, split(t.backtrace, "\n"))), "\n")
            end
        end
    elseif t.test_type === :test_throws_nothing
        # An exception was expected, but no exception was thrown
        print(io, "\n    Expected: ", data)
        print(io, "\n  No exception thrown")
    elseif t.test_type === :test
        if data !== nothing && t.orig_expr != data
            # The test was an expression, so display the term-by-term
            # evaluated version as well
            print(io, "\n   Evaluated: ", data)
        end
    end
    if t.context !== nothing
        print(io, "\n     Context: ", t.context)
    end
end
```

**stdlib/Test/src/Test.jl:273-303**
[View on GitHub](https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L273-L303)
```julia
function Base.show(io::IO, t::Error)
    if t.test_type === :test_interrupted
        printstyled(io, "Interrupted", color=Base.error_color())
        return
    end
    printstyled(io, "Error During Test"; bold=true, color=Base.error_color())
    print(io, " at ")
    printstyled(io, something(t.source.file, :none), ":", t.source.line, "\n"; bold=true, color=:default)
    if t.test_type === :test_nonbool
        println(io, "  Expression evaluated to non-Boolean")
        println(io, "  Expression: ", t.orig_expr)
        print(  io, "       Value: ", t.value)
    elseif t.test_type === :test_error
        println(io, "  Test threw exception")
        println(io, "  Expression: ", t.orig_expr)
        # Capture error message and indent to match
        join(io, ("  " * line for line in filter!(!isempty, split(t.backtrace, "\n"))), "\n")
    elseif t.test_type === :test_unbroken
        # A test that was expected to fail did not
        println(io, " Unexpected Pass")
        println(io, " Expression: ", t.orig_expr)
        print(io, " Got correct result, please change to @test if no longer broken.")
    elseif t.test_type === :nontest_error
        # we had an error outside of a @test
        println(io, "  Got exception outside of a @test")
        # Capture error message and indent to match
        join(io, ("  " * line for line in filter!(!isempty, split(t.backtrace, "\n"))), "\n")
    end
    if t.context !== nothing
        print(io, "\n     Context: ", t.context)
    end
end
```

</details>

#### 4. `@test_throws` is now a single varargs macro that accepts an optional trailing `context=...` keyword, passing it into `do_test_throws`.

**Component**: Test stdlib

<details>
<summary>Evidence</summary>

**stdlib/Test/src/Test.jl:887-923**
[View on GitHub](https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/src/Test.jl#L887-L923)
```julia
macro test_throws(args...)
    # Parse arguments: expect (extype, ex) or (extype, pattern, ex), with optional context=... at end
    nargs = length(args)
    nargs >= 2 || error("@test_throws requires at least 2 arguments")

    # Check for context=... keyword at end
    ctx = nothing
    if nargs >= 3 && args[end] isa Expr && args[end].head === :(=) && args[end].args[1] === :context
        ctx = esc(args[end].args[2])
        args = args[1:end-1]
        nargs -= 1
    end

    if nargs == 2
        extype, ex = args
        pattern = nothing
    elseif nargs == 3
        extype, pattern, ex = args
        pattern = esc(pattern)
    else
        error("@test_throws expects 2 or 3 positional arguments (plus optional context=...)")
    end

    orig_ex = Expr(:inert, ex)
    ex = Expr(:block, __source__, esc(ex))
    result = quote
        try
            Returned($ex, nothing, $(QuoteNode(__source__)))
        catch _e
            if $(esc(extype)) != InterruptException && _e isa InterruptException
                rethrow()
            end
            Threw(_e, Base.current_exceptions(), $(QuoteNode(__source__)))
        end
    end
    return :(do_test_throws($result, $orig_ex, $(esc(extype)), $pattern, $ctx))
end
```

</details>

#### 5. New tests exercise context propagation for @test, @test_throws, and @test_broken, asserting the context string is stored on Fail/Error results.

**Component**: Test stdlib tests

<details>
<summary>Evidence</summary>

**stdlib/Test/test/runtests.jl:469-542**
[View on GitHub](https://github.com/JuliaLang/julia/blob/35eaf05348215063bd239f3609a625e97735685d/stdlib/Test/test/runtests.jl#L469-L542)
```julia
# Tests for context keyword
@testset "@test with context keyword" begin
    # Test that context appears in Fail
    let f = Test.Fail(:test, "false", nothing, "false", "(sin, Float64)", LineNumberNode(1), false)
        @test occursin("Context: (sin, Float64)", sprint(show, f))
    end

    # Test that context is evaluated and shown in @test
    let fails = @testset NoThrowTestSet begin
            @test false context=(sin, Float64)
        end
        @test length(fails) == 1
        @test fails[1] isa Test.Fail
        @test occursin("(sin, Float64)", fails[1].context)
    end

    # Test context with broken=true (should record as Broken)
    let results = @testset NoThrowTestSet begin
            @test false context="info" broken=true
        end
        @test length(results) == 1
        @test results[1] isa Test.Broken
    end

    # Test context with Error (exception thrown)
    let errors = @testset NoThrowTestSet begin
            @test error("boom") context="error info"
        end
        @test length(errors) == 1
        @test errors[1] isa Test.Error
        @test errors[1].context == "\"error info\""
    end
end

@testset "@test_throws with context keyword" begin
    # Test context appears when wrong exception thrown
    let fails = @testset NoThrowTestSet begin
            @test_throws ArgumentError error("wrong") context="extra info"
        end
        @test length(fails) == 1
        @test fails[1] isa Test.Fail
        @test fails[1].context == "\"extra info\""
    end

    # Test context with three-arg form
    let fails = @testset NoThrowTestSet begin
            @test_throws ErrorException "pattern" error("wrong msg") context=(1, 2)
        end
        @test length(fails) == 1
        @test fails[1] isa Test.Fail
        @test occursin("(1, 2)", fails[1].context)
    end

    # Test context when no exception thrown
    let fails = @testset NoThrowTestSet begin
            @test_throws ErrorException 1 + 1 context="no throw info"
        end
        @test length(fails) == 1
        @test fails[1] isa Test.Fail
        @test fails[1].test_type === :test_throws_nothing
        @test fails[1].context == "\"no throw info\""
    end
end

@testset "@test_broken with context keyword" begin
    # Test context with @test_broken when test unexpectedly passes
    let errors = @testset NoThrowTestSet begin
            @test_broken true context="broken info"
        end
        @test length(errors) == 1
        @test errors[1] isa Test.Error
        @test errors[1].test_type === :test_unbroken
        @test errors[1].context == "\"broken info\""
    end
end
```

</details>

### Secondary Effects

#### Tests that previously used ad-hoc non-Boolean tricks (e.g., `@test cond || "info"`) can now use `context=...`, while `broken=true` tests still route through `do_broken_test` but now preserve context on unexpected passes or non-boolean results.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
@test macro parses context and selects do_test/do_broken_test  [stdlib/Test/src/Test.jl:524-553]
  -> do_test/do_broken_test stringifies context via sprint(show, ...)  [stdlib/Test/src/Test.jl:781-825]
  -> Fail/Error objects carry context for rendering  [stdlib/Test/src/Test.jl:174-207, 273-303]
```
</details>

**Downstream Surfaces:**
- Test failure output formatting
- `Test.Fail.context` and `Test.Error.context` fields

#### `@test_throws` now accepts a trailing `context=...`, which is threaded to `do_test_throws` and included when reporting wrong/no-throw failures.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
@test_throws macro parses trailing context keyword  [stdlib/Test/src/Test.jl:887-923]
  -> do_test_throws attaches context_str to Fail results  [stdlib/Test/src/Test.jl:942-955]
```
</details>

**Downstream Surfaces:**
- `@test_throws` call sites in packages
- Test failure output formatting

### Compatibility

#### Internal API Changes
- **Test.do_test(result, orig_expr, context)**: Added optional `context` argument and now expects callers to pass context or `nothing`.
- **Test.do_broken_test(result, orig_expr, context)**: Added optional `context` argument; now stores context on Error results for unexpected passes/non-boolean results.
- **Test.do_test_throws(result, orig_expr, extype, pattern, context)**: Added optional `context` argument; failure results include context string.

#### Behavioral Changes
- `context` becomes a reserved keyword for `@test`, `@test_throws`, and `@test_broken`; tests that used `context=` as a generic keyword argument must rename it.

### Performance

**Compile Time:**
- ESTIMATED: when `context=...` is provided, `sprint(show, context; context=:limit => true)` adds formatting work during test execution (per test invocation).

### Risk Assessment

**Level**: low

**Rationale:**
- Behavior is isolated to the Test stdlib and only affects output/metadata when `context` is provided.
- New tests cover context propagation for @test, @test_throws, and @test_broken.

### Recommendations

- Update package test suites to use `context=...` instead of non-Boolean short-circuit tricks when extra debugging info is needed.
- Avoid using `context=` as a generic keyword in @test/@test_throws/@test_broken calls; rename such parameters to prevent keyword conflicts.
