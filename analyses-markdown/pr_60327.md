# PR #60327: Allow `K"error"` when parsing to SyntaxTree

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60327
- **Merged**: 2025-12-05 22:26 UTC
- **Labels**: `parser`, `JuliaLowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60327.diff

## Scope

### Files Touched
- `JuliaLowering/src/syntax_graph.jl`
- `JuliaLowering/test/syntax_graph.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Parsing
- Lowering

## Analysis

### Intent

Allow SyntaxTree construction to tolerate parse errors (notably for ignore_errors parsing used by tooling like JETLS) instead of asserting on unexpected shapes.

### Direct Changes

#### 1. `_green_to_ast` now preserves `parens`, `var`, and `char` nodes with multiple children instead of asserting they must contain exactly one child.

**Component**: JuliaLowering/src/syntax_graph.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/syntax_graph.jl:861-883**
[View on GitHub](https://github.com/JuliaLang/julia/blob/2ec05d5734ce268e75bc29126e3e2f1455e5fa49/JuliaLowering/src/syntax_graph.jl#L861-L883)
```julia
function _green_to_ast(parent::Kind, ex::SyntaxTree; eq_to_kw=false)
    is_trivia(ex) && !is_error(ex) && return nothing
    graph = syntax_graph(ex)
    k = kind(ex)
    if k === K"ref" ||
        (k in KSet"call dotcall" && (
            is_prefix_call(ex) || is_prefix_op_call(ex) && numchildren(ex) > 2))
        cs = SyntaxList(ex)
        for c in children(ex)
            c2 = _green_to_ast(k, c; eq_to_kw=length(cs)>0)
            !isnothing(c2) && push!(cs, c2)
        end
        makenode(graph, ex, ex, cs)
    elseif k === K"parameters"
        eq_to_kw = parent != K"vect"   && parent != K"curly" &&
                   parent != K"braces" && parent != K"ref"
        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex); eq_to_kw))
    elseif k === K"parens"
        cs = _map_green_to_ast(parent, children(ex); eq_to_kw)
        length(cs) === 1 ? cs[1] : makenode(graph, ex, ex, cs)
    elseif k in KSet"var char"
        cs = _map_green_to_ast(parent, children(ex))
        length(cs) === 1 ? cs[1] : makenode(graph, ex, ex, cs)
```

**JuliaLowering/src/syntax_graph.jl:826-919**
[View on GitHub](https://github.com/JuliaLang/julia/blob/2ec05d5734ce268e75bc29126e3e2f1455e5fa49/JuliaLowering/src/syntax_graph.jl#L826-L919)
```julia
JuliaLowering/src/syntax_graph.jl
826:    out = _green_to_ast(K"None", SyntaxTree(graph, green_id))
861:function _green_to_ast(parent::Kind, ex::SyntaxTree; eq_to_kw=false)
870:            c2 = _green_to_ast(k, c; eq_to_kw=length(cs)>0)
877:        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex); eq_to_kw))
879:        cs = _map_green_to_ast(parent, children(ex); eq_to_kw)
882:        cs = _map_green_to_ast(parent, children(ex))
885:        setattr!(makenode(graph, ex, ex, _map_green_to_ast(k, children(ex))),
895:        cs = _map_green_to_ast(k, children(ex))
911:        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex)))
915:function _map_green_to_ast(parent::Kind, cs::SyntaxList; eq_to_kw=false)
918:        c2 = _green_to_ast(parent, c; eq_to_kw)
```

</details>

#### 2. `macro_name` handling now falls back to a regular node when the expected single Identifier or dotted Identifier shape is not present.

**Component**: JuliaLowering/src/syntax_graph.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/syntax_graph.jl:891-907**
[View on GitHub](https://github.com/JuliaLang/julia/blob/2ec05d5734ce268e75bc29126e3e2f1455e5fa49/JuliaLowering/src/syntax_graph.jl#L891-L907)
```julia
elseif k === K"macro_name"
    # M.@x parses to (. M (macro_name x))
    # @M.x parses to (macro_name (. M x))
    # We want (. M @x) (both identifiers) in either case
    cs = _map_green_to_ast(k, children(ex))
    if length(cs) !== 1 || !(kind(cs[1]) in KSet". Identifier")
        return makenode(graph, ex, ex, cs)
    end
    id = cs[1]
    mname_raw = (kind(id) === K"." ? id[2] : id).name_val
    mac_id = setattr!(makeleaf(graph, ex, K"Identifier"), :name_val,
                      lower_identifier_name(mname_raw, K"macro_name"))
    if kind(id) === K"."
        makenode(graph, ex, ex, NodeId[id[1]._id, mac_id._id])
    else
        mac_id
    end
```

</details>

#### 3. Tests now assert that parsing with `ignore_errors=true` returns a SyntaxTree for malformed inputs like lone `@` or bad parenthesized forms.

**Component**: JuliaLowering/test/syntax_graph.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/test/syntax_graph.jl:43-52**
[View on GitHub](https://github.com/JuliaLang/julia/blob/2ec05d5734ce268e75bc29126e3e2f1455e5fa49/JuliaLowering/test/syntax_graph.jl#L43-L52)
```julia
@testset "SyntaxTree" begin
    # Expr conversion
    @test Expr(parsestmt(SyntaxTree, "begin a + b ; c end", filename="none")) ==
        Meta.parse("begin a + b ; c end")

    # Parsing to SyntaxTree: errors should fall through
    @test parsestmt(SyntaxTree, "@"; ignore_errors=true) isa SyntaxTree
    @test parsestmt(SyntaxTree, "@@@"; ignore_errors=true) isa SyntaxTree
    @test parsestmt(SyntaxTree, "(a b c)"; ignore_errors=true) isa SyntaxTree
    @test parsestmt(SyntaxTree, "'a b c'"; ignore_errors=true) isa SyntaxTree
```

</details>

### Secondary Effects

#### Malformed inputs that previously tripped assertions now survive as SyntaxTree nodes, allowing editor/LS tooling to keep a tree for error recovery.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
JuliaSyntax.build_tree(::Type{SyntaxTree}, stream)  [syntax_graph.jl:799-815]
  -> SyntaxTree(graph, sf, cursor)  [syntax_graph.jl:818-828]
    -> _insert_green(...)  [syntax_graph.jl:833-855]
    -> _green_to_ast(K"None", SyntaxTree(graph, green_id))  [syntax_graph.jl:861-911]
       - For K"parens" and KSet"var char", length(cs) != 1 now returns makenode(...) instead of asserting
       - For K"macro_name" with unexpected shape, returns makenode(...) instead of asserting
```
</details>

**Downstream Surfaces:**
- JETLS and other tooling parsing with ignore_errors=true
- Downstream SyntaxTree walkers that assumed single-child parens/var/char nodes

#### Macro-name rewriting is skipped for malformed macro syntax, preserving raw subtrees instead of emitting an Identifier/macroname pair.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
_green_to_ast(..., k == K"macro_name")  [syntax_graph.jl:891-907]
  -> if length(cs) !== 1 or kind(cs[1]) not in KSet". Identifier"
       returns makenode(graph, ex, ex, cs)
  -> otherwise continues rewriting into Identifier/macro_name form
```
</details>

**Downstream Surfaces:**
- Macro-introspection tooling that expects normalized macro_name nodes

### Compatibility

#### Internal API Changes
- **SyntaxTree shapes for K"parens" / KSet"var char"**: No longer guaranteed to collapse to a single child when parsing error nodes; callers may now see wrapper nodes with multiple children.
- **SyntaxTree K"macro_name" normalization**: Malformed macro syntax now yields a node with raw children instead of raising assertion or producing Identifier/macroname rewrite.

#### Behavioral Changes
- Returns a SyntaxTree even for inputs like '@' or '(a b c)' instead of triggering assertions during conversion.

### Performance

**Compile Time:**
- ESTIMATED: negligible extra branching in _green_to_ast for error cases only; no new passes or traversals.

**Runtime:**
- ESTIMATED: no measurable runtime impact; changes are confined to parsing/SyntaxTree construction.

### Risk Assessment

**Level**: low

**Rationale:**
- Changes only affect error-handling paths in SyntaxTree conversion; normal well-formed trees follow the same fast paths.
- Tests added to lock in error-tolerant parsing behavior.

### Recommendations

- Downstream SyntaxTree consumers should treat K"parens", K"var", and K"char" nodes as potentially multi-child in error-tolerant parsing modes.
- Consider adding dedicated error-node invariants or documentation for SyntaxTree shape under ignore_errors parsing to guide tooling.
