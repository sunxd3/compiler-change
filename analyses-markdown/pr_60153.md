# PR #60153: Use imperative form in docstrings

## Metadata

- **Author**: fingolfin
- **URL**: https://github.com/JuliaLang/julia/pull/60153
- **Merged**: 2025-11-20 06:52 UTC
- **Diff**: https://github.com/JuliaLang/julia/pull/60153.diff

## Scope

### Files Touched
- `Compiler/src/abstractlattice.jl`
- `Compiler/src/ssair/EscapeAnalysis.jl`
- `Compiler/src/ssair/domtree.jl`
- `base/abstractset.jl`
- `base/channels.jl`
- `base/deprecated.jl`
- `base/docs/basedocs.jl`
- `base/essentials.jl`
- `base/experimental.jl`
- `base/file.jl`
- `base/floatfuncs.jl`
- `base/gcutils.jl`
- `base/int.jl`
- `base/intfuncs.jl`
- `base/libc.jl`
- `base/loading.jl`
- `base/lock.jl`
- `base/rational.jl`
- `base/rawbigfloats.jl`
- `base/reflection.jl`
- `base/runtime_internals.jl`
- `base/ryu/utils.jl`
- `base/sort.jl`
- `base/special/rem_pio2.jl`
- `base/special/trig.jl`
- `base/strings/cstring.jl`
- `base/sysinfo.jl`
- `base/task.jl`
- `base/threadingconstructs.jl`
- `base/tuple.jl`

### Components
- Compiler.AbstractLattice
- Compiler.SSAIR
- Base

### Pipeline Stages
- TypeInference
- SSA
- Runtime

## Analysis

### Intent

Standardize Julia docstrings to use imperative phrasing (e.g., Return/Determine/Check) rather than third-person verbs.

**Related Issues:**
- https://github.com/JuliaLang/julia/issues/50301

### Direct Changes

#### 1. Compiler docstrings in lattice utilities and SSA IR helpers now use imperative verbs (Determine/Check/Try), with no code behavior changes.

**Component**: Compiler (AbstractLattice, SSAIR)

<details>
<summary>Evidence</summary>

**Compiler/src/abstractlattice.jl:183-211**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4606012b73293d44db72977ddcb3caaf0a4a5df0/Compiler/src/abstractlattice.jl#L183-L211)
```julia
"""
    has_nontrivial_extended_info(ð•ƒ::AbstractLattice, t)::Bool

Determine whether the given lattice element `t` of `ð•ƒ` has non-trivial extended lattice
information that would not be available from the type itself.
"""
@nospecializeinfer has_nontrivial_extended_info(ð•ƒ::AbstractLattice, @nospecialize t) =
    has_nontrivial_extended_info(widenlattice(ð•ƒ), t)

"""
    is_const_prop_profitable_arg(ð•ƒ::AbstractLattice, t)::Bool

Determine whether the given lattice element `t` of `ð•ƒ` has new extended lattice information
that should be forwarded along with constant propagation.
"""
```

**Compiler/src/ssair/EscapeAnalysis.jl:415-424**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4606012b73293d44db72977ddcb3caaf0a4a5df0/Compiler/src/ssair/EscapeAnalysis.jl#L415-L424)
```julia
"""
    iridx(x, estate::EscapeState) -> xidx::Union{Int,Nothing}

Try to convert analyzable IR element `x::Union{Argument,SSAValue}` to
its unique identifier number `xidx` that is valid in the analysis context of `estate`.
Returns `nothing` if `x` isn't maintained by `estate` and thus unanalyzable (e.g. `x::GlobalRef`).

`irval` is the inverse function of `iridx` (not formally), i.e.
`irval(iridx(x::Union{Argument,SSAValue}, state), state) === x`.
"""
```

**Compiler/src/ssair/domtree.jl:597-614**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4606012b73293d44db72977ddcb3caaf0a4a5df0/Compiler/src/ssair/domtree.jl#L597-L614)
```julia
"""
    dominates(domtree::DomTree, bb1::Int, bb2::Int)::Bool

Check if `bb1` dominates `bb2`.
`bb1` and `bb2` are indexes into the `CFG` blocks.
`bb1` dominates `bb2` if the only way to enter `bb2` is via `bb1`.
(Other blocks may be in between, e.g `bb1->bbx->bb2`).
"""

"""
    postdominates(domtree::PostDomTree, bb1::Int, bb2::Int)::Bool

Check if `bb1` post-dominates `bb2`.
`bb1` and `bb2` are indexes into the `CFG` blocks.
`bb1` post-dominates `bb2` if every pass from `bb2` to the exit is via `bb1`.
(Other blocks may be in between, e.g `bb2->bbx->bb1->exit`).
"""
```

</details>

#### 2. Base library docstrings were rephrased to imperative form for user-facing APIs.

**Component**: Base

<details>
<summary>Evidence</summary>

**base/channels.jl:13-20**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4606012b73293d44db72977ddcb3caaf0a4a5df0/base/channels.jl#L13-L20)
```julia
"""
    Channel{T=Any}(size::Int=0)

Construct a `Channel` with an internal buffer that can hold a maximum of `size` objects
of type `T`.
[`put!`](@ref) calls on a full channel block until an object is removed with [`take!`](@ref).
"""
```

**base/reflection.jl:211-216**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4606012b73293d44db72977ddcb3caaf0a4a5df0/base/reflection.jl#L211-L216)
```julia
"""
    code_typed(f, types; kw...)

Return an array of type-inferred lowered form (IR) for the methods matching the given
generic function and type signature.
"""
```

</details>

### Secondary Effects

#### Help-mode/documentation output changes wording but not semantics.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
Only docstring text literals were edited; function bodies and compiler logic remain unchanged.
```
</details>

**Downstream Surfaces:**
- REPL help mode (Base.Docs)
- Generated documentation

### Compatibility

### Performance

### Risk Assessment

**Level**: low

**Rationale:**
- Docstring-only edits with no changes to executable code or tests.

### Recommendations

- No downstream action required; update any internal documentation style guides if they mirror Julia's docstring conventions.
