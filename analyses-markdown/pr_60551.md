# PR #60551: [JuliaLowering] Add remap for assigned-to arguments

## Metadata

- **Author**: topolarity
- **URL**: https://github.com/JuliaLang/julia/pull/60551
- **Merged**: 2026-01-07 16:06 UTC
- **Diff**: https://github.com/JuliaLang/julia/pull/60551.diff

## Scope

### Files Touched
- `JuliaLowering/src/linear_ir.jl`
- `JuliaLowering/test/closures_ir.jl`
- `JuliaLowering/test/decls_ir.jl`
- `JuliaLowering/test/functions.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering
- LinearIR

## Analysis

### Intent

Implement arg-map style remapping for arguments that are reassigned in lowering so macro-expanded code does not hand invalid slots to codegen; add regression tests for reassigned arguments and updated IR expectations.

**Related Issues:**
- https://github.com/JuliaLang/JuliaLowering.jl/issues/129

### Direct Changes

#### 1. LinearIRContext now tracks an argument remap table, and `compile` rewrites BindingId uses/assignments through that mapping before emitting IR or returns.

**Component**: JuliaLowering/src/linear_ir.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/linear_ir.jl:67-95**
[View on GitHub](https://github.com/JuliaLang/julia/blob/94771dd2ca098ca3e0a74495829cd160203d1e2e/JuliaLowering/src/linear_ir.jl#L67-L95)
```julia
struct LinearIRContext{Attrs} <: AbstractLoweringContext
    graph::SyntaxGraph{Attrs}
    code::SyntaxList{Attrs, Vector{NodeId}}
    bindings::Bindings
    next_label_id::Ref{Int}
    is_toplevel_thunk::Bool
    lambda_bindings::LambdaBindings
    argmap::Dict{IdTag, IdTag}
    return_type::Union{Nothing, SyntaxTree{Attrs}}
    break_targets::Dict{String, JumpTarget{Attrs}}
    handler_token_stack::SyntaxList{Attrs, Vector{NodeId}}
    catch_token_stack::SyntaxList{Attrs, Vector{NodeId}}
    finally_handlers::Vector{FinallyHandler{Attrs}}
    symbolic_jump_targets::Dict{String,JumpTarget{Attrs}}
    symbolic_jump_origins::Vector{JumpOrigin{Attrs}}
    meta::Dict{Symbol, Any}
    mod::Module
end

function LinearIRContext(ctx, is_toplevel_thunk, lambda_bindings, return_type)
    graph = syntax_graph(ctx)
    rett = isnothing(return_type) ? nothing : reparent(graph, return_type)
    Attrs = typeof(graph.attributes)
    LinearIRContext(graph, SyntaxList(ctx), ctx.bindings, Ref(0),
                    is_toplevel_thunk, lambda_bindings, Dict{IdTag,IdTag}(), rett,
                    Dict{String,JumpTarget{Attrs}}(), SyntaxList(ctx), SyntaxList(ctx),
                    Vector{FinallyHandler{Attrs}}(), Dict{String,JumpTarget{Attrs}}(),
                    Vector{JumpOrigin{Attrs}}(), Dict{Symbol, Any}(), ctx.mod)
end
```

**JuliaLowering/src/linear_ir.jl:575-650**
[View on GitHub](https://github.com/JuliaLang/julia/blob/94771dd2ca098ca3e0a74495829cd160203d1e2e/JuliaLowering/src/linear_ir.jl#L575-L650)
```julia
function compile(ctx::LinearIRContext, ex, needs_value, in_tail_pos)
    k = kind(ex)
    if k == K"BindingId" || is_literal(k) || k == K"quote" || k == K"inert" ||
            k == K"top" || k == K"core" || k == K"Value" || k == K"Symbol" ||
            k == K"SourceLocation" || k == K"static_eval"
        ex1 = ex
        if kind(ex1) == K"BindingId"
            binfo = get_binding(ctx, ex1)
            if haskey(ctx.argmap, binfo.id)
                ex1 = setattr!(newleaf(ctx, ex1, K"BindingId"), :var_id, ctx.argmap[binfo.id])
            end
        end
        if in_tail_pos
            emit_return(ctx, ex1)
        elseif needs_value
            ex1
        else
            if k == K"BindingId" && !is_ssa(ctx, ex1)
                emit(ctx, ex1) # keep identifiers for undefined-var checking
            end
            nothing
        end
    elseif k == K"Placeholder"
        if needs_value
            throw(LoweringError(ex, "all-underscore identifiers are write-only and their values cannot be used in expressions"))
        end
        nothing
    elseif k == K"TOMBSTONE"
        @chk !needs_value (ex,"TOMBSTONE encountered in value position")
        nothing
    elseif k == K"call" || k == K"new" || k == K"splatnew" || k == K"foreigncall" ||
            k == K"new_opaque_closure" || k == K"cfunction"
        callex = newnode(ctx, ex, k, compile_args(ctx, children(ex)))
        if in_tail_pos
            emit_return(ctx, ex, callex)
        elseif needs_value
            callex
        else
            emit(ctx, callex)
            nothing
        end
    elseif k == K"=" || k == K"constdecl"
        lhs = ex[1]
        res = if kind(lhs) == K"Placeholder"
            compile(ctx, ex[2], needs_value, in_tail_pos)
        elseif k == K"constdecl" && numchildren(ex) == 1
            # No RHS - make undefined constant
            mod, name = if kind(ex[1]) == K"BindingId"
                binfo = get_binding(ctx, ex[1])
                binfo.mod, binfo.name
            else
                @assert kind(ex[1]) == K"Value" && typeof(ex[1].value) === GlobalRef
                gr = ex[1].value
                gr.mod, String(gr.name)
            end
            emit(ctx, @ast ctx ex [K"call" "declare_const"::K"core"
                                   mod::K"Value" name::K"Symbol"])
        else
            rhs = compile(ctx, ex[2], true, false)
            if kind(lhs) == K"BindingId"
                binfo = get_binding(ctx, lhs)
                if haskey(ctx.argmap, binfo.id)
                    lhs = setattr!(newleaf(ctx, lhs, K"BindingId"), :var_id, ctx.argmap[binfo.id])
                end
            end
            if needs_value && !isnothing(rhs)
                r = emit_assign_tmp(ctx, rhs)
                emit_simple_assignment(ctx, ex, lhs, r, k)
                if in_tail_pos
                    emit_return(ctx, ex, r)
                else
                    r
                end
            else
                emit_assignment(ctx, ex, lhs, rhs, k)
            end
        end
```

</details>

#### 2. `compile_lambda` builds remapped locals for reassigned arguments and inserts a prologue assignment that copies argument values into the new locals before compilation proceeds.

**Component**: JuliaLowering/src/linear_ir.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/linear_ir.jl:1069-1090**
[View on GitHub](https://github.com/JuliaLang/julia/blob/94771dd2ca098ca3e0a74495829cd160203d1e2e/JuliaLowering/src/linear_ir.jl#L1069-L1090)
```julia
function compile_lambda(outer_ctx, ex)
    lambda_args = ex[1]
    static_parameters = ex[2]
    ret_var = numchildren(ex) == 4 ? ex[4] : nothing
    lambda_bindings = ex.lambda_bindings
    ctx = LinearIRContext(outer_ctx, ex.is_toplevel_thunk, lambda_bindings, ret_var)
    for arg in children(lambda_args)
        kind(arg) == K"Placeholder" && continue
        @assert kind(arg) == K"BindingId"
        id = arg.var_id
        binfo = get_binding(ctx, id)
        if binfo.is_assigned
            @assert !haskey(ctx.argmap, binfo.id)
            ctx.argmap[binfo.id] = new_local_binding(ctx, binding_ex(ctx, binfo), binfo.name).var_id
        end
    end
    compile_body(ctx, ex[3])
    for (id, remapped) in pairs(ctx.argmap)
        binding = binding_ex(ctx, id)
        local_slot = binding_ex(ctx, remapped)
        pushfirst!(ctx.code, @ast ctx binding [K"=" local_slot binding])
    end
```

**JuliaLowering/src/linear_ir.jl:779,795,798,1166**
[View on GitHub](https://github.com/JuliaLang/julia/blob/94771dd2ca098ca3e0a74495829cd160203d1e2e/JuliaLowering/src/linear_ir.jl#L770-L806)
```julia
779:                lam = compile_lambda(ctx, lam)
795:            compile_lambda(ctx, ex[5])
798:        lam = compile_lambda(ctx, ex)
1166:    res = compile_lambda(_ctx, reparent(_ctx, ex))
```

</details>

#### 3. New regression tests assert that macros with assigned-to arguments lower correctly, and IR snapshots now include the extra local slots created by arg remapping.

**Component**: JuliaLowering/test

<details>
<summary>Evidence</summary>

**JuliaLowering/test/functions.jl:511-545**
[View on GitHub](https://github.com/JuliaLang/julia/blob/94771dd2ca098ca3e0a74495829cd160203d1e2e/JuliaLowering/test/functions.jl#L511-L545)
```julia
@testset "Assigned-to arguments" begin
    # These examples are all macros, since they have specialized de-optimization
    # behavior that sends un-optimized code straight to codegen. Normal compiled
    # functions essentially always pass through SSA conversion on the way to the
    # optimizer, erasing these slots (potentially hiding bugs in slot handling)

    @test JuliaLowering.include_string(test_mod, raw"""
    macro m_assigned_args_1(x)
        x = x + 1
        return x
    end
    var"@m_assigned_args_1"(LineNumberNode(0, nothing), Main, 2)
    """; expr_compat_mode=true) == 3

    @test JuliaLowering.include_string(test_mod, raw"""
    macro m_assigned_args_2(x, y = 1)
        (y, x) = (x + 1, y + 1)
        return y - x
    end
    (
        var"@m_assigned_args_2"(LineNumberNode(0, nothing), Main, 2),
        var"@m_assigned_args_2"(LineNumberNode(0, nothing), Main, 1, 2),
    )
    """; expr_compat_mode=true) == (1, -1)

    for expr_compat_mode in (false, true)
        @test JuliaLowering.include_string(test_mod, raw"""
        macro m_assigned_args(ex)
            ex = Base.remove_linenums!(ex)
            return ex
        end
        ((@m_assigned_args 1 + 1), @m_assigned_args 1)
        """; expr_compat_mode) == (2, 1)
    end
end
```

**JuliaLowering/test/closures_ir.jl:132-150**
[View on GitHub](https://github.com/JuliaLang/julia/blob/94771dd2ca098ca3e0a74495829cd160203d1e2e/JuliaLowering/test/closures_ir.jl#L132-L150)
```julia
20  --- method core.nothing %₁₉
    slots: [slot₁/#self#(!read) slot₂/x(single_assign) slot₃/g(single_assign,called) slot₄/x(!read,maybe_undef) slot₅/x(!read)]
    1   (= slot₅/x slot₂/x)
    2   slot₅/x
    3   (= slot₅/x (call core.Box %₂))
    4   TestMod.#f#g##0
    5   slot₅/x
    6   (new %₄ %₅)
    7   (= slot₃/g %₆)
    8   slot₃/g
    9   (call %₈)
    10  slot₅/x
    11  (call core.isdefined %₁₀ :contents)
    12  (gotoifnot %₁₁ label₁₄)
    13  (goto label₁₆)
    14  (newvar slot₄/x)
    15  slot₄/x
    16  (call core.getfield %₁₀ :contents)
    17  (return %₁₆)
```

**JuliaLowering/test/decls_ir.jl:265-293**
[View on GitHub](https://github.com/JuliaLang/julia/blob/94771dd2ca098ca3e0a74495829cd160203d1e2e/JuliaLowering/test/decls_ir.jl#L265-L293)
```julia
9   --- method core.nothing %₈
    slots: [slot₁/#self#(!read) slot₂/x slot₃/tmp(!read) slot₄/tmp(!read) slot₅/x(!read)]
    1   (= slot₅/x slot₂/x)
    2   1
    3   TestMod.Int
    4   (= slot₃/tmp %₂)
    5   slot₃/tmp
    6   (call core.isa %₅ %₃)
    7   (gotoifnot %₆ label₉)
    8   (goto label₁₂)
    9   slot₃/tmp
    10  (call top.convert %₃ %₉)
    11  (= slot₃/tmp (call core.typeassert %₁₀ %₃))
    12  slot₃/tmp
    13  (= slot₅/x %₁₂)
    14  2.0
    15  TestMod.Int
    16  (= slot₄/tmp %₁₄)
    17  slot₄/tmp
    18  (call core.isa %₁₇ %₁₅)
    19  (gotoifnot %₁₈ label₂₁)
    20  (goto label₂₄)
    21  slot₄/tmp
    22  (call top.convert %₁₅ %₂₁)
    23  (= slot₄/tmp (call core.typeassert %₂₂ %₁₅))
    24  slot₄/tmp
    25  (= slot₅/x %₂₄)
    26  slot₅/x
    27  (return %₂₆)
```

</details>

### Secondary Effects

#### Assigned-to arguments are now consistently lowered into fresh local slots, preventing unoptimized macro expansions from referencing argument slots that codegen cannot handle.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
compile_lambda(outer_ctx, ex)  [linear_ir.jl:1069-1090]
  builds ctx.argmap for any argument with binfo.is_assigned
  and inserts a prologue assignment: (= local_slot binding)
-> compile(ctx, ex, ...)  [linear_ir.jl:575-650]
  rewrites BindingId uses and LHS assignments via ctx.argmap before emit
-> compile_lambda callers (method/lambda/opaque_closure_method)  [linear_ir.jl:779-798]
  ensure all lowering paths use the remapped slots
```
</details>

**Downstream Surfaces:**
- Macro expansion in expr_compat_mode (JuliaLowering.include_string)
- Linear IR emitted for codegen in de-optimized macro paths

#### Linear IR slot layout now includes an extra local slot for reassigned arguments (copy from arg to local), which can alter snapshot-based IR tooling expectations.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
compile_lambda inserts a prologue assignment and new local binding  [linear_ir.jl:1069-1090]
-> slot table includes the new local slot during _renumber / slot rewrite  [linear_ir.jl:1091-1107]
-> tests show added slot and copy in IR output  [closures_ir.jl:132-150, decls_ir.jl:265-293]
```
</details>

**Downstream Surfaces:**
- JuliaLowering IR snapshot tests
- Tooling that inspects JuliaLowering linear IR slots (IRTools-like consumers)

### Compatibility

#### Internal API Changes
- **LinearIRContext.argmap**: New Dict{IdTag,IdTag} field initialized in LinearIRContext and used during compile to remap argument bindings.

#### Behavioral Changes
- Macros with reassigned arguments now lower and evaluate reliably, matching new regression tests.

### Performance

**Compile Time:**
- ESTIMATED: Additional Dict lookup per BindingId and per assignment when argmap is non-empty; one extra prologue assignment per reassigned argument.

**Runtime:**
- No runtime change for optimized code; effects limited to lowering output shape prior to SSA/optimization.

### Risk Assessment

**Level**: low

**Rationale:**
- Change is localized to JuliaLowering linear IR construction and guarded by reassigned-argument detection.
- New tests exercise macro paths that previously crashed or emitted invalid slots.

### Recommendations

- If consuming JuliaLowering linear IR, allow for an extra local slot and copy assignment when arguments are reassigned.
- Consider adding a small note to internal developer docs about argmap behavior for macro lowering.
