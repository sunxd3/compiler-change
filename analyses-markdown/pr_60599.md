# PR #60599: avoid some more `Core.Box` in Base and SharedArrays

## Metadata

- **Author**: KristofferC
- **URL**: https://github.com/JuliaLang/julia/pull/60599
- **Merged**: 2026-01-09 13:35 UTC
- **Labels**: `backport 1.13`
- **Diff**: https://github.com/JuliaLang/julia/pull/60599.diff

## Scope

### Files Touched
- `Compiler/src/abstractinterpretation.jl`
- `base/loading.jl`
- `base/timing.jl`
- `base/views.jl`
- `stdlib/SharedArrays/src/SharedArrays.jl`

### Components
- Compiler.AbstractInterpretation
- Base
- SharedArrays

### Pipeline Stages
- TypeInference
- Runtime

## Analysis

### Intent

Reduce Core.Box allocations by rewriting closures in inference and Base/SharedArrays utilities without changing observable behavior.

### Direct Changes

#### 1. Wrap the iterate function value in a let-bound closure state machine in abstract_iteration to avoid boxing captured variables while resuming inference tasks.

**Component**: Compiler/src/abstractinterpretation.jl

<details>
<summary>Evidence</summary>

**Compiler/src/abstractinterpretation.jl:1571-1707**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f20e7549dc1e7a04849566cb80e0507969f848eb/Compiler/src/abstractinterpretation.jl#L1571-L1707)
```julia
# simulate iteration protocol on container type up to fixpoint
function abstract_iteration(interp::AbstractInterpreter, @nospecialize(itft), @nospecialize(itertype),
                            vtypes::Union{VarTable,Nothing}, sv::AbsIntState)
    if isa(itft, Const)
        iteratef = itft.val
    else
        return Future(AbstractIterationResult(Any[Vararg{Any}], nothing, Effects()))
    end
    @assert !isvarargtype(itertype)
    let iteratef = iteratef
        iterateresult = Future{AbstractIterationResult}()
        call1future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[itft, itertype]), StmtInfo(true, false), vtypes, sv)::Future
        function inferiterate(interp, sv)
            call1 = call1future[]
            stateordonet = call1.rt
            if stateordonet === Bottom
                iterateresult[] = AbstractIterationResult(Any[Bottom], AbstractIterationInfo(CallMeta[CallMeta(Bottom, Any, call1.effects, call1.info)], true))
                return true
            end
            stateordonet_widened = widenconst(stateordonet)
            calls = CallMeta[call1]
            valtype = statetype = Bottom
            ret = Any[]
            ùïÉ·µ¢ = typeinf_lattice(interp)
            may_have_terminated = false
            local call2future::Future{CallMeta}

            nextstate::UInt8 = 0x0
            function inferiterate_2arg(interp, sv)
                if nextstate === 0x1
                    nextstate = 0xff
                    @goto state1
                elseif nextstate === 0x2
                    nextstate = 0xff
                    @goto state2
                else
                    @assert nextstate === 0x0
                    nextstate = 0xff
                end

                while true
                    if stateordonet_widened === Nothing
                        iterateresult[] = AbstractIterationResult(ret, AbstractIterationInfo(calls, true))
                        return true
                    end
                    if Nothing <: stateordonet_widened || length(ret) >= InferenceParams(interp).max_tuple_splat
                        break
                    end
                    if !isa(stateordonet_widened, DataType) || !(stateordonet_widened <: Tuple) || isvatuple(stateordonet_widened) || length(stateordonet_widened.parameters) != 2
                        break
                    end
                    nstatetype = getfield_tfunc(ùïÉ·µ¢, stateordonet, Const(2))
                    if ‚äë(ùïÉ·µ¢, nstatetype, statetype)
                        iterateresult[] = AbstractIterationResult(Any[Bottom], AbstractIterationInfo(calls, false), EFFECTS_THROWS)
                        return true
                    end
                    valtype = getfield_tfunc(ùïÉ·µ¢, stateordonet, Const(1))
                    push!(ret, valtype)
                    statetype = nstatetype
                    call2future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[Const(iteratef), itertype, statetype]), StmtInfo(true, false), vtypes, sv)::Future
                    if !isready(call2future)
                        nextstate = 0x1
                        return false
                        @label state1
                    end
                    let call = call2future[]
                        push!(calls, call)
                        stateordonet = call.rt
                        stateordonet_widened = widenconst(stateordonet)
                    end
                end
                valtype = statetype = Bottom
                may_have_terminated = Nothing <: stateordonet_widened
                while valtype !== Any
                    nounion = typeintersect(stateordonet_widened, Tuple{Any,Any})
                    if nounion !== Union{} && !isa(nounion, DataType)
                        valtype = Any
                        break
                    end
                    if nounion === Union{} || (nounion.parameters[1] <: valtype && nounion.parameters[2] <: statetype)
                        if !hasintersect(stateordonet_widened, Nothing)
                            if may_have_terminated
                                valtype = Bottom
                            else
                                iterateresult[] = AbstractIterationResult(Any[Bottom], AbstractIterationInfo(calls, false), Effects())
                                return true
                            end
                        end
                        break
                    end
                    valtype = tmerge(valtype, nounion.parameters[1])
                    statetype = tmerge(statetype, nounion.parameters[2])
                    call2future = abstract_call_known(interp, iteratef, ArgInfo(nothing, Any[Const(iteratef), itertype, statetype]), StmtInfo(true, false), vtypes, sv)::Future
                    if !isready(call2future)
                        nextstate = 0x2
                        return false
                        @label state2
                    end
                    let call = call2future[]
                        push!(calls, call)
                        stateordonet = call.rt
                        stateordonet_widened = widenconst(stateordonet)
                    end
                end
                if valtype !== Union{}
                    push!(ret, Vararg{valtype})
                end
                iterateresult[] = AbstractIterationResult(ret, AbstractIterationInfo(calls, false))
                return true
            end # function inferiterate_2arg
            inferiterate_2arg(interp, sv) || push!(sv.tasks, inferiterate_2arg)
            return true
        end # inferiterate
        if !(isready(call1future) && inferiterate(interp, sv))
            push!(sv.tasks, inferiterate)
        end
        return iterateresult
    end
end
```

</details>

#### 2. Use dedicated local bindings in Base and SharedArrays helpers to avoid captured-variable boxing (loading precompile task, time_print, view rewriting, shared-memory names, and mmap modes).

**Component**: Base/SharedArrays

<details>
<summary>Evidence</summary>

**base/loading.jl:2889-2904**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f20e7549dc1e7a04849566cb80e0507969f848eb/base/loading.jl#L2889-L2904)
```julia
if JLOptions().use_compiled_modules == 1
    if !generating_output(#=incremental=#false)
        # spawn off a new incremental pre-compile task for recursive `require` calls
        loaded = let spec = spec, reasons = reasons, parallel_precompile_attempted = parallel_precompile_attempted
            maybe_cachefile_lock(pkg, spec.path) do
                # double-check the search now that we have lock
                m = _require_search_from_serialized(pkg, spec, UInt128(0), true)
                m isa Module && return m

                local verbosity = isinteractive() ? CoreLogging.Info : CoreLogging.Debug
                @logmsg verbosity "Precompiling $(repr("text/plain", pkg))$(list_reasons(reasons))"

                unlock(require_lock)
                try
                    if !generating_output() && !parallel_precompile_attempted[] && !disable_parallel_precompile && @isdefined(Precompilation)
                        parallel_precompile_attempted[] = true
```

**base/timing.jl:252-302**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f20e7549dc1e7a04849566cb80e0507969f848eb/base/timing.jl#L252-L302)
```julia
function time_print(io::IO, elapsedtime, bytes=0, gctime=0, allocs=0, lock_conflicts=0, compile_time=0, recompile_time=0, newline=false;
                    msg::Union{String,Nothing}=nothing)
    timestr = Ryu.writefixed(Float64(elapsedtime/1e9), 6)
    str = sprint() do io
        if msg isa String
            print(io, msg, ": ")
        else
            print(io, length(timestr) < 10 ? (" "^(10 - length(timestr))) : "")
        end
        print(io, timestr, " seconds")
        parens = bytes != 0 || allocs != 0 || gctime > 0 || lock_conflicts > 0 || compile_time > 0
        parens && print(io, " (")
        had_allocs = bytes != 0 || allocs != 0
        if had_allocs
            allocs_scaled, ma = prettyprint_getunits(allocs, length(_cnt_units), Int64(1000))
            if ma == 1
                print(io, Int(allocs_scaled), _cnt_units[ma], allocs_scaled==1 ? " allocation: " : " allocations: ")
            else
                print(io, Ryu.writefixed(Float64(allocs_scaled), 2), _cnt_units[ma], " allocations: ")
            end
            print(io, format_bytes(bytes))
        end
        if gctime > 0
            if had_allocs
                print(io, ", ")
            end
            print(io, Ryu.writefixed(Float64(100*gctime/elapsedtime), 2), "% gc time")
        end
        if lock_conflicts > 0
            if had_allocs || gctime > 0
                print(io, ", ")
            end
            plural = lock_conflicts == 1 ? "" : "s"
            print(io, lock_conflicts, " lock conflict$plural")
        end
        if compile_time > 0
            if had_allocs || gctime > 0 || lock_conflicts > 0
                print(io, ", ")
            end
            print(io, Ryu.writefixed(Float64(100*compile_time/elapsedtime), 2), "% compilation time")
        end
        if recompile_time > 0
            perc = Float64(100 * recompile_time / compile_time)
            print(io, ": ", perc < 1 ? "<1" : Ryu.writefixed(perc, 0), "% of which was recompilation")
        end
        parens && print(io, ")")
        newline && print(io, "\n")
    end
    print(io, str)
    nothing
end
```

**base/views.jl:57-74**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f20e7549dc1e7a04849566cb80e0507969f848eb/base/views.jl#L57-L74)
```julia
# Second pass: if any need temps, create temps for all args
temp_vars = Tuple{Int,Symbol}[]
for j = 2:J
    n = nx === 0 ? ni : :($nx + $ni)
    exj, used_arg = replace_ref_begin_end_!(__module__, ref_ex.args[j], (:($firstindex($S,$n)),:($lastindex($S,$n))), in_quote_context, escs)
    used_S |= used_arg
    ref_ex.args[j] = exj
    ni += 1
    if need_temps
        isva = isexpr(exj, :...) # implied need_temps
        if isva
            exj = exj.args[1]
        end
        if isa_ast_node(exj) # create temp to preserve evaluation order and count in case `used` gets set later
            exj = gensym(:arg)
            push!(temp_vars, (j, exj))
        end
        if isva
            ni -= 1
            nx = nx === 0 ? :(length($exj)) : :($nx + length($exj))
        end
    end
```

**stdlib/SharedArrays/src/SharedArrays.jl:105-153**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f20e7549dc1e7a04849566cb80e0507969f848eb/stdlib/SharedArrays/src/SharedArrays.jl#L105-L153)
```julia
function SharedArray{T,N}(dims::Dims{N}; init=false, pids=Int[]) where {T,N}
    isbitstype(T) || throw(ArgumentError("type of SharedArray elements must be bits types, got $(T)"))

    pids, onlocalhost = shared_pids(pids)

    local shm_seg_name = ""
    local s = Array{T}(undef, ntuple(d->0,N))
    local S
    local shmmem_create_pid
    try
        # On OSX, the shm_seg_name length must be <= 31 characters (including the terminating NULL character)
        seg_name = "/jl$(lpad(string(getpid() % 10^6), 6, "0"))$(randstring(20))"
        shm_seg_name = seg_name
        if onlocalhost
            shmmem_create_pid = myid()
            s = shm_mmap_array(T, dims, seg_name, JL_O_CREAT | JL_O_RDWR)
        else
            # The shared array is created on a remote machine
            shmmem_create_pid = pids[1]
            remotecall_fetch(pids[1]) do
                shm_mmap_array(T, dims, seg_name, JL_O_CREAT | JL_O_RDWR)
                nothing
            end
        end

        func_mapshmem = () -> shm_mmap_array(T, dims, seg_name, JL_O_RDWR)

        refs = Vector{Future}(undef, length(pids))
        for (i, p) in enumerate(pids)
            refs[i] = remotecall(func_mapshmem, p)
        end

        # Wait till all the workers have mapped the segment
        for ref in refs
            wait(ref)
        end

        # All good, immediately unlink the segment.
        if (prod(dims) > 0) && (sizeof(T) > 0)
            if onlocalhost
                rc = shm_unlink(seg_name)
            else
                rc = remotecall_fetch(shm_unlink, shmmem_create_pid, seg_name)
            end
            systemerror("Error unlinking shmem segment " * seg_name, rc != 0)
        end
        S = SharedArray{T,N}(dims, pids, refs, seg_name, s)
        initialize_shared_array(S, onlocalhost, init, pids)
        shm_seg_name = ""

    finally
        if !isempty(shm_seg_name)
            remotecall_fetch(shm_unlink, shmmem_create_pid, shm_seg_name)
        end
    end
    S
end
```

**stdlib/SharedArrays/src/SharedArrays.jl:176-237**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f20e7549dc1e7a04849566cb80e0507969f848eb/stdlib/SharedArrays/src/SharedArrays.jl#L176-L237)
```julia
function SharedArray{T,N}(filename::AbstractString, dims::NTuple{N,Int}, offset::Integer=0;
                          mode=nothing, init=false, pids::Vector{Int}=Int[]) where {T,N}
    if !isabspath(filename)
        throw(ArgumentError("$filename is not an absolute path; try abspath(filename)?"))
    end
    if !isbitstype(T)
        throw(ArgumentError("type of SharedArray elements must be bits types, got $(T)"))
    end

    pids, onlocalhost = shared_pids(pids)

    # If not supplied, determine the appropriate mode
    have_file = onlocalhost ? isfile(filename) : remotecall_fetch(isfile, pids[1], filename)
    mode_val = mode === nothing ? (have_file ? "r+" : "w+") : mode
    workermode = mode_val == "w+" ? "r+" : mode_val  # workers don't truncate!

    # Ensure the file will be readable
    if !(mode_val in ("r", "r+", "w+", "a+"))
        throw(ArgumentError("mode must be readable, but $mode_val is not"))
    end
    if init !== false
        typeassert(init, Function)
        if !(mode_val in ("r+", "w+", "a+"))
            throw(ArgumentError("cannot initialize unwritable array (mode = $mode_val)"))
        end
    end
    if mode_val == "r" && !isfile(filename)
        throw(ArgumentError("file $filename does not exist, but mode $mode_val cannot create it"))
    end

    # Create the file if it doesn't exist, map it if it does
    refs = Vector{Future}(undef, length(pids))
    func_mmap = mode -> open(filename, mode) do io
        mmap(io, Array{T,N}, dims, offset; shared=true)
    end
    s = Array{T}(undef, ntuple(d->0,N))
    if onlocalhost
        s = func_mmap(mode_val)
        refs[1] = remotecall(pids[1]) do
            func_mmap(workermode)
        end
    else
        refs[1] = remotecall_wait(pids[1]) do
            func_mmap(mode_val)
        end
    end

    # Populate the rest of the workers
    for i = 2:length(pids)
        refs[i] = remotecall(pids[i]) do
            func_mmap(workermode)
        end
    end

    # Wait till all the workers have mapped the segment
    for ref in refs
        wait(ref)
    end

    S = SharedArray{T,N}(dims, pids, refs, filename, s)
    initialize_shared_array(S, onlocalhost, init, pids)
    S
end
```

</details>

#### 3. Existing tests in test/misc.jl continue to assert time_print output formatting (before/after behavior remains identical).

**Component**: Tests

<details>
<summary>Evidence</summary>

**test/misc.jl:381-388**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f20e7549dc1e7a04849566cb80e0507969f848eb/test/misc.jl#L381-L388)
```julia
# this is internal, but used for easy testing
@test sprint(Base.time_print, 1e9) == "  1.000000 seconds"
@test sprint(Base.time_print, 1e9, 111, 0, 222) == "  1.000000 seconds (222 allocations: 111 bytes)"
@test sprint(Base.time_print, 1e9, 111, 0.5e9, 222) == "  1.000000 seconds (222 allocations: 111 bytes, 50.00% gc time)"
@test sprint(Base.time_print, 1e9, 111, 0, 222, 333) == "  1.000000 seconds (222 allocations: 111 bytes, 333 lock conflicts)"
@test sprint(Base.time_print, 1e9, 0, 0, 0, 333) == "  1.000000 seconds (333 lock conflicts)"
@test sprint(Base.time_print, 1e9, 111, 0, 222, 333, 0.25e9) == "  1.000000 seconds (222 allocations: 111 bytes, 333 lock conflicts, 25.00% compilation time)"
@test sprint(Base.time_print, 1e9, 111, 0.5e9, 222, 333, 0.25e9, 0.175e9) == "  1.000000 seconds (222 allocations: 111 bytes, 50.00% gc time, 333 lock conflicts, 25.00% compilation time: 70% of which was recompilation)"
```

</details>

### Secondary Effects

#### Inference over _apply_iterate arguments continues to unroll iterator shapes with fewer captured-variable boxes when the task state machine suspends/resumes.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
infercalls(interp, sv) in abstract_apply  [Compiler/src/abstractinterpretation.jl:1764-1804]
  -> precise_container_type(interp, itft.contents, ti, vtypes, sv)  [Compiler/src/abstractinterpretation.jl:1769-1779]
  -> abstract_iteration(interp, itft, typ, vtypes, sv)  [Compiler/src/abstractinterpretation.jl:1567-1707]
  -> inferiterate_2arg() uses let iteratef = iteratef to avoid boxing captured iteratef across resumable tasks.
```
</details>

**Downstream Surfaces:**
- Core.Compiler inference for _apply_iterate
- JET/IRTools consumers of inference metadata (reduced heap pressure in analysis)

#### SharedArrays creation avoids boxing of segment name and mode values in closures passed to remotecall/mmap helpers.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
SharedArray{T,N}(dims::Dims{N}) defines seg_name and passes it into shm_mmap_array and func_mapshmem closures  [stdlib/SharedArrays/src/SharedArrays.jl:105-153]
SharedArray{T,N}(filename::AbstractString, ...) computes mode_val once and reuses it in func_mmap and remotecall closures  [stdlib/SharedArrays/src/SharedArrays.jl:176-237]
```
</details>

**Downstream Surfaces:**
- SharedArrays mmap setup on local/remote workers

### Compatibility

### Performance

**Compile Time:**
- ESTIMATED: fewer Core.Box allocations during inference of _apply_iterate/precise_container_type state machines; should slightly reduce analysis-time heap pressure for iterator-heavy code.

**Runtime:**
- ESTIMATED: minor reduction in allocations when running SharedArrays setup and Base time_print formatting due to fewer boxed locals; no semantic change expected.

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are limited to refactoring of local bindings; control flow and output formatting are unchanged in tests.
- No new API surface or behavior change introduced; test expectations for time_print remain identical.

### Recommendations

- No downstream action required; keep existing misc.jl time_print tests as coverage for formatting invariants.
