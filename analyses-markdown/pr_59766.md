# PR #59766: Align interpreter and codegen error behavior of setglobal! and friends

## Metadata

- **Author**: Keno
- **URL**: https://github.com/JuliaLang/julia/pull/59766
- **Merged**: 2025-10-08 15:38 UTC
- **Diff**: https://github.com/JuliaLang/julia/pull/59766.diff

## Scope

### Files Touched
- `Compiler/src/abstractinterpretation.jl`
- `Compiler/test/inference.jl`
- `base/boot.jl`
- `base/errorshow.jl`
- `src/codegen.cpp`
- `src/datatype.c`
- `src/genericmemory.c`
- `src/julia.h`
- `src/julia_internal.h`
- `src/module.c`
- `src/rtutils.c`
- `test/core.jl`

### Components
- Compiler.AbstractInterpretation
- Codegen
- Runtime
- Base.Errors

### Pipeline Stages
- TypeInference
- Codegen
- Runtime
- Diagnostics

## Analysis

### Intent

Unify setglobal!/swapglobal!/replaceglobal!/modifyglobal! error behavior between interpreter and codegen by raising TypeError with binding-aware context instead of ErrorException, and update inference modeling to avoid inconsistent exception typing.

### Direct Changes

#### 1. Inference for setglobal! now models TypeError (or TypeError/ErrorException union) in constant and partitioned global assignment paths.

**Component**: Compiler.AbstractInterpretation

<details>
<summary>Evidence</summary>

**Compiler/src/abstractinterpretation.jl:2480-2496**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/Compiler/src/abstractinterpretation.jl#L2480-L2496)
```julia
function abstract_eval_setglobal!(interp::AbstractInterpreter, sv::AbsIntState, saw_latestworld::Bool, @nospecialize(M), @nospecialize(s), @nospecialize(v))
    if isa(M, Const) && isa(s, Const)
        M, s = M.val, s.val
        if M isa Module && s isa Symbol
            gr = GlobalRef(M, s)
            (rt, exct) = global_assignment_rt_exct(interp, sv, saw_latestworld, gr, v)
            return CallMeta(rt, exct, Effects(setglobal!_effects, nothrow=exct===Bottom), GlobalAccessInfo(convert(Core.Binding, gr)))
        end
        return CallMeta(Union{}, Union{TypeError, ErrorException}, EFFECTS_THROWS, NoCallInfo())
    end
    ⊑ = partialorder(typeinf_lattice(interp))
    if !(hasintersect(widenconst(M), Module) && hasintersect(widenconst(s), Symbol))
        return CallMeta(Union{}, TypeError, EFFECTS_THROWS, NoCallInfo())
    elseif M ⊑ Module && s ⊑ Symbol
        return CallMeta(v, ErrorException, setglobal!_effects, NoCallInfo())
    end
    return CallMeta(v, Union{TypeError, ErrorException}, setglobal!_effects, NoCallInfo())
end
```

**Compiler/src/abstractinterpretation.jl:3752-3779**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/Compiler/src/abstractinterpretation.jl#L3752-L3779)
```julia
function global_assignment_rt_exct(interp::AbstractInterpreter, sv::AbsIntState, saw_latestworld::Bool, g::GlobalRef, @nospecialize(newty))
    if saw_latestworld
        return Pair{Any,Any}(newty, Union{TypeError, ErrorException})
    end
    newty′ = RefValue{Any}(newty)
    (valid_worlds, ret) = scan_partitions(interp, g, sv.world) do interp::AbstractInterpreter, ::Core.Binding, partition::Core.BindingPartition
        global_assignment_binding_rt_exct(interp, partition, newty′[])
    end
    update_valid_age!(sv, valid_worlds)
    return ret
end

function global_assignment_binding_rt_exct(interp::AbstractInterpreter, partition::Core.BindingPartition, @nospecialize(newty))
    kind = binding_kind(partition)
    if is_some_guard(kind)
        return Pair{Any,Any}(newty, ErrorException)
    elseif is_some_const_binding(kind) || is_some_imported(kind)
        # N.B.: Backdating should not improve inference in an earlier world
        return Pair{Any,Any}(kind == PARTITION_KIND_BACKDATED_CONST ? newty : Bottom, ErrorException)
    end
    ty = kind == PARTITION_KIND_DECLARED ? Any : partition_restriction(partition)
    wnewty = widenconst(newty)
    if !hasintersect(wnewty, ty)
        return Pair{Any,Any}(Bottom, TypeError)
    elseif !(wnewty <: ty)
        retty = tmeet(typeinf_lattice(interp), newty, ty)
        return Pair{Any,Any}(retty, TypeError)
    end
    return Pair{Any,Any}(newty, Bottom)
end
```

</details>

#### 2. Runtime global assignment checks now throw TypeError with a GlobalRef context, and showerror displays the binding name.

**Component**: Runtime / Base.Errors

<details>
<summary>Evidence</summary>

**src/module.c:1887-1939**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/module.c#L1887-L1939)
```julia
jl_value_t *jl_check_binding_assign_value(jl_binding_t *b JL_PROPAGATES_ROOT, jl_module_t *mod, jl_sym_t *var, jl_value_t *rhs JL_MAYBE_UNROOTED, const char *msg)
{
    JL_GC_PUSH1(&rhs); // callee-rooted
    jl_binding_partition_t *bpart = jl_get_binding_partition(b, jl_current_task->world_age);
    enum jl_partition_kind kind = jl_binding_kind(bpart);
    assert(kind == PARTITION_KIND_DECLARED || kind == PARTITION_KIND_GLOBAL);
    jl_value_t *old_ty = kind == PARTITION_KIND_DECLARED ? (jl_value_t*)jl_any_type : bpart->restriction;
    JL_GC_PROMISE_ROOTED(old_ty);
    if (old_ty != (jl_value_t*)jl_any_type && jl_typeof(rhs) != old_ty && !jl_isa(rhs, old_ty)) {
        jl_type_error_global(msg, mod, var, old_ty, rhs);
    }
    JL_GC_POP();
    return old_ty;
}

JL_DLLEXPORT void jl_checked_assignment(jl_binding_t *b, jl_module_t *mod, jl_sym_t *var, jl_value_t *rhs)
{
    if (jl_check_binding_assign_value(b, mod, var, rhs, "setglobal!") != NULL) {
        jl_atomic_store_release(&b->value, rhs);
        jl_gc_wb(b, rhs);
    }
}

JL_DLLEXPORT jl_value_t *jl_checked_modify(jl_binding_t *b, jl_module_t *mod, jl_sym_t *var, jl_value_t *op, jl_value_t *rhs)
{
    jl_binding_partition_t *bpart = jl_get_binding_partition(b, jl_current_task->world_age);
    enum jl_partition_kind kind = jl_binding_kind(bpart);
    assert(!jl_bkind_is_some_guard(kind) && !jl_bkind_is_some_import(kind));
    if (jl_bkind_is_some_constant(kind))
        jl_errorf("invalid assignment to constant %s.%s",
                  jl_symbol_name(mod->name), jl_symbol_name(var));
    jl_value_t *ty = bpart->restriction;
    JL_GC_PROMISE_ROOTED(ty);
    return modify_value(ty, &b->value, (jl_value_t*)b, op, rhs, 1, b, mod, var);
}
```

**src/rtutils.c:112-131**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/rtutils.c#L112-L131)
```julia
JL_DLLEXPORT void JL_NORETURN jl_type_error_rt(const char *fname, const char *context,
                                       jl_value_t *expected JL_MAYBE_UNROOTED,
                                       jl_value_t *got JL_MAYBE_UNROOTED)
{
    jl_value_t *ctxt=NULL;
    JL_GC_PUSH3(&ctxt, &expected, &got);
    ctxt = jl_pchar_to_string((char*)context, strlen(context));
    jl_value_t *ex = jl_new_struct(jl_typeerror_type, jl_symbol(fname), ctxt, expected, got);
    jl_throw(ex);
}

JL_DLLEXPORT void JL_NORETURN jl_type_error_global(const char *fname, jl_module_t *mod, jl_sym_t *sym,
                                       jl_value_t *expected JL_MAYBE_UNROOTED,
                                       jl_value_t *got JL_MAYBE_UNROOTED)
{
    jl_value_t *gr = jl_module_globalref(mod, sym);
    jl_value_t *ex = jl_new_struct(jl_typeerror_type, jl_symbol(fname), gr, expected, got);
    jl_throw(ex);
}
```

**base/boot.jl:406-418**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/base/boot.jl#L406-L418)
```julia
struct TypeError <: Exception
    # `func` is the name of the builtin function that encountered a type error,
    # the name of the type that hit an error in its definition or application, or
    # some other brief description of where the error happened.
    # `context` optionally adds extra detail, e.g. the name of the type parameter
    # that got a bad value.
    func::Symbol
    context::Union{AbstractString,GlobalRef,Symbol}
    expected::Type
    got
    TypeError(func, context, @nospecialize(expected::Type), @nospecialize(got)) =
        new(func, context, expected, got)
end
```

**base/errorshow.jl:80-103**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/base/errorshow.jl#L80-L103)
```julia
function showerror(io::IO, ex::TypeError)
    print(io, "TypeError: ")
    if ex.expected === Bool
        print(io, "non-boolean (", typeof(ex.got), ") used in boolean context")
    elseif ex.func === :var"dict key"
        print(io, "$(limitrepr(ex.got)) is not a valid key for type $(ex.expected)")
    else
        if isvarargtype(ex.got)
            targs = (ex.got,)
        elseif isa(ex.got, Type)
            targs = ("Type{", ex.got, "}")
        else
            targs = ("a value of type $(typeof(ex.got))",)
        end
        if ex.context == ""
            ctx = "in $(ex.func)"
        elseif isa(ex.context, Core.GlobalRef)
            gr = ex.context
            ctx = "in $(ex.func) of global binding `$(gr.mod).$(gr.name)`"
        elseif ex.func === :var"keyword argument"
            ctx = "in keyword argument $(ex.context)"
        else
            ctx = "in $(ex.func), in $(ex.context)"
        end
        print(io, ctx, ", expected ", ex.expected, ", got ", targs...)
    end
    Experimental.show_error_hints(io, ex)
end
```

</details>

#### 3. Codegen type checks for global assignment now use setglobal!/swapglobal!/replaceglobal!/modifyglobal!/setglobalonce! as the TypeError function name.

**Component**: Codegen

<details>
<summary>Evidence</summary>

**src/codegen.cpp:3224-3263**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/codegen.cpp#L3224-L3263)
```julia
jl_binding_t *bnd = jl_get_module_binding(mod, sym, 1);
jl_binding_partition_t *bpart = jl_get_binding_partition_all(bnd, ctx.min_world, ctx.max_world);
Value *bp = julia_binding_gv(ctx, bnd);
if (bpart) {
    if (jl_binding_kind(bpart) == PARTITION_KIND_GLOBAL) {
        int possibly_deprecated = bpart->kind & PARTITION_FLAG_DEPWARN;
        jl_value_t *ty = bpart->restriction;
        if (ty != nullptr) {
            const std::string fname = issetglobal ? "setglobal!" : isreplaceglobal ? "replaceglobal!" : isswapglobal ? "swapglobal!" : ismodifyglobal ? "modifyglobal!" : "setglobalonce!";
            if (!ismodifyglobal) {
                emit_typecheck(ctx, rval, ty, fname.c_str());
                rval = update_julia_type(ctx, rval, ty);
                if (rval.typ == jl_bottom_type)
                    return jl_cgval_t();
            }
            bool isboxed = true;
            bool maybe_null = jl_atomic_load_relaxed(&bnd->value) == NULL;
            if (possibly_deprecated) {
                ctx.builder.CreateCall(prepare_call(jldepcheck_func), { bp });
            }
            return typed_store(ctx,
                            julia_binding_pvalue(ctx, bp),
                            rval, cmp, ty,
                            ctx.tbaa().tbaa_binding,
                            nullptr,
                            bp,
                            isboxed,
                            Order,
                            FailOrder,
                            0,
                            nullptr,
                            issetglobal,
                            isreplaceglobal,
                            isswapglobal,
                            ismodifyglobal,
                            issetglobalonce,
                            maybe_null,
                            modifyop,
                            fname,
                            mod,
                            sym);
```

</details>

#### 4. modifyglobal! and memoryrefmodify! now route through jl_check_binding_assign_value when operating on bindings, ensuring consistent TypeError behavior.

**Component**: Runtime

<details>
<summary>Evidence</summary>

**src/datatype.c:1995-2026**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/datatype.c#L1995-L2026)
```julia
inline jl_value_t *modify_value(jl_value_t *ty, _Atomic(jl_value_t*) *p, jl_value_t *parent, jl_value_t *op, jl_value_t *rhs, int isatomic, jl_binding_t *b, jl_module_t *mod, jl_sym_t *name)
{
    jl_value_t *r = isatomic ? jl_atomic_load(p) : jl_atomic_load_relaxed(p);
    if (__unlikely(r == NULL)) {
        if (b)
            jl_undefined_var_error(name, (jl_value_t*)mod);
        jl_throw(jl_undefref_exception);
    }
    jl_value_t **args;
    JL_GC_PUSHARGS(args, 2);
    args[0] = r;
    while (1) {
        args[1] = rhs;
        jl_value_t *y = jl_apply_generic(op, args, 2);
        args[1] = y;
        if (b)
            jl_check_binding_assign_value(b, mod, name, y, "modifyglobal!");
        else if (!jl_isa(y, ty))
            jl_type_error(jl_is_genericmemory(parent) ? "memoryrefmodify!" : "modifyfield!", ty, y);
        if (isatomic ? jl_atomic_cmpswap(p, &r, y) : jl_atomic_cmpswap_release(p, &r, y)) {
            jl_gc_wb(parent, y);
            break;
        }
        args[0] = r;
        jl_gc_safepoint();
    }
    // args[0] == r (old)
    // args[1] == y (new)
    jl_datatype_t *rettyp = jl_apply_modify_type(ty);
    JL_GC_PROMISE_ROOTED(rettyp); // (JL_ALWAYS_LEAFTYPE)
    args[0] = jl_new_struct(rettyp, args[0], args[1]);
    JL_GC_POP();
    return args[0];
}
```

**src/genericmemory.c:501-510**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/src/genericmemory.c#L501-L510)
```julia
JL_DLLEXPORT jl_value_t *jl_memoryrefmodify(jl_genericmemoryref_t m, jl_value_t *op, jl_value_t *rhs, int isatomic)
{
    jl_value_t *eltype = jl_tparam1(jl_typetagof(m.mem));
    const jl_datatype_layout_t *layout = ((jl_datatype_t*)jl_typetagof(m.mem))->layout;
    jl_value_t *owner = jl_genericmemory_owner(m.mem);
    char *data = (char*)m.ptr_or_offset;
    if (layout->flags.arrayelem_isboxed) {
        assert(data - (char*)m.mem->ptr < sizeof(jl_value_t*) * m.mem->length);
        return modify_value(eltype, (_Atomic(jl_value_t*)*)data, owner, op, rhs, isatomic, NULL, NULL, NULL);
    }
```

</details>

#### 5. Tests now assert TypeError for invalid setglobal! assignments, matching inference and runtime behavior.

**Component**: Tests

<details>
<summary>Evidence</summary>

**Compiler/test/inference.jl:6458-6461**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/Compiler/test/inference.jl#L6458-L6461)
```julia
global invalid_setglobal!_exct_modeling::Int
@test Base.infer_exception_type((Float64,)) do x
    setglobal!(@__MODULE__, :invalid_setglobal!_exct_modeling, x)
end == TypeError
```

**test/core.jl:8147-8159**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3cebd25dbb9b3b7a0d3357402950a8a5dcfc696a/test/core.jl#L8147-L8159)
```julia
@testset "setproperty! on modules" begin
    m = Module()
    @eval m global x::Int

    setglobal!(m, :x, 1)
    @test m.x === 1
    setglobal!(m, :x, 2, :release)
    @test m.x === 2
    @test_throws ConcurrencyViolationError setglobal!(m, :x, 3, :not_atomic)
    @test_throws TypeError setglobal!(m, :x, 4., :release)

    f_set_bad_type(m) = setglobal!(m, :x, 4., :release)
    @test_throws TypeError f_set_bad_type(m)
```

</details>

### Secondary Effects

#### Error reporting for global assignment type mismatches now includes the concrete binding in the TypeError context (GlobalRef), aligning interpreter and codegen error messages.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
jl_checked_assignment(b, mod, var, rhs) [module.c:1904-1909]
  -> jl_check_binding_assign_value(b, mod, var, rhs, "setglobal!") [module.c:1889-1899]
    -> jl_type_error_global("setglobal!", mod, var, old_ty, rhs) [module.c:1897-1899]
      -> jl_type_error_global builds TypeError with GlobalRef context [rtutils.c:124-130]
        -> showerror recognizes Core.GlobalRef context for message formatting [base/errorshow.jl:92-103]
```
</details>

**Downstream Surfaces:**
- User-facing error text for setglobal!/swapglobal!/replaceglobal!/modifyglobal!/setglobalonce!
- Tests or tooling matching on TypeError.context

#### Inference exception modeling for setglobal! now propagates TypeError for non-intersecting assignments, reducing mismatches between inference and runtime/codegen.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
abstract_eval_setglobal!(...) [abstractinterpretation.jl:2480-2496]
  -> global_assignment_rt_exct(...) [abstractinterpretation.jl:3752-3761]
    -> global_assignment_binding_rt_exct(...) [abstractinterpretation.jl:3764-3778]
       returns TypeError when !hasintersect(wnewty, ty) or !(wnewty <: ty)
```
</details>

**Downstream Surfaces:**
- Base.infer_exception_type for global assignments
- Core.Compiler effect analysis (setglobal! throw classification)

### Compatibility

#### Internal API Changes
- **TypeError.context**: Now accepts Core.GlobalRef in addition to AbstractString and Symbol.
- **jl_check_binding_assign_value**: Signature now includes a const char *msg to supply the builtin name for TypeError.
- **jl_type_error_global**: New exported runtime helper for binding-aware TypeError creation.

#### Behavioral Changes
- setglobal!/swapglobal!/replaceglobal!/modifyglobal!/setglobalonce! now throw TypeError (with binding context) instead of ErrorException for type mismatches. *(Impact: User code that caught ErrorException for these cases will now see TypeError; error message format includes global binding name.)*

### Performance

**Compile Time:**
- ESTIMATED: negligible. Inference now unions TypeError into setglobal! exception type but does not add new passes.

**Runtime:**
- ESTIMATED: no measurable change on success paths; error paths allocate TypeError with GlobalRef context instead of ErrorException.

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are localized to error-path behavior and exception typing for global assignment operations.
- Tests explicitly lock in TypeError behavior for setglobal! and inference.

### Recommendations

- Downstream tooling that inspects TypeError.context should accept Core.GlobalRef in addition to strings/symbols.
- If embedding Julia, update any direct calls to jl_check_binding_assign_value to pass the builtin name for error reporting.
