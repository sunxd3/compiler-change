# PR #60162: Bypass `SyntaxNode` in JuliaLowering; fix `kw` bug

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60162
- **Merged**: 2025-12-02 23:51 UTC
- **Labels**: `parser`, `compiler:lowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60162.diff

## Scope

### Files Touched
- `JuliaLowering/src/compat.jl`
- `JuliaLowering/src/desugaring.jl`
- `JuliaLowering/src/syntax_graph.jl`
- `JuliaLowering/src/syntax_macros.jl`
- `JuliaLowering/test/compat.jl`
- `JuliaLowering/test/functions.jl`
- `JuliaLowering/test/quoting.jl`
- `JuliaLowering/test/typedefs_ir.jl`
- `JuliaSyntax/src/integration/expr.jl`
- `JuliaSyntax/src/julia/kinds.jl`

### Components
- JuliaSyntax
- JuliaLowering

### Pipeline Stages
- Parsing
- Lowering
- MacroExpansion

## Analysis

### Intent

Move JuliaLowering’s SyntaxTree construction to bypass SyntaxNode, add an AST-level "kw" kind that preserves keyword semantics earlier, and fix keyword argument handling in arrow syntax and other lowering paths.

**Related Issues:**
- https://github.com/c42f/JuliaLowering.jl/issues/98
- https://github.com/c42f/JuliaLowering.jl/issues/77
- https://github.com/JuliaLang/JuliaSyntax.jl/pull/522

### Direct Changes

#### 1. SyntaxTree now builds directly from the raw green tree, storing byte ranges in SourceRef and converting "=" to "kw" in keyword positions before lowering.

**Component**: JuliaLowering.SyntaxGraph

<details>
<summary>Evidence</summary>

**JuliaLowering/src/syntax_graph.jl:315-324**
[View on GitHub](https://github.com/JuliaLang/julia/blob/296cca2365f3736af59def97564d3a244677282a/JuliaLowering/src/syntax_graph.jl#L315-L324)
```julia
struct SourceRef
    file::SourceFile
    first_byte::Int
    last_byte::Int
end

JuliaSyntax.sourcefile(src::SourceRef) = src.file
JuliaSyntax.byte_range(src::SourceRef) = src.first_byte:src.last_byte
```

**JuliaLowering/src/syntax_graph.jl:818-848**
[View on GitHub](https://github.com/JuliaLang/julia/blob/296cca2365f3736af59def97564d3a244677282a/JuliaLowering/src/syntax_graph.jl#L818-L848)
```julia
function JuliaSyntax.build_tree(::Type{SyntaxTree}, stream::ParseStream;
                                filename=nothing, first_line=1)
    cursor = RedTreeCursor(stream)
    graph = SyntaxGraph()
    sf = SourceFile(stream; filename, first_line)
    source = SourceRef(sf, first_byte(stream), last_byte(stream))
    cs = SyntaxList(graph)
    for c in reverse_toplevel_siblings(cursor)
        is_trivia(c) && !is_error(c) && continue
        push!(cs, SyntaxTree(graph, sf, c))
    end
    length(cs) === 1 && return only(cs)
    id = newnode!(graph)
    setchildren!(graph, id, reverse(cs).ids)
    setattr!(graph, id; source, kind=K"wrapper")
    return SyntaxTree(graph, id)
end

function SyntaxTree(graph::SyntaxGraph, sf::SourceFile, cursor::RedTreeCursor)
    ensure_attributes!(graph, kind=Kind, syntax_flags=UInt16,
                       source=SourceAttrType, value=Any, name_val=String)
    green_id = GC.@preserve sf begin
        raw_offset, txtbuf = _unsafe_wrap_substring(sf.code)
        offset = raw_offset - sf.byte_offset
        _insert_green(graph, sf, txtbuf, offset, cursor)
    end
    out = _green_to_ast(K"None", SyntaxTree(graph, green_id))
    @assert !isnothing(out) "SyntaxTree requires >0 nontrivia nodes"
    return out
end
```

**JuliaLowering/src/syntax_graph.jl:879-909**
[View on GitHub](https://github.com/JuliaLang/julia/blob/296cca2365f3736af59def97564d3a244677282a/JuliaLowering/src/syntax_graph.jl#L879-L909)
```julia
function _green_to_ast(parent::Kind, ex::SyntaxTree; eq_to_kw=false)
    is_trivia(ex) && !is_error(ex) && return nothing
    graph = syntax_graph(ex)
    k = kind(ex)
    if k === K"ref" ||
        (k in KSet"call dotcall" && (
            is_prefix_call(ex) || is_prefix_op_call(ex) && numchildren(ex) > 2))
        cs = SyntaxList(ex)
        for c in children(ex)
            c2 = _green_to_ast(k, c; eq_to_kw=length(cs)>0)
            !isnothing(c2) && push!(cs, c2)
        end
        makenode(graph, ex, ex, cs)
    elseif k === K"parameters"
        eq_to_kw = parent != K"vect"   && parent != K"curly" &&
                   parent != K"braces" && parent != K"ref"
        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex); eq_to_kw))
    elseif k === K"parens"
        cs = _map_green_to_ast(parent, children(ex); eq_to_kw)
        @assert length(cs) === 1
        cs[1]
    elseif k in KSet"var char"
        cs = _map_green_to_ast(parent, children(ex))
        @assert length(cs) === 1
        cs[1]
    elseif k === K"=" && eq_to_kw
        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex)); kind=K"kw")
    elseif is_leaf(ex)
        return ex
    else
        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex)))
    end
end
```

</details>

#### 2. Lowering now treats K"kw" as the canonical keyword node (including in named tuple expansion and call argument extraction) and normalizes arrow argument lists to emit K"kw" defaults.

**Component**: JuliaLowering.Desugaring

<details>
<summary>Evidence</summary>

**JuliaLowering/src/desugaring.jl:1615-1690**
[View on GitHub](https://github.com/JuliaLang/julia/blob/296cca2365f3736af59def97564d3a244677282a/JuliaLowering/src/desugaring.jl#L1615-L1690)
```julia
function expand_named_tuple(ctx, ex, kws, eq_is_kw;
                            field_name="named tuple field",
                            element_name="named tuple element")
    name_strs = Set{String}()
    names = SyntaxList(ctx)
    values = SyntaxList(ctx)
    current_nt = nothing
    for (i,kw) in enumerate(kws)
        k = kind(kw)
        appended_nt = nothing
        name = nothing
        if kind(k) == K"Identifier"
            name = to_symbol(ctx, kw)
            value = kw
        elseif k == K"kw" || (eq_is_kw && k == K"=")
            if kind(kw[1]) != K"Identifier" && kind(kw[1]) != K"Placeholder"
                throw(LoweringError(kw[1], "invalid $field_name name"))
            end
            if kind(kw[2]) == K"..."
                throw(LoweringError(kw[2], "`...` cannot be used in a value for a $field_name"))
            end
            name = to_symbol(ctx, kw[1])
            value = kw[2]
        elseif k == K"."
            if kind(kw[2]) != K"Symbol"
                throw(LoweringError(kw, "invalid $element_name"))
            end
            name = to_symbol(ctx, kw[2])
            value = kw
        elseif k == K"call" && is_infix_op_call(kw) && numchildren(kw) == 3 &&
                is_same_identifier_like(kw[1], "=>")
            appended_nt = _named_tuple_expr(ctx, kw, (kw[2],), (kw[3],))
            nothing, nothing
        elseif k == K"..."
            appended_nt = kw[1]
            if isnothing(current_nt) && isempty(names)
                current_nt = _named_tuple_expr(ctx, ex, (), ())
            end
            nothing, nothing
        else
            throw(LoweringError(kw, "Invalid $element_name"))
        end
        if !isnothing(name)
            if kind(name) == K"Symbol"
                name_str = name.name_val
                if name_str in name_strs
                    throw(LoweringError(name, "Repeated $field_name name"))
                end
                push!(name_strs, name_str)
            end
            push!(names, name)
            push!(values, value)
        end
        if !isnothing(appended_nt)
            if !isempty(names)
                current_nt = _merge_named_tuple(ctx, ex, current_nt,
                                                _named_tuple_expr(ctx, ex, names, values))
                empty!(names)
                empty!(values)
            end
            current_nt = _merge_named_tuple(ctx, ex, current_nt, appended_nt)
        end
    end
    if !isempty(names) || isnothing(current_nt)
        current_nt = _merge_named_tuple(ctx, ex, current_nt,
                                        _named_tuple_expr(ctx, ex, names, values))
    end
    @assert !isnothing(current_nt)
    current_nt
end
```

**JuliaLowering/src/desugaring.jl:1865-1897**
[View on GitHub](https://github.com/JuliaLang/julia/blob/296cca2365f3736af59def97564d3a244677282a/JuliaLowering/src/desugaring.jl#L1865-L1897)
```julia
function remove_kw_args!(ctx, args::SyntaxList)
    kws = nothing
    j = 0
    num_parameter_blocks = 0
    for i in 1:length(args)
        arg = args[i]
        k = kind(arg)
        if k == K"kw"
            if isnothing(kws)
                kws = SyntaxList(ctx)
            end
            push!(kws, arg)
        elseif k == K"parameters"
            num_parameter_blocks += 1
            if num_parameter_blocks > 1
                throw(LoweringError(arg, "Cannot have more than one group of keyword arguments separated with `;`"))
            end
            if numchildren(arg) == 0
                continue # ignore empty parameters (issue #18845)
            end
            if isnothing(kws)
                kws = SyntaxList(ctx)
            end
            append!(kws, children(arg))
        else
            j += 1
            if j < i
                args[j] = args[i]
            end
        end
    end
    resize!(args, j)
    return kws
end
```

**JuliaLowering/src/desugaring.jl:3238-3258**
[View on GitHub](https://github.com/JuliaLang/julia/blob/296cca2365f3736af59def97564d3a244677282a/JuliaLowering/src/desugaring.jl#L3238-L3258)
```julia
function expand_arrow_args(ctx, arglist)
    k = kind(arglist)
    if k == K"block"
        @chk numchildren(arglist) == 2
        kw = arglist[2]
        if kind(kw) === K"="
            kw = @ast ctx kw [K"kw" children(kw)...]
        end
        arglist = @ast ctx arglist [K"tuple"
            arglist[1]
            [K"parameters" kw]
        ]
    elseif k != K"tuple"
        arglist = @ast ctx arglist [K"tuple" arglist]
    end
    return mapchildren(ctx, arglist) do a
        kind(a) === K"=" ? @ast(ctx, a, [K"kw" children(a)...]) : a
    end
end
```

</details>

#### 3. Expr conversion now distinguishes SyntaxTree-specific fixups by passing the tree type through fixup_Expr_child, allowing SyntaxTree to preserve dot/operator coalescing without reusing SyntaxNode semantics.

**Component**: JuliaSyntax.ExprIntegration

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/integration/expr.jl:146-176**
[View on GitHub](https://github.com/JuliaLang/julia/blob/296cca2365f3736af59def97564d3a244677282a/JuliaSyntax/src/integration/expr.jl#L146-L176)
```julia
function fixup_Expr_child(::Type, head::SyntaxHead, @nospecialize(arg), first::Bool)
    isa(arg, Expr) || return arg
    k = kind(head)
    eq_to_kw_in_call = ((k == K"call" || k == K"dotcall") &&
                        is_prefix_call(head)) || k == K"ref"
    eq_to_kw_in_params = k != K"vect"   && k != K"curly" &&
                         k != K"braces" && k != K"ref"
    coalesce_dot = k in KSet"call dotcall curly" ||
                   (k == K"quote" && has_flags(head, COLON_QUOTE))
    was_parens = @isexpr(arg, :parens)
    arg = _strip_parens(arg)
    if @isexpr(arg, :(=)) && eq_to_kw_in_call && !first
        arg = Expr(:kw, arg.args...)
    elseif k != K"parens" && @isexpr(arg, :., 1) && arg.args[1] isa Tuple
        h, a = arg.args[1]::Tuple{SyntaxHead,Any}
        arg = ((!was_parens && coalesce_dot && first) ||
                is_syntactic_operator(h)) ?
            Symbol(".", a) : Expr(:., a)
    elseif @isexpr(arg, :parameters) && eq_to_kw_in_params
        pargs = arg.args
        for j = 1:length(pargs)
            pj = pargs[j]
            if @isexpr(pj, :(=))
                pargs[j] = Expr(:kw, pj.args...)
            end
        end
    end
    return arg
end
```

**JuliaLowering/src/syntax_graph.jl:577-588**
[View on GitHub](https://github.com/JuliaLang/julia/blob/296cca2365f3736af59def97564d3a244677282a/JuliaLowering/src/syntax_graph.jl#L577-L588)
```julia
function JuliaSyntax.fixup_Expr_child(::Type{<:SyntaxTree}, head::SyntaxHead,
                                      @nospecialize(arg), first::Bool)
    isa(arg, Expr) || return arg
    k = kind(head)
    coalesce_dot = k in KSet"call dotcall curly" ||
                   (k == K"quote" && has_flags(head, COLON_QUOTE))
    if @isexpr(arg, :., 1) && arg.args[1] isa Tuple
        h, a = arg.args[1]::Tuple{SyntaxHead,Any}
        arg = ((coalesce_dot && first) || is_syntactic_operator(h)) ?
            Symbol(".", a) : Expr(:., a)
    end
    return arg
end
```

</details>

#### 4. Tests updated to lock in arrow/kw parsing and provenance shape changes.

**Component**: JuliaLowering.Tests

<details>
<summary>Evidence</summary>

**JuliaLowering/test/functions.jl:106-127**
[View on GitHub](https://github.com/JuliaLang/julia/blob/296cca2365f3736af59def97564d3a244677282a/JuliaLowering/test/functions.jl#L106-L127)
```julia
@test JuliaLowering.include_string(test_mod, """
let
    f = ((x::T, y::T) where T) -> x + y
    f(1, 2)
end
""") === 3

@test JuliaLowering.include_string(test_mod, """
let
    f = ((x::T; y=2) where T) -> x + y
    f(1)
end
""") === 3

@test JuliaLowering.include_string(test_mod, """
let
    f = ((x::T) where T) -> x
    f(1)
end
""") === 1
```

**JuliaLowering/test/quoting.jl:5-52**
[View on GitHub](https://github.com/JuliaLang/julia/blob/296cca2365f3736af59def97564d3a244677282a/JuliaLowering/test/quoting.jl#L5-L52)
```julia
ex = JuliaLowering.include_string(test_mod, """
begin
    x = 10
    y = :(g(z))
    quote
        f($(x+1), $y)
    end
end
""")
@test ex ≈ @ast_ [K"block"
    [K"call"
        "f"::K"Identifier"
        11::K"Value"
        [K"call"
            "g"::K"Identifier"
            "z"::K"Identifier"
        ]
    ]
]
@test sourcetext(ex[1]) == "f($(x+1), $y)"
@test sourcetext(ex[1][2]) == "$(x+1)"
@test sourcetext.(flattened_provenance(ex[1][3])) == ["$y", "g(z)"]
@test sprint(io->showprov(io, ex[1][3], tree=true)) == raw"""
    (call g z)
    ├─ (call g z)
    │  └─ (call g z)
    │     └─ (call g ✘ z ✘)
    │        └─ @ string:3
    └─ ($ y)
       └─ ($ $ y)
          └─ @ string:5
    """
```

</details>

### Secondary Effects

#### Keyword arguments are now represented as K"kw" in SyntaxTree before macro expansion, so downstream desugaring sees K"kw" consistently in call/parameters contexts rather than K"=".

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
JuliaSyntax.build_tree(::Type{SyntaxTree})  [syntax_graph.jl:818-835]
  -> SyntaxTree(graph, sf, cursor)          [syntax_graph.jl:837-847]
    -> _green_to_ast(parent, ex; eq_to_kw)  [syntax_graph.jl:879-906]
      converts K"=" to K"kw" in call/parameters contexts
  -> remove_kw_args!(ctx, args)             [desugaring.jl:1865-1897]
     collects K"kw" into keyword list
  -> expand_kw_call(...)                    [desugaring.jl:1696-1712]
     builds kwcall path for lowered calls
```
</details>

**Downstream Surfaces:**
- Macro expansion pipelines expecting K"=" nodes in SyntaxTree
- Keyword argument lowering (kwcall)
- Expr-to-SyntaxTree compatibility paths

#### Anonymous function and opaque-closure argument lists normalize defaults to K"kw", so default detection uses the same K"kw" branch as regular function arguments.

**Likelihood**: medium | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
expand_arrow_args(ctx, arglist)             [desugaring.jl:3238-3258]
  rewrites K"=" into K"kw" in arrow args
-> expand_opaque_closure(ctx, ex)           [desugaring.jl:3286-3311]
  args = expand_arrow_args(...)
-> expand_function_arg(ctx, ..., arg, ...)  [desugaring.jl:2277-2343]
  if kind(ex) == K"kw" then default = ex[2]
```
</details>

**Downstream Surfaces:**
- Anonymous function desugaring
- OpaqueClosure lowering

#### Expr reconstruction from SyntaxTree/SyntaxNode now passes the tree type into fixup_Expr_child, allowing SyntaxTree to skip eq-to-kw rewrites in its own override while still performing dot coalescing.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
node_to_expr(...) calls fixup_Expr_child(typeof(cursor), ...)  [expr.jl:214-216]
  -> SyntaxTree-specific fixup_Expr_child                    [syntax_graph.jl:577-588]
     only coalesces dotted operators
```
</details>

**Downstream Surfaces:**
- Expr compatibility layer for macros
- SyntaxTree <-> Expr round-tripping

### Compatibility

#### Internal API Changes
- **JuliaSyntax.Kind "kw"**: New syntax kind registered for keyword nodes; K"kw" may now appear in SyntaxTree trees.
- **SourceRef.last_byte**: SourceRef stores explicit byte range end instead of GreenNode; byte_range uses first/last bytes.

#### Behavioral Changes
- Keyword argument defaults in arrow syntax parse as K"kw" and no longer depend on SyntaxNode fixups.

### Performance

**Compile Time:**
- ESTIMATED: One additional green-tree walk to build SyntaxTree and rewrite trivia/kw nodes (O(n) in AST size).

**Runtime:**
- No direct runtime change expected; changes are in parsing/lowering stages.

### Risk Assessment

**Level**: medium

**Rationale:**
- Changes early in the parsing/lowering pipeline and adds a new syntax kind (K"kw").
- Alters SyntaxTree construction/provenance and Expr conversion behavior, which downstream tools may rely on.

### Recommendations

- Audit downstream tooling that inspects SyntaxTree kinds or Expr conversion paths for assumptions about K"=" in keyword positions.
- Consider adding regression tests for keyword arguments in ref/curly/vect/braces once syntax decisions are finalized.
