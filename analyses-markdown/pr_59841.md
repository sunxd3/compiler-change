# PR #59841: Libdl: Add documentation for LazyLibrary and friends

## Metadata

- **Author**: vtjnash
- **URL**: https://github.com/JuliaLang/julia/pull/59841
- **Merged**: 2025-10-17 19:12 UTC
- **Labels**: `docs`, `stdlib`
- **Diff**: https://github.com/JuliaLang/julia/pull/59841.diff

## Scope

### Files Touched
- `Compiler/src/abstractinterpretation.jl`
- `base/libdl.jl`
- `doc/src/manual/calling-c-and-fortran-code.md`
- `stdlib/Libdl/docs/src/index.md`
- `stdlib/Libdl/src/Libdl.jl`

### Components
- Compiler.AbstractInterpretation
- Libdl
- Docs

### Pipeline Stages
- TypeInference

## Analysis

### Intent

Add and expand documentation for Libdl.LazyLibrary (manual + docstrings), clarify lazy-loading guidance, and fix the LazyLibrary dependency initializer to copy the provided dependency vector.

### Direct Changes

#### 1. Expanded LazyLibrary/LazyLibraryPath/BundledLazyLibraryPath/add_dependency! docstrings with examples and compatibility notes, and clarified LazyLibrary constructor semantics.

**Component**: Libdl

<details>
<summary>Evidence</summary>

**base/libdl.jl:321-483**
[View on GitHub](https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/base/libdl.jl#L321-L483)
```julia
"""
    LazyLibraryPath(path_pieces...)

Helper type for lazily constructed library paths for use with [`LazyLibrary`](@ref).
Path pieces are stored unevaluated and joined with `joinpath()` when the library is first
accessed. Arguments must be able to have `string()` called on them.

# Example

```julia
const mylib = LazyLibrary(LazyLibraryPath(artifact_dir, "lib", "libmylib.so.1.2.3"))
```

!!! compat "Julia 1.11"
    `LazyLibraryPath` was added in Julia 1.11.

See also [`LazyLibrary`](@ref), [`BundledLazyLibraryPath`](@ref).
"""
struct LazyLibraryPath
    pieces::Tuple{Vararg{Any}}
    LazyLibraryPath(pieces...) = new(pieces)
end
@inline Base.string(llp::LazyLibraryPath) = joinpath(String[string(p) for p in llp.pieces])
Base.cconvert(::Type{Cstring}, llp::LazyLibraryPath) = Base.cconvert(Cstring, string(llp))
# Define `print` so that we can wrap this in a `LazyString`
Base.print(io::IO, llp::LazyLibraryPath) = print(io, string(llp))

"""
    BundledLazyLibraryPath(subpath)

Helper type for lazily constructed library paths within the Julia distribution.
Constructs paths relative to Julia's private shared library directory.

Primarily used by Julia's standard library. For example:
```julia
const libgmp = LazyLibrary(BundledLazyLibraryPath("libgmp.so.10"))
```

!!! compat "Julia 1.11"
    `BundledLazyLibraryPath` was added in Julia 1.11.

See also [`LazyLibrary`](@ref), [`LazyLibraryPath`](@ref).
"""
BundledLazyLibraryPath(subpath) = LazyLibraryPath(PrivateShlibdirGetter(), subpath)

"""
    LazyLibrary(name; flags = <default dlopen flags>,
                dependencies = LazyLibrary[], on_load_callback = nothing)

Represents a lazily-loaded shared library that delays loading itself and its dependencies
until first use in a `ccall()`, `@ccall`, `dlopen()`, `dlsym()`, `dlpath()`, or `cglobal()`.
This is a thread-safe mechanism for on-demand library initialization.
"""
mutable struct LazyLibrary
    # Name and flags to open with
    const path
    const flags::UInt32

    # Dependencies that must be loaded before we can load
    #
    # The OncePerProcess is introduced here so that any registered dependencies are
    # always ephemeral to a given process (instead of, e.g., persisting depending
    # on whether they were added in the process where this LazyLibrary was created)
    dependencies::Base.OncePerProcess{Vector{LazyLibrary}, InitialDependencies{LazyLibrary}}

    # Function that get called once upon initial load
    on_load_callback
    const lock::Base.ReentrantLock

    # Pointer that we eventually fill out upon first `dlopen()`
    @atomic handle::Ptr{Cvoid}
    function LazyLibrary(path; flags = default_rtld_flags, dependencies = LazyLibrary[],
                         on_load_callback = nothing)
        return new(
            path,
            UInt32(flags),
            Base.OncePerProcess{Vector{LazyLibrary}}(
                InitialDependencies{LazyLibrary}(dependencies)
            ),
            on_load_callback,
            Base.ReentrantLock(),
            C_NULL,
        )
    end
end

"""
    add_dependency!(library::LazyLibrary, dependency::LazyLibrary)

Dynamically add a dependency that must be loaded before `library`. Only needed when
dependencies cannot be determined at construction time.

!!! warning
    Dependencies added with this function are **ephemeral** and only persist within the
    current process. They will not persist across precompilation boundaries.
"""
function add_dependency!(ll::LazyLibrary, dep::LazyLibrary)
    @lock ll.lock begin
        push!(ll.dependencies(), dep)
    end
end
```

</details>

#### 2. Added a comprehensive manual section on LazyLibrary usage with examples for platform-specific libraries, dependencies, lazy paths, and initialization callbacks.

**Component**: Docs

<details>
<summary>Evidence</summary>

**doc/src/manual/calling-c-and-fortran-code.md:853-1027**
[View on GitHub](https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/doc/src/manual/calling-c-and-fortran-code.md#L853-L1027)
```julia
## Non-constant Function Specifications

In some cases, the exact name or path of the needed library is not known in
advance and must be computed at run time. To handle such cases, the library
component specification can be a value such as `Libdl.LazyLibrary`. The runtime
will call `Libdl.dlopen` on that object when first used by a `ccall`.

### [Using LazyLibrary for Lazy Loading](@id man-lazylibrary)

[`Libdl.LazyLibrary`](@ref) provides a thread-safe mechanism for deferring library loading
until first use. This is the recommended approach for library initialization in modern Julia code.

A `LazyLibrary` represents a library that opens itself (and its dependencies) automatically
on first use in a `ccall()`, `@ccall`, `dlopen()`, `dlsym()`, `dlpath()`, or `cglobal()`.
The library is loaded exactly once in a thread-safe manner, and subsequent calls reuse the
loaded library handle.

#### Basic Usage

```julia
using Libdl

# Define a LazyLibrary as a const for optimal performance
const libz = LazyLibrary("libz")

# Use directly in @ccall - library loads automatically on first call
@ccall libz.deflate(strm::Ptr{Cvoid}, flush::Cint)::Cint

# Also works with ccall
ccall((:inflate, libz), Cint, (Ptr{Cvoid}, Cint), strm, flush)
```

#### Platform-Specific Libraries

For code that needs to work across different platforms:

```julia
const mylib = LazyLibrary(
    if Sys.iswindows()
        "mylib.dll"
    elseif Sys.isapple()
        "libmylib.dylib"
    else
        "libmylib.so"
    end
)
```

#### Libraries with Dependencies

When a library depends on other libraries, specify the dependencies to ensure
they load in the correct order:

```julia
const libfoo = LazyLibrary("libfoo")
const libbar = LazyLibrary("libbar"; dependencies=[libfoo])

# When libbar is first used, libfoo is loaded first automatically
@ccall libbar.bar_function(x::Cint)::Cint
```

#### Lazy Path Construction

For libraries whose paths are determined at runtime, use `LazyLibraryPath`:

```julia
# Path is constructed when library is first accessed
const mylib = LazyLibrary(LazyLibraryPath(artifact_dir, "lib", "libmylib.so"))
```

#### Initialization Callbacks

If a library requires initialization after loading:

```julia
const mylib = LazyLibrary("libmylib";
    on_load_callback = () -> @ccall mylib.initialize()::Cvoid
)
```

!!! warning
    The `on_load_callback` should be minimal and must not call `wait()` on any tasks.
    It is called exactly once by the thread that loads the library.
```
const mylibvar = LazyLibrary("mylib")
@ccall $(@dlsym(dlopen(mylibvar), "myfunc"))()::Cvoid
```
```

</details>

#### 3. Registered `add_dependency!` as a public Libdl API and included it in the Libdl docs index.

**Component**: Libdl

<details>
<summary>Evidence</summary>

**stdlib/Libdl/src/Libdl.jl:10-19**
[View on GitHub](https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/stdlib/Libdl/src/Libdl.jl#L10-L19)
```julia
export DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,
    RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,
    dlpath, find_library, dlext, dllist, LazyLibrary, LazyLibraryPath, BundledLazyLibraryPath

public add_dependency!

import Base.Libc.Libdl: DL_LOAD_PATH, RTLD_DEEPBIND, RTLD_FIRST, RTLD_GLOBAL, RTLD_LAZY, RTLD_LOCAL,
                        RTLD_NODELETE, RTLD_NOLOAD, RTLD_NOW, dlclose, dlopen, dlopen_e, dlsym, dlsym_e,
                        dlpath, find_library, dlext, dllist, LazyLibrary, LazyLibraryPath,
                        BundledLazyLibraryPath, default_rtld_flags, add_dependency!
```

**stdlib/Libdl/docs/src/index.md:25-31**
[View on GitHub](https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/stdlib/Libdl/docs/src/index.md#L25-L31)
```julia
# Lazy Library Loading

```@docs
Libdl.LazyLibrary
Libdl.LazyLibraryPath
Libdl.BundledLazyLibraryPath
Libdl.add_dependency!
```
```

</details>

#### 4. Clarified inference commentary for foreigncall evaluation without altering runtime behavior.

**Component**: Compiler.AbstractInterpretation

<details>
<summary>Evidence</summary>

**Compiler/src/abstractinterpretation.jl:3483-3497**
[View on GitHub](https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/Compiler/src/abstractinterpretation.jl#L3483-L3497)
```julia
function abstract_eval_foreigncall(interp::AbstractInterpreter, e::Expr, sstate::StatementState, sv::AbsIntState)
    callee = e.args[1]
    if isexpr(callee, :tuple)
        if length(callee.args) >= 1
            # Evaluate the arguments to constrain the world, effects, and other info for codegen,
            # but note there is an implied `if !=(C_NULL)` branch here that might read data
            # in a different world (the exact cache behavior is unspecified), so we do not use
            # these results to refine reachability of the subsequent foreigncall.
            abstract_eval_value(interp, callee.args[1], sstate, sv)
            if length(callee.args) >= 2
                abstract_eval_value(interp, callee.args[2], sstate, sv)
                #TODO: implement abstract_eval_nonlinearized_foreigncall_name correctly?
                # lib_effects = abstract_call(interp, ArgInfo(e.args, Any[typeof(Libdl.dlopen), lib]), sstate, sv)::Future
            end
        end
    else
        abstract_eval_value(interp, callee, sstate, sv)
    end
```

</details>

#### 5. Existing stdlib test continues to validate LazyLibrary dependency lists for JLLs (no new tests added in this PR).

**Component**: Tests

<details>
<summary>Evidence</summary>

**test/stdlib_dependencies.jl:203-249**
[View on GitHub](https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/test/stdlib_dependencies.jl#L203-L249)
```julia
@testset "Stdlib JLL dependency check" begin
    for (_, (stdlib_name, _)) in Pkg.Types.stdlibs()
        if !endswith(stdlib_name, "_jll")
            continue
        end

        # Import the stdlib, skip it if it's not available on this platform
        m = eval(Meta.parse("import $(stdlib_name); $(stdlib_name)"))
        if !Base.invokelatest(getproperty(m, :is_available))
            continue
        end

        for prop_name in names(m)
            prop = getproperty(m, prop_name)
            if isa(prop, Libdl.LazyLibrary)
                lib_path = dlpath(prop)
                lazy_lib_deps = strip_soversion.(basename.(dlpath.(prop.dependencies())))
                real_lib_deps = filter(!is_system_lib, get_deps_objectfile(lib_path))

                # See if there are missing dependencies in the lazy library deps
                missing_deps = setdiff(real_lib_deps, lazy_lib_deps)
                extraneous_deps = setdiff(lazy_lib_deps, real_lib_deps)

                # We expect there to be no missing or extraneous deps
                deps_mismatch = !isempty(missing_deps) || !isempty(extraneous_deps)
```

</details>

### Secondary Effects

#### Downstream packages can treat `add_dependency!` as a documented public API for dynamic dependency wiring (e.g., libblastrampoline_jll).

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
Libdl module marks add_dependency! as public  [stdlib/Libdl/src/Libdl.jl:10-19]
-> stdlib/libblastrampoline_jll delegates to Libdl.add_dependency! for dynamic BLAS dependencies  [stdlib/libblastrampoline_jll/src/libblastrampoline_jll.jl:28-31]
```
</details>

**Downstream Surfaces:**
- Libdl.add_dependency!
- libblastrampoline_jll LazyLibrary dependency wiring

### Compatibility

#### Internal API Changes
- **Libdl.add_dependency! (public API marker)**: Now declared public in Libdl module; downstream tooling can rely on it as part of Libdl's public surface.

#### Behavioral Changes
- InitialDependencies is now parameterized on element type and its callable returns copy(init.dependencies).

### Performance

**Compile Time:**
- {'item': 'ESTIMATED: no measurable change; documentation-only edits plus a simple vector copy in dependency initialization.', 'evidence': [{'source': 'code', 'path': 'base/libdl.jl', 'loc': '374-378', 'url': 'https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/base/libdl.jl#L374-L378', 'snippet': 'struct InitialDependencies{T}\n    dependencies::Vector{T}\nend\n(init::InitialDependencies)() = copy(init.dependencies)\n'}]}

**Runtime:**
- {'item': 'ESTIMATED: no runtime behavior change; LazyLibrary loading semantics are unchanged aside from clearer documentation.', 'evidence': [{'source': 'docs', 'path': 'doc/src/manual/calling-c-and-fortran-code.md', 'loc': '860-969', 'url': 'https://github.com/JuliaLang/julia/blob/298f8ad81dffebef3fd34f4153f33b366f2583f4/doc/src/manual/calling-c-and-fortran-code.md#L860-L969', 'snippet': '[`Libdl.LazyLibrary`](@ref) provides a thread-safe mechanism for deferring library loading\nuntil first use. This is the recommended approach for library initialization in modern Julia code.\n\nA `LazyLibrary` represents a library that opens itself (and its dependencies) automatically\non first use in a `ccall()`, `@ccall`, `dlopen()`, `dlsym()`, `dlpath()`, or `cglobal()`.\nThe library is loaded exactly once in a thread-safe manner, and subsequent calls reuse the\nloaded library handle.\n'}]}

### Risk Assessment

**Level**: low

**Rationale:**
- Core behavior is unchanged; the compiler edit is a comment-only clarification.
- The only codepath modification is a small dependency initializer refactor that preserves existing semantics for Vector{LazyLibrary} inputs.

### Recommendations

- Downstream packages should adopt the new LazyLibrary documentation section as the preferred guidance for lazy loading and dependency ordering.
