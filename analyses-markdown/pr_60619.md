# PR #60619: [JuliaLowering] Fix-up handling of `stmt_offset` in `K"enter"`

## Metadata

- **Author**: topolarity
- **URL**: https://github.com/JuliaLang/julia/pull/60619
- **Merged**: 2026-01-09 21:55 UTC
- **Labels**: `JuliaLowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60619.diff

## Scope

### Files Touched
- `JuliaLowering/src/eval.jl`
- `JuliaLowering/test/exceptions.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering
- CodeInfo

## Analysis

### Intent

Fix lowering of K"enter" so catch targets include the statement offset, restoring correct try/catch behavior in JuliaLowering (e.g., REPL).

**Related Issues:**
- https://github.com/JuliaLang/JuliaLowering.jl/issues/135

### Direct Changes

#### 1. When translating K"enter" nodes, add stmt_offset to the catch label so Core.EnterNode points at the correct statement index.

**Component**: JuliaLowering/src/eval.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/eval.jl:381-389**
[View on GitHub](https://github.com/JuliaLang/julia/blob/e61a047e1c108ff555ee93cea27f7c5c1781484a/JuliaLowering/src/eval.jl#L381-L389)
```julia
elseif k == K"goto"
    Core.GotoNode(ex[1].id + stmt_offset)
elseif k == K"gotoifnot"
    Core.GotoIfNot(_to_lowered_expr(ex[1], stmt_offset), ex[2].id + stmt_offset)
elseif k == K"enter"
    catch_idx = ex[1].id + stmt_offset
    numchildren(ex) == 1 ?
        Core.EnterNode(catch_idx) :
        Core.EnterNode(catch_idx, _to_lowered_expr(ex[2], stmt_offset))
```

**JuliaLowering/src/eval.jl:253-399**
[View on GitHub](https://github.com/JuliaLang/julia/blob/e61a047e1c108ff555ee93cea27f7c5c1781484a/JuliaLowering/src/eval.jl#L253-L399)
```julia
$ rg -n "stmt_offset" JuliaLowering/src/eval.jl
253:    stmt_offset = length(stmts)
255:        push!(stmts, _to_lowered_expr(stmt, stmt_offset))
330:function _to_lowered_expr(ex::SyntaxTree, stmt_offset::Int)
366:        Core.SSAValue(ex.var_id + stmt_offset)
368:        Core.ReturnNode(_to_lowered_expr(ex[1], stmt_offset))
382:        Core.GotoNode(ex[1].id + stmt_offset)
384:        Core.GotoIfNot(_to_lowered_expr(ex[1], stmt_offset), ex[2].id + stmt_offset)
386:        catch_idx = ex[1].id + stmt_offset
389:            Core.EnterNode(catch_idx, _to_lowered_expr(ex[2], stmt_offset))
391:        cs = map(e->_to_lowered_expr(e, stmt_offset), children(ex))
397:        Core.NewvarNode(_to_lowered_expr(ex[1], stmt_offset))
399:        args = map(e->_to_lowered_expr(e, stmt_offset), children(ex))
```

</details>

#### 2. Add a try/catch test with @nospecialize to validate correct exception handling under JuliaLowering include_string.

**Component**: JuliaLowering/test/exceptions.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/test/exceptions.jl:338-353**
[View on GitHub](https://github.com/JuliaLang/julia/blob/e61a047e1c108ff555ee93cea27f7c5c1781484a/JuliaLowering/test/exceptions.jl#L338-L353)
```julia
@test JuliaLowering.include_string(test_mod, """
begin
    function f_try_catch_nospecialize(@nospecialize(cond))
        try
            cond && throw(ArgumentError(""))
        catch
            return 1
        end
        return 2
    end
    (
        f_try_catch_nospecialize(true),
        f_try_catch_nospecialize(false),
    )
end
""") == (1,2)
```

</details>

### Secondary Effects

#### EnterNode catch targets now align with the shifted statement indices when extra statements (e.g., :meta :nospecialize) are inserted before user code, preventing mis-targeted catch blocks during CodeInfo execution.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
to_code_info(ex, slots, meta)  [eval.jl:220-257]
  computes stmt_offset = length(stmts)
  and pushes _to_lowered_expr(stmt, stmt_offset) for each lowered statement
-> _to_lowered_expr(ex, stmt_offset)  [eval.jl:330-389]
  translates K"enter" into Core.EnterNode(catch_idx)
  where catch_idx = ex[1].id + stmt_offset
```
</details>

**Downstream Surfaces:**
- Interpreter and runtime exception handling using Core.EnterNode
- JuliaLowering-based REPL evaluation paths

### Compatibility

#### Behavioral Changes
- Try/catch lowering for JuliaLowering include_string now yields correct catch control flow even when nospecialize metadata precedes statements.

### Performance

**Compile Time:**
- No measurable compile-time impact expected; change is a constant-time adjustment to catch index computation (ESTIMATED).

**Runtime:**
- No measurable runtime impact expected outside corrected exception target selection (ESTIMATED).

### Risk Assessment

**Level**: low

**Rationale:**
- Change is localized to K"enter" lowering and only adjusts an index by the existing stmt_offset used for other control-flow nodes.
- New test locks in corrected try/catch behavior with @nospecialize under JuliaLowering include_string.

### Recommendations

- Consider adding a targeted test that inspects the lowered CodeInfo EnterNode indices to catch future regressions in stmt_offset handling.
