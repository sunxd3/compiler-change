# PR #60259: Proactively compile lambdas when the type of the closure is known

## Metadata

- **Author**: xal-0
- **URL**: https://github.com/JuliaLang/julia/pull/60259
- **Merged**: 2025-12-09 19:17 UTC
- **Diff**: https://github.com/JuliaLang/julia/pull/60259.diff

## Scope

### Files Touched
- `Compiler/src/typeinfer.jl`

### Components
- Compiler.TypeInference

### Pipeline Stages
- TypeInference
- Precompile

## Analysis

### Intent

When precompiling methods, detect construction of Function-typed structs (closures) and enqueue their single compileable specialization so the closure method is compiled ahead of time.

### Direct Changes

#### 1. Extend collectinvokes! to recognize :new expressions that instantiate Function-typed structs, derive their concrete closure type via instanceof_tfunc, and enqueue a compileable specialization for invokelatest precompile work queues.

**Component**: Compiler/src/typeinfer.jl

<details>
<summary>Evidence</summary>

**Compiler/src/typeinfer.jl:1645-1660**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3efd5e7c9b31f02d70f39f16702823b769d7c4d1/Compiler/src/typeinfer.jl#L1645-L1660)
```julia
elseif isexpr(stmt, :new)
    # When creating a struct of Function type, check to see if we should
    # proactively compile the lambda
    t, _, _, _ = instanceof_tfunc(argextype(stmt.args[1], ci, sptypes))
    t <: Function || continue
    atype = Tuple{t, Vararg}
else
    # TODO: handle other StmtInfo like OpaqueClosure?
    continue
end
let workqueue = invokelatest_queue
    # make a best-effort attempt to enqueue the relevant code for the dynamic invokelatest call
    mi = compileable_specialization_for_call(workqueue.interp, atype)
    mi === nothing && continue

    push!(workqueue, mi)
end
```

</details>

### Secondary Effects

#### Closure methods created via struct construction during precompile may now be eagerly compiled when the closure type is concrete, reducing later runtime compilation for those closures.

**Likelihood**: medium | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
compile!(codeinfos, workqueue; invokelatest_queue)  [typeinfer.jl:1722-1793]
  -> collectinvokes!(workqueue, src, sptypes; invokelatest_queue)  [typeinfer.jl:1778-1781]
    -> isexpr(stmt, :new) branch derives closure type with instanceof_tfunc  [typeinfer.jl:1645-1649]
    -> compileable_specialization_for_call(...) resolves single compileable MethodInstance  [typeinfer.jl:1557-1579]
    -> push!(invokelatest_queue, mi) enqueues closure method for compilation  [typeinfer.jl:1655-1660]
```
</details>

**Downstream Surfaces:**
- Precompile scripts and cache generation (e.g., REPL precompile)
- Task/Channel closures built during module precompilation

### Compatibility

#### Behavioral Changes
- Precompile may now emit extra CodeInstances for closure methods when the closure type is concrete and compileable, which can reduce first-call latency for those closures.

### Performance

**Compile Time:**
- ESTIMATED: Additional compileable_specialization_for_call lookup for each :new of Function-typed struct in precompile/invokelatest queue, adding minor inference-time work when such closures are constructed.

**Runtime:**
- ESTIMATED: Reduced first-call latency for closure invocations whose types are known at precompile time, since their MethodInstances can be compiled during precompile.

### Risk Assessment

**Level**: low

**Rationale:**
- Change is limited to enqueueing additional compileable MethodInstances during precompile/invokelatest handling; no changes to runtime dispatch semantics.
- Guarded by instanceof_tfunc and compileable_specialization_for_call returning a single compileable specialization.

### Recommendations

- Consider adding a targeted precompile test that asserts closure methods created during precompile (such as Channel/Task lambdas) appear in the precompile trace or code cache, to lock in this behavior.
