# PR #60174: [JuliaLowering] Fix-up `__module__` in macro expansion

## Metadata

- **Author**: topolarity
- **URL**: https://github.com/JuliaLang/julia/pull/60174
- **Merged**: 2025-11-19 21:05 UTC
- **Labels**: `compiler:lowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60174.diff

## Scope

### Files Touched
- `JuliaLowering/src/macro_expansion.jl`
- `JuliaLowering/test/macros.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering

## Analysis

### Intent

Ensure old-style macro expansion passes the lexical module as `__module__`, fixing cases like `@static` that eval into `__module__`.

**Related Issues:**
- https://github.com/c42f/JuliaLowering.jl/issues/120

### Direct Changes

#### 1. Old-style macro invocation now passes the root lexical scope module (layer 1) as the `__module__` argument instead of the current hygienic scope module.

**Component**: JuliaLowering/src/macro_expansion.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/macro_expansion.jl:300-317**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6baf8f78eafdca137f1e39b128f540fd88f8a06e/JuliaLowering/src/macro_expansion.jl#L300-L317)
```julia
else
    # Compat: attempt to invoke an old-style macro if there's no applicable
    # method for new-style macro arguments.
    macro_args = Any[macro_loc, ctx.scope_layers[1].mod]
    for arg in raw_args
        # For hygiene in old-style macros, we omit any additional scope
        # layer information from macro arguments. Old-style macros will
        # handle that using manual escaping in the macro itself.
        push!(macro_args, Expr(arg))
    end
    expanded = try
        Base.invoke_in_world(ctx.macro_world, macfunc, macro_args...)
```

</details>

#### 2. Added regression test ensuring `@__MODULE__` expands to the lexical module rather than the current hygienic scope module.

**Component**: JuliaLowering/test/macros.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/test/macros.jl:505-517**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6baf8f78eafdca137f1e39b128f540fd88f8a06e/JuliaLowering/test/macros.jl#L505-L517)
```julia
# JuliaLang/JuliaLowering.jl#120
#
# `__module__` should be expanded as the lexical module containing the expanded
# code, not the module corresponding to the current hygienic scope
JuliaLowering.include_string(test_mod, raw"""
module Mod1
macro indirect_MODULE()
    return :(@__MODULE__())
end
end
""")
code = JuliaLowering.include_string(test_mod, """Mod1.@indirect_MODULE()""")
@test JuliaLowering.eval(test_mod, code) === test_mod # !== test_mod.Mod1
```

</details>

### Secondary Effects

#### Macros implemented in old style that call `eval` or rely on `__module__` now see the lexical caller module rather than the current hygienic scope module.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
expand_macro(ctx, ex)  [macro_expansion.jl:300-329]
  -> macro_args = Any[macro_loc, ctx.scope_layers[1].mod]
  -> Base.invoke_in_world(ctx.macro_world, macfunc, macro_args...)
  -> old-style macro receives (__source__, __module__, ...) from macro_args
```
</details>

**Downstream Surfaces:**
- Old-style macros using `__module__` for `eval` or module-relative lookups
- Packages depending on JuliaLowering old-style macro compat behavior (e.g. macro hygiene tooling)

### Compatibility

#### Behavioral Changes
- `__module__` passed to old-style macros is now the lexical module (scope layer 1), not the current hygienic scope module.

### Performance

### Risk Assessment

**Level**: low

**Rationale:**
- Change is localized to old-style macro argument construction and backed by a regression test.

### Recommendations

- If downstream tools relied on hygienic-scope `__module__` for old-style macros, update expectations to match lexical module semantics.
