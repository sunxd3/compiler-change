# PR #60255: [JuliaLowering] Restrict `K"VERSION"` to module arg

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60255
- **Merged**: 2025-12-01 21:03 UTC
- **Labels**: `compiler:lowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60255.diff

## Scope

### Files Touched
- `JuliaLowering/src/compat.jl`
- `JuliaLowering/src/macro_expansion.jl`
- `JuliaLowering/test/macros.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering
- MacroExpansion

## Analysis

### Intent

Limit special `K"VERSION"` handling to module version syntax so standalone `VersionNumber` literals (e.g. v"1.14") are not treated as special syntax during lowering, fixing stdlib precompilation regressions after #60018.

**Related Issues:**
- https://github.com/JuliaLang/julia/pull/60018

### Direct Changes

#### 1. Module expressions now wrap the version argument in a dedicated `:mod_version` Expr, ensuring only module version positions become `K"VERSION"` nodes.

**Component**: JuliaLowering/src/compat.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/compat.jl:400-408**
[View on GitHub](https://github.com/JuliaLang/julia/blob/68553c5863b81a27335aff82898405dd86392c8b/JuliaLowering/src/compat.jl#L400-L408)
```julia
elseif e.head === :module
    @assert nargs in (3, 4)
    has_version = !isa(e.args[1], Bool)
    if !e.args[1+has_version]
        st_flags |= JS.BARE_MODULE_FLAG
    end
    child_exprs = has_version ?
        Any[Expr(:mod_version, e.args[1]), e.args[2+has_version], e.args[3+has_version]] :
        Any[e.args[2+has_version], e.args[3+has_version]]
```

**JuliaLowering/src/compat.jl:565-571**
[View on GitHub](https://github.com/JuliaLang/julia/blob/68553c5863b81a27335aff82898405dd86392c8b/JuliaLowering/src/compat.jl#L565-L571)
```julia
elseif e.head === :mod_version
    v = e.args[1]
    @assert v isa VersionNumber
    st_k = K"VERSION"
    st_flags = JS.set_numeric_flags(v.minor*10)
    st_attrs[:value] = v
    child_exprs = nothing
```

</details>

#### 2. Old-style macro invocation now treats a leading `K"VERSION"` argument as a macro source payload and avoids pushing `K"VERSION"` into `macro_args`.

**Component**: JuliaLowering/src/macro_expansion.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/macro_expansion.jl:325-360**
[View on GitHub](https://github.com/JuliaLang/julia/blob/68553c5863b81a27335aff82898405dd86392c8b/JuliaLowering/src/macro_expansion.jl#L325-L360)
```julia
# Compat: attempt to invoke an old-style macro if there's no applicable
# method for new-style macro arguments.
macro_args = Any[macro_loc, ctx.scope_layers[1].mod]

if length(raw_args) >= 1 && kind(raw_args[1]) === K"VERSION"
    # Hack: see jl_invoke_julia_macro.  We may see an extra argument
    # depending on who parsed this macrocall.
    macro_args[1] = Core.MacroSource(macro_loc, raw_args[1].value)
end

for arg in raw_args
    # For hygiene in old-style macros, we omit any additional scope
    # layer information from macro arguments. Old-style macros will
    # handle that using manual escaping in the macro itself.
    #
    # Note that there's one slight incompatibility here for identifiers
    # interpolated into the `raw_args` from outer macro expansions of
    # new-style macros which call old-style macros. Instead of seeing
    # `Expr(:escape)` in such situations, old-style macros will now see
    # `Expr(:scope_layer)` inside `macro_args`.
    kind(arg) !== K"VERSION" && push!(macro_args, Expr(arg))
end
```

</details>

### Secondary Effects

#### Standalone `VersionNumber` literals produced by `v""` no longer become `K\"VERSION\"` nodes during compat conversion, avoiding unhandled syntax outside module headers.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
_insert_convert_expr(e, graph, src) [compat.jl:186]
  sees Expr(:module, ...) and wraps version as Expr(:mod_version, v) [compat.jl:400-408]
  -> :mod_version branch converts to K"VERSION" only for module header [compat.jl:565-571]
All other VersionNumber literals fall through the non-Expr handling path and are treated as regular values.
```
</details>

**Downstream Surfaces:**
- Macro expansion compatibility mode (old-style macros)
- Stdlib precompilation when parsing v"x.y" literals

#### Old-style macros see one fewer argument when a K"VERSION" token is present in raw args, aligning with jl_invoke_julia_macro behavior.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
expand_macro(ctx, ex) [macro_expansion.jl:281]
  builds macro_args = Any[macro_loc, ctx.scope_layers[1].mod]
  -> replaces macro_loc with Core.MacroSource when raw_args[1] is K"VERSION" [macro_expansion.jl:329-333]
  -> skips pushing K"VERSION" into macro_args [macro_expansion.jl:335-345]
```
</details>

**Downstream Surfaces:**
- Old-style macros that consume MacroSource arguments

### Compatibility

#### Internal API Changes
- **SyntaxTree kind K"VERSION"**: K"VERSION" nodes are now produced only via Expr(:mod_version) in module headers; standalone VersionNumber literals are treated as values.

#### Behavioral Changes
- `v"x.y"` literals in compat-mode parsing now yield VersionNumber values without triggering K"VERSION" syntax errors.

### Performance

**Compile Time:**
- ESTIMATED: negligible. Adds a small Expr(:mod_version, v) wrapper during compat conversion and a conditional in old-style macro argument handling.

**Runtime:**
- No runtime impact; changes are limited to lowering and macro expansion paths.

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are localized to JuliaLowering compat conversion and macro expansion; tests cover VersionNumber and @VERSION cases.
- No changes to CodeInfo/SSA or optimizer pipelines.

### Recommendations

- Downstream macro tooling that inspects raw macro arguments should ignore or special-case K"VERSION" similarly to JuliaLowering to avoid extra-argument mismatches.
