# PR #60276: Backports for 1.13.0-alpha2

## Metadata

- **Author**: KristofferC
- **URL**: https://github.com/JuliaLang/julia/pull/60276
- **Merged**: 2025-11-30 08:28 UTC
- **Diff**: https://github.com/JuliaLang/julia/pull/60276.diff

## Scope

### Files Touched
- `Compiler/extras/CompilerDevTools/test/testpkg.jl`
- `JuliaLowering/Manifest.toml`
- `base/loading.jl`
- `contrib/generate_precompile.jl`
- `deps/checksums/Pkg-4f9884fdb867f2c928ba43dc41da5f150aaec4ab.tar.gz/md5`
- `deps/checksums/Pkg-4f9884fdb867f2c928ba43dc41da5f150aaec4ab.tar.gz/sha512`
- `deps/checksums/Pkg-d0be1daf22f15da346e83429b323a82554ef241c.tar.gz/md5`
- `deps/checksums/Pkg-d0be1daf22f15da346e83429b323a82554ef241c.tar.gz/sha512`
- `deps/jlutilities/documenter/Manifest.toml`
- `deps/jlutilities/objectfile/Manifest.toml`
- `deps/jlutilities/objectfile/Project.toml`
- `doc/make.jl`
- `doc/src/index.md`
- `src/llvm-multiversioning.cpp`
- `stdlib/Pkg.version`
- `test/llvmpasses/multiversioning-clone-only.ll`
- `test/llvmpasses/multiversioning-x86.ll`
- `test/loading.jl`
- `test/project/deps/BadStdlibDeps2/Manifest.toml`
- `test/project/deps/BadStdlibDeps2/Project.toml`
- `test/runtests.jl`
- `test/stdlib_dependencies.jl`

### Components
- Compiler.Codegen
- Base.Loading
- Tests

### Pipeline Stages
- Codegen
- RuntimeLoading

## Analysis

### Intent

Backport a set of fixes and dependency updates for the 1.13.0-alpha2 release, including LLVM multiversioning trampoline initialization and stdlib loading fallback behavior.

### Direct Changes

#### 1. Introduce a reusable LLVM multiversioning trampoline helper and use it to initialize relocation slots with an autoinit trampoline for multiversioned entrypoints.

**Component**: Compiler.Codegen

<details>
<summary>Evidence</summary>

**src/llvm-multiversioning.cpp:498-542**
[View on GitHub](https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/src/llvm-multiversioning.cpp#L498-L542)
```julia
Function *CloneCtx::create_trampoline(Function *F, GlobalVariable *slot, bool autoinit)
{
    Function *trampoline =
        Function::Create(F->getFunctionType(), GlobalValue::ExternalLinkage, "", &M);

    trampoline->copyAttributesFrom(F);
    trampoline->setVisibility(GlobalValue::HiddenVisibility);
    trampoline->setDSOLocal(true);

    // drop multiversioning attributes
    trampoline->removeFnAttr("julia.mv.reloc");
    trampoline->removeFnAttr("julia.mv.clones");

    auto BB = BasicBlock::Create(F->getContext(), "top", trampoline);
    IRBuilder<> irbuilder(BB);

    if (autoinit) {
        irbuilder.CreateCall(F->getParent()->getOrInsertFunction(
            XSTR(jl_autoinit_and_adopt_thread),
            PointerType::get(F->getContext(), 0)
        ));
    }

    auto ptr = irbuilder.CreateLoad(F->getType(), slot);
    ptr->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);
    ptr->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(F->getContext(), None));

    SmallVector<Value *, 0> Args;
    for (auto &arg : trampoline->args())
        Args.push_back(&arg);
    auto call = irbuilder.CreateCall(F->getFunctionType(), ptr, ArrayRef<Value *>(Args));
    if (F->isVarArg()) {
        assert(!TT.isARM() && !TT.isPPC() && "musttail not supported on ARM/PPC!");
        call->setTailCallKind(CallInst::TCK_MustTail);
    } else {
        call->setTailCallKind(CallInst::TCK_Tail);

    }

    if (F->getReturnType() == Type::getVoidTy(F->getContext()))
        irbuilder.CreateRetVoid();
    else
        irbuilder.CreateRet(call);

    return trampoline;
}
```

**src/llvm-multiversioning.cpp:545-565**
[View on GitHub](https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/src/llvm-multiversioning.cpp#L545-L565)
```julia
void CloneCtx::prepare_slots()
{
    for (auto &F : orig_funcs) {
        if (F->hasFnAttribute("julia.mv.reloc")) {
            assert(F->hasFnAttribute("julia.mv.clones"));
            GlobalVariable *GV = new GlobalVariable(M, F->getType(), false, GlobalValue::ExternalLinkage, nullptr, F->getName() + ".reloc_slot");
            GV->setVisibility(GlobalValue::HiddenVisibility);
            GV->setDSOLocal(true);
            if (F->isDeclaration()) {
                extern_relocs[F] = GV;
            }
            else {
                auto id = get_func_id(F);
                const_relocs[id] = GV;

                // Initialize with a single-use trampoline that calls `jl_autoinit_and_adopt_thread`,
                // so that auto-initialization works with multi-versioned entrypoints.
                Function *trampoline = create_trampoline(F, GV, /* autoinit */ true);
                trampoline->setName(F->getName() + ".autoinit_trampoline");
                GV->setInitializer(trampoline);
            }
        }
    }
}
```

**src/llvm-multiversioning.cpp:498,562,727**
[View on GitHub](https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/src/llvm-multiversioning.cpp#L498-L727)
```julia
498:Function *CloneCtx::create_trampoline(Function *F, GlobalVariable *slot, bool autoinit)
562:                Function *trampoline = create_trampoline(F, GV, /* autoinit */ true);
727:    Function *trampoline = create_trampoline(F, slot, /* autoinit */ false);
```

</details>

#### 2. Rewrite multiversioning aliases through the new trampoline helper to keep alias metadata and slot usage consistent.

**Component**: Compiler.Codegen

<details>
<summary>Evidence</summary>

**src/llvm-multiversioning.cpp:717-736**
[View on GitHub](https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/src/llvm-multiversioning.cpp#L717-L736)
```julia
void CloneCtx::rewrite_alias(GlobalAlias *alias, Function *F)
{
    assert(!is_vector(F->getFunctionType()));

    uint32_t id;
    GlobalVariable *slot;
    std::tie(id, slot) = get_reloc_slot(F);
    assert(slot);

    Function *trampoline = create_trampoline(F, slot, /* autoinit */ false);
    trampoline->addFnAttr("julia.mv.alias"); // add alias attribute for testing purposes

    trampoline->takeName(alias);
    trampoline->setLinkage(alias->getLinkage());
    trampoline->setVisibility(alias->getVisibility());
    trampoline->setDSOLocal(alias->isDSOLocal());
    trampoline->setDLLStorageClass(alias->getDLLStorageClass());

    alias->eraseFromParent();
}
```

**test/llvmpasses/multiversioning-clone-only.ll:76-83**
[View on GitHub](https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/test/llvmpasses/multiversioning-clone-only.ll#L76-L83)
```julia
; COM: check that the autoinit trampoline is generated correctly
; CHECK: define{{.*}}@subtarget_cloned.autoinit_trampoline({{.*}}
; CHECK-NEXT: top:
; CHECK-NEXT: call ptr @ijl_autoinit_and_adopt_thread()
; CHECK-NEXT: [[FUNC_PTR:%[0-9]+]] = load ptr, ptr @subtarget_cloned.reloc_slot{{.*}}!tbaa ![[TBAA_CONST_METADATA]], !invariant.load
; CHECK-NEXT: call{{.*}}[[FUNC_PTR]]({{.*}})
; CHECK: ret i32
```

</details>

#### 3. When locating packages, fall back to stdlib manifests even if a project manifest returned a sentinel missing entry.

**Component**: Base.Loading

<details>
<summary>Evidence</summary>

**base/loading.jl:468-494**
[View on GitHub](https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/base/loading.jl#L468-L494)
```julia
for env in load_path()
    path = manifest_uuid_path(env, pkg)
    # missing is used as a sentinel to stop looking further down in envs
    if path === missing
        # Before stopping, try stdlib fallback
        is_stdlib(pkg) && @goto stdlib_fallback
        path = nothing
        @goto done
    end
    if path !== nothing
        env′ = env
        @goto done
    end
    if !(loading_extension || precompiling_extension)
        stopenv == env && break
    end
end
@label stdlib_fallback
# Allow loading of stdlibs if the name/uuid are given
# e.g. if they have been explicitly added to the project/manifest
mbypath = manifest_uuid_path(Sys.STDLIB, pkg)
if mbypath isa String
    path = mbypath
    env′ = Sys.STDLIB
    @goto done
end
```

**test/loading.jl:1535-1563**
[View on GitHub](https://github.com/JuliaLang/julia/blob/af3e3bb21e4cae85fb4694451c725adf54748cc1/test/loading.jl#L1535-L1563)
```julia
@testset "Fallback for stdlib deps if manifest deps aren't found" begin
    s = Sys.iswindows() ? ';' : ':'
    mktempdir() do depot
        # This manifest has a LibGit2 entry that is missing LibGit2_jll, which should be
        # handled by falling back to the stdlib Project.toml for dependency truth.
        badmanifest_test_dir = joinpath(@__DIR__, "project", "deps", "BadStdlibDeps")
        @test success(addenv(
            `$(Base.julia_cmd()) --project=$badmanifest_test_dir --startup-file=no -e 'using LibGit2'`,
            "JULIA_DEPOT_PATH" => string(depot * Base.Filesystem.pathsep(), s),
        ))
    end
    mktempdir() do depot
        # This manifest has a LibGit2 entry that has a LibGit2_jll with a git-tree-hash1
        # which simulates an old manifest where LibGit2_jll was not a stdlib
        badmanifest_test_dir2 = joinpath(@__DIR__, "project", "deps", "BadStdlibDeps2")
        @test success(addenv(
            `$(Base.julia_cmd()) --project=$badmanifest_test_dir2 --startup-file=no -e 'using LibGit2'`,
            "JULIA_DEPOT_PATH" => string(depot * Base.Filesystem.pathsep(), s),
        ))
    end
    mktempdir() do depot
        # This manifest has a LibGit2 entry that has a LibGit2_jll with a git-tree-hash1
        # which simulates an old manifest where LibGit2_jll was not a stdlib
        badmanifest_test_dir2 = joinpath(@__DIR__, "project", "deps", "BadStdlibDeps2")
        @test success(addenv(
            `$(Base.julia_cmd()) --project=$badmanifest_test_dir2 --startup-file=no -e 'using LibGit2'`,
            "JULIA_DEPOT_PATH" => depot * Base.Filesystem.pathsep(),
        ))
    end
end
```

</details>

### Secondary Effects

#### Multiversioned relocation slots now initially point to a trampoline that performs thread auto-initialization before tail-calling the resolved target.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
CloneCtx::prepare_slots() creates relocation slots and calls create_trampoline(..., autoinit=true) to initialize each slot. [src/llvm-multiversioning.cpp:545-565]
  -> create_trampoline(...) emits a call to jl_autoinit_and_adopt_thread() before loading the slot target and tail-calling it. [src/llvm-multiversioning.cpp:498-542]
```
</details>

**Downstream Surfaces:**
- LLVM IR produced by the JuliaMultiVersioning pass
- System image/runtime init for multiversioned entrypoints

#### Packages with older or incomplete manifests can still resolve stdlib dependencies (including JLL stdlibs) even when manifest lookup stops early.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
locate_package_env() now jumps to stdlib_fallback when manifest_uuid_path() returns missing and the target is a stdlib, then retries against Sys.STDLIB. [base/loading.jl:468-494]
```
</details>

**Downstream Surfaces:**
- Pkg/manifest-based loading of stdlib deps
- Legacy environments with LibGit2_jll entries

### Compatibility

#### Behavioral Changes
- Package loading falls back to stdlib manifests for stdlib deps even after a missing sentinel, which may resolve packages that previously failed with missing deps.

### Performance

**Compile Time:**
- {'summary': 'ESTIMATED: negligible additional IR in the multiversioning pass from emitting a small trampoline per multiversioned entrypoint.'}

**Runtime:**
- {'summary': 'ESTIMATED: one extra call to jl_autoinit_and_adopt_thread in the first execution of a multiversioned entrypoint via its reloc slot; subsequent calls still go through the reloc slot load and tail-call.'}

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are localized to codegen initialization paths and stdlib loading fallback, with tests covering both behaviors.

### Recommendations

- Downstream tooling that inspects LLVM IR for multiversioning should accept the new autoinit trampoline symbol name and the non-null reloc slot initializer.
- Package environment diagnostics should note that stdlib fallback may succeed even when manifest entries are incomplete.
