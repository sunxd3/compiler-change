# PR #60191: [JuliaLowering] Tidy up node creation functions

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60191
- **Merged**: 2025-12-03 21:45 UTC
- **Labels**: `compiler:lowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60191.diff

## Scope

### Files Touched
- `JuliaLowering/src/ast.jl`
- `JuliaLowering/src/bindings.jl`
- `JuliaLowering/src/closure_conversion.jl`
- `JuliaLowering/src/compat.jl`
- `JuliaLowering/src/linear_ir.jl`
- `JuliaLowering/src/macro_expansion.jl`
- `JuliaLowering/src/runtime.jl`
- `JuliaLowering/src/syntax_graph.jl`
- `JuliaLowering/src/syntax_macros.jl`
- `JuliaLowering/test/compat.jl`
- `JuliaLowering/test/scopes.jl`
- `JuliaLowering/test/utils.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Parsing
- Lowering
- MacroExpansion
- LinearIR

## Analysis

### Intent

Replace keyword-argument attribute passing in JuliaLowering AST/node construction with explicit Vector{Pair} attribute lists and explicit setattr! calls, reducing JuliaLowering image size while keeping lowering behavior unchanged.


### Direct Changes

#### 1. Node creation APIs now build leaves/nodes first, then attach attributes via explicit Pair lists and setattr!; a new newleaf helper handles value/name/var_id/id storage.

**Component**: JuliaLowering AST construction

<details>
<summary>Evidence</summary>

**JuliaLowering/src/ast.jl:133-187**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6c75e91cf4fc8bc7972131a778482e3e8279e9c6/JuliaLowering/src/ast.jl#L133-L187)
```julia
function makeleaf(graph::SyntaxGraph, srcref, proto::Union{Kind, SyntaxTree})
    id = newnode!(graph)
    ex = SyntaxTree(graph, id)
    copy_attrs!(ex, proto, true)
    ex.source = _unpack_srcref(graph, srcref)
    return ex
end

function makeleaf(ctx, srcref, proto, @nospecialize(attrs::AbstractVector))
    graph = syntax_graph(ctx)
    ex = makeleaf(graph, srcref, proto)
    for (k, v) in attrs
        setattr!(graph, ex._id, k, v)
    end
    return ex
end

function newleaf(ctx, srcref, k::Kind, @nospecialize(value))
    leaf = makeleaf(ctx, srcref, k)
    if k == K"Identifier" || k == K"core" || k == K"top" || k == K"Symbol" ||
            k == K"globalref" || k == K"Placeholder" ||
            k == K"StrMacroName" || k == K"CmdMacroName"
        setattr!(leaf._graph, leaf._id, :name_val, value)
    elseif k == K"BindingId"
        setattr!(leaf._graph, leaf._id, :var_id, value)
    elseif k == K"label"
        setattr!(leaf._graph, leaf._id, :id, value)
    elseif k == K"symbolic_label"
        setattr!(leaf._graph, leaf._id, :name_val, value)
    elseif k in KSet"TOMBSTONE SourceLocation latestworld latestworld_if_toplevel"
        # no attributes
    else
        val = k == K"Integer" ? convert(Int,     value) :
              k == K"Float"   ? convert(Float64, value) :
              k == K"String"  ? convert(String,  value) :
              k == K"Char"    ? convert(Char,    value) :
              k == K"Value"   ? value                   :
              k == K"Bool"    ? value                   :
              k == K"VERSION" ? value                   :
              error("Unexpected leaf kind `$k`")
        setattr!(leaf._graph, leaf._id, :value, val)
    end
    leaf
end
```

**JuliaLowering/src/ast.jl:234-317**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6c75e91cf4fc8bc7972131a778482e3e8279e9c6/JuliaLowering/src/ast.jl#L234-L317)
```julia
function _kw_to_pair(ex)
    if ex isa Expr && ex.head === :kw && ex.args[1] isa Symbol
        (QuoteNode(ex.args[1]), esc(ex.args[2]))
    elseif ex isa Symbol
        (QuoteNode(ex), esc(ex))
    else
        @assert false "invalid keyword form in @ast $ex"
    end
end

function _match_kind(srcref, ex)
    kws = []
    if Meta.isexpr(ex, :call)
        kind = esc(ex.args[1])
        args = ex.args[2:end]
        if Meta.isexpr(args[1], :parameters)
            kws = map(_kw_to_pair, args[1].args)
            popfirst!(args)
        end
        while length(args) >= 1 && Meta.isexpr(args[end], :kw)
            pushfirst!(kws, _kw_to_pair(pop!(args)))
        end
        if length(args) == 1
            srcref_tmp = gensym("srcref")
            return (kind, _match_srcref(args[1]), kws)
        elseif length(args) > 1
            error("Unexpected: extra srcref argument in `$ex`?")
        end
    else
        kind = esc(ex)
    end
    return (kind, srcref, kws)
end

function _expand_ast_tree(ctx, srcref, tree)
    if Meta.isexpr(tree, :(::))
        # Leaf node
        if length(tree.args) == 2
            val = esc(tree.args[1])
            kindspec = tree.args[2]
        else
            val = nothing
            kindspec = tree.args[1]
        end
        let (kind, srcref, kws) = _match_kind(srcref, kindspec)
            n = :(newleaf($ctx, $srcref, $kind, $val))
            for (attr, val) in kws
                n = :(setattr!($n, $attr, $val))
            end
            n
        end
    elseif Meta.isexpr(tree, (:vcat, :hcat, :vect))
        # Interior node
        flatargs = []
        for a in tree.args
            if Meta.isexpr(a, :row)
                append!(flatargs, a.args)
            else
                push!(flatargs, a)
            end
        end
        children_ex = :(let child_ids = Vector{NodeId}(), graph = syntax_graph($ctx)
        end)
        child_stmts = children_ex.args[2].args
        for a in flatargs[2:end]
            child = _expand_ast_tree(ctx, srcref, a)
            if Meta.isexpr(child, :(...))
                push!(child_stmts, :(_append_nodeids!(graph, child_ids, $(child.args[1]))))
            else
                push!(child_stmts, :(_push_nodeid!(graph, child_ids, $child)))
            end
        end
        push!(child_stmts, :(child_ids))
        let (kind, srcref, kws) = _match_kind(srcref, flatargs[1])
            n = :(makenode($ctx, $srcref, $kind, $children_ex))
            for (attr, val) in kws
                n = :(setattr!($n, $attr, $val))
            end
            n
        end
    elseif Meta.isexpr(tree, :(:=))
        lhs = tree.args[1]
        rhs = _expand_ast_tree(ctx, srcref, tree.args[2])
        ssadef = gensym("ssadef")
        quote
            ($(esc(lhs)), $ssadef) = assign_tmp($ctx, $rhs, $(string(lhs)))
            $ssadef
        end
    elseif Meta.isexpr(tree, :macrocall)
        esc(tree)
    elseif tree isa Expr
        Expr(tree.head, map(a->_expand_ast_tree(ctx, srcref, a), tree.args)...)
    else
        esc(tree)
    end
end
```

</details>

#### 2. SyntaxGraph attribute and child-setting helpers are now explicit (symbol/value) setters and vector-based children lists, with new SyntaxList helpers to pass children and SyntaxTree property setters using setattr!.

**Component**: JuliaLowering SyntaxGraph

<details>
<summary>Evidence</summary>

**JuliaLowering/src/syntax_graph.jl:107-214**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6c75e91cf4fc8bc7972131a778482e3e8279e9c6/JuliaLowering/src/syntax_graph.jl#L107-L214)
```julia
function setchildren!(graph::SyntaxGraph, id::NodeId,
                      children::AbstractVector{NodeId})
    n = length(graph.edges)
    graph.edge_ranges[id] = n+1:(n+length(children))
    # TODO: Reuse existing edges if possible
    append!(graph.edges, children)
end

function setattr!(graph::SyntaxGraph, id::NodeId, k::Symbol, @nospecialize(v))
    if !isnothing(v)
        getattr(graph, k)[id] = v
    end
    id
end

function Base.setproperty!(ex::SyntaxTree, name::Symbol, @nospecialize(val))
    setattr!(ex._graph, ex._id, name, val)
    val
end
```

**JuliaLowering/src/syntax_graph.jl:680-699**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6c75e91cf4fc8bc7972131a778482e3e8279e9c6/JuliaLowering/src/syntax_graph.jl#L680-L699)
```julia
mutable struct SyntaxList{GraphType, NodeIdVecType} <: AbstractVector{SyntaxTree}
    graph::GraphType
    ids::NodeIdVecType
end

function SyntaxList(graph::SyntaxGraph, ids::AbstractVector{NodeId})
    SyntaxList{typeof(graph), typeof(ids)}(graph, ids)
end

SyntaxList(graph::SyntaxGraph) = SyntaxList(graph, Vector{NodeId}())
SyntaxList(ctx) = SyntaxList(syntax_graph(ctx))
SyntaxList(ctx, v::Vector{SyntaxTree}) =
    SyntaxList(syntax_graph(ctx), NodeId[x._id for x in v])

syntax_graph(lst::SyntaxList) = lst.graph

setchildren!(graph::SyntaxGraph, id::NodeId, children::SyntaxList) =
    setchildren!(graph, id, children.ids)
```

**JuliaLowering/src/syntax_graph.jl:838-858**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6c75e91cf4fc8bc7972131a778482e3e8279e9c6/JuliaLowering/src/syntax_graph.jl#L838-L858)
```julia
function _insert_green(graph::SyntaxGraph, sf::SourceFile,
                       txtbuf::Vector{UInt8}, offset::Int,
                       cursor::RedTreeCursor)
    id = newnode!(graph)
    setattr!(graph, id, :kind, kind(cursor))
    setattr!(graph, id, :syntax_flags, flags(cursor))
    setattr!(graph, id, :source, SourceRef(sf, first_byte(cursor), last_byte(cursor)))
    if !is_leaf(cursor)
        cs = NodeId[]
        for c in reverse(cursor)
            push!(cs, _insert_green(graph, sf, txtbuf, offset, c))
        end
        setchildren!(graph, id, reverse(cs))
    else
        v = parse_julia_literal(txtbuf, head(cursor), byte_range(cursor) .+ offset)
        if v isa Symbol
            # TODO: Fixes in JuliaSyntax to avoid ever converting to Symbol
            setattr!(graph, id, :name_val, string(v))
        elseif !isnothing(v)
            setattr!(graph, id, :value, v)
        end
    end
    return id
end
```

</details>

#### 3. Scope and macro hygiene transforms now apply attributes via explicit setattr! after mapping, instead of keyword-based extra_attrs in mapchildren/makeleaf.

**Component**: JuliaLowering MacroExpansion/AST hygiene

<details>
<summary>Evidence</summary>

**JuliaLowering/src/ast.jl:510-526**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6c75e91cf4fc8bc7972131a778482e3e8279e9c6/JuliaLowering/src/ast.jl#L510-L526)
```julia
function set_scope_layer(ctx, ex, layer_id, force)
    k = kind(ex)
    new_layer = force ? layer_id : get(ex, :scope_layer, layer_id)

    ex2 = if k == K"module" || k == K"toplevel" || k == K"inert"
        makenode(ctx, ex, ex, children(ex))
    elseif k == K"."
        children = NodeId[set_scope_layer(ctx, ex[1], layer_id, force), ex[2]]
        makenode(ctx, ex, ex, children)
    elseif !is_leaf(ex)
        mapchildren(e->set_scope_layer(ctx, e, layer_id, force), ctx, ex)
    else
        makeleaf(ctx, ex, ex)
    end
    setattr!(ex2, :scope_layer, new_layer)
end
```

**JuliaLowering/src/macro_expansion.jl:210-236**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6c75e91cf4fc8bc7972131a778482e3e8279e9c6/JuliaLowering/src/macro_expansion.jl#L210-L236)
```julia
function set_macro_arg_hygiene(ctx, ex, layer_ids, layer_idx)
    k = kind(ex)
    scope_layer = get(ex, :scope_layer, layer_ids[layer_idx])
    if is_leaf(ex)
        makeleaf(ctx, ex, ex, [:scope_layer=>scope_layer])
    else
        inner_layer_idx = layer_idx
        if k == K"escape"
            inner_layer_idx = layer_idx - 1
            if inner_layer_idx < 1
                throw(MacroExpansionError(ex, "`escape` node in outer context"))
            end
        end
        node = mapchildren(e->set_macro_arg_hygiene(
            ctx, e, layer_ids, inner_layer_idx), ctx, ex)
        setattr!(node, :scope_layer, scope_layer)
    end
end
```

</details>

#### 4. Metadata APIs now use explicit key/value parameters (setmeta/setmeta!), and @nospecialize uses the new signature.

**Component**: JuliaLowering meta attributes

<details>
<summary>Evidence</summary>

**JuliaLowering/src/ast.jl:560-570**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6c75e91cf4fc8bc7972131a778482e3e8279e9c6/JuliaLowering/src/ast.jl#L560-L570)
```julia
function setmeta!(ex::SyntaxTree, key::Symbol, @nospecialize(val))
    meta = begin
        m = get(ex, :meta, nothing)
        isnothing(m) ? CompileHints(key, val) : CompileHints(m, key, val)
    end
    setattr!(ex, :meta, meta)
    ex
end

setmeta(ex::SyntaxTree, k::Symbol, @nospecialize(v)) =
    setmeta!(copy_node(ex), k, v)
```

**JuliaLowering/src/syntax_macros.jl:18-31**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6c75e91cf4fc8bc7972131a778482e3e8279e9c6/JuliaLowering/src/syntax_macros.jl#L18-L31)
```julia
function _apply_nospecialize(ctx, ex)
    k = kind(ex)
    if k == K"Identifier" || k == K"Placeholder" || k == K"tuple"
        setmeta(ex, :nospecialize, true)
    elseif k == K"..." || k == K"::" || k == K"=" || k == K"kw"
        # The @nospecialize macro is responsible for converting K"=" to K"kw".
        # Desugaring uses this helper internally, so we may see K"kw" too.
        if k == K"::" && numchildren(ex) == 1
            ex = @ast ctx ex [K"::" "_"::K"Placeholder" ex[1]]
        elseif k == K"=" && numchildren(ex) === 2
            ex = @ast ctx ex [K"kw" ex[1] ex[2]]
        end
        mapchildren(c->_apply_nospecialize(ctx, c), ctx, ex, 1:1)
    else
        throw(LoweringError(ex, "Invalid function argument"))
    end
end
```

</details>

#### 5. Lowering call sites updated to the new attribute-setting style, including label creation, bindings, and interpolation leaves.

**Component**: JuliaLowering call sites

<details>
<summary>Evidence</summary>

**JuliaLowering/src/linear_ir.jl:347-350**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6c75e91cf4fc8bc7972131a778482e3e8279e9c6/JuliaLowering/src/linear_ir.jl#L347-L350)
```julia
function make_label(ctx, srcref)
    id = ctx.next_label_id[]
    ctx.next_label_id[] += 1
    makeleaf(ctx, srcref, K"label", [:id=>id])
end
```

**JuliaLowering/src/bindings.jl:152-175**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6c75e91cf4fc8bc7972131a778482e3e8279e9c6/JuliaLowering/src/bindings.jl#L152-L175)
```julia
function ssavar(ctx::AbstractLoweringContext, srcref, name="tmp")
    nameref = makeleaf(ctx, srcref, K"Identifier")
    nameref.name_val = name
    new_binding(ctx, nameref, name, :local; is_ssa=true, is_internal=true)
end

function new_local_binding(ctx::AbstractLoweringContext, srcref, name; kind=:local, kws...)
    @assert kind === :local || kind === :argument
    nameref = makeleaf(ctx, srcref, K"Identifier")
    nameref.name_val = name
    ex = new_binding(ctx, nameref, name, kind; is_internal=true, kws...)
    lbindings = current_lambda_bindings(ctx)
    if !isnothing(lbindings)
        init_lambda_binding(lbindings, ex.var_id)
    end
    ex
end

function new_global_binding(ctx::AbstractLoweringContext, srcref, name, mod; kws...)
    nameref = makeleaf(ctx, srcref, K"Identifier")
    nameref.name_val = name
    new_binding(ctx, nameref, name, :global; is_internal=true, mod=mod, kws...)
end
```

**JuliaLowering/src/runtime.jl:55-69**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6c75e91cf4fc8bc7972131a778482e3e8279e9c6/JuliaLowering/src/runtime.jl#L55-L69)
```julia
function _interpolated_value(ctx::InterpolationContext, srcref, ex)
    if ex isa SyntaxTree
        if !is_compatible_graph(ctx, ex)
            ex = copy_ast(ctx, ex)
        end
        append_sourceref(ctx, ex, srcref)
    elseif ex isa Symbol
        # Plain symbols become identifiers. This is an accommodation for
        # compatibility to allow `:x` (a Symbol) and `:(x)` (a SyntaxTree) to
        # be used interchangeably in macros.
        newleaf(ctx, srcref, K"Identifier", string(ex))
    else
        newleaf(ctx, srcref, K"Value", ex)
    end
end
```

</details>

### Secondary Effects

#### AST attributes provided to @ast now flow through explicit Pair lists and setattr! calls rather than keyword splats.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
_expand_ast_tree() constructs nodes via newleaf/makenode (ast.jl:268-317)
  -> for each attribute Pair from _kw_to_pair() (ast.jl:234-241)
  -> setattr!(node, attr, val) applies attributes after node creation (ast.jl:279-316)
```
</details>

**Downstream Surfaces:**
- Macros or tooling that generate JuliaLowering SyntaxTree via @ast
- Custom passes expecting keyword-arg attr construction

#### Scope-layer hygiene updates now mutate/set attributes after child-mapping, which can reuse existing nodes when children are unchanged.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
set_scope_layer() maps children via mapchildren() (ast.jl:510-522)
  -> mapchildren() returns original node if no child changes (ast.jl:418-443)
  -> setattr!(ex2, :scope_layer, new_layer) writes attribute in place (ast.jl:525)
set_macro_arg_hygiene() similarly sets :scope_layer after mapchildren() (macro_expansion.jl:215-236)
```
</details>

**Downstream Surfaces:**
- Macro expansion hygiene (scope_layer propagation)
- Passes that rely on node identity changes when scope_layer updates

#### Lambda nodes store :lambda_bindings via explicit attribute vectors, aligning closure conversion with the new API.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
closure_convert_lambda() builds lambda_children then calls
  makenode(ctx, ex, ex, lambda_children, [:lambda_bindings=>lambda_bindings])
  (closure_conversion.jl:552-596)
```
</details>

**Downstream Surfaces:**
- Closure conversion consumers reading :lambda_bindings

### Compatibility

#### Internal API Changes
- **makeleaf/makenode keyword-attr forms**: Replaced by makeleaf(ctx, srcref, proto, attrs::AbstractVector) and makenode(ctx, srcref, proto, children, attrs=nothing); attributes are attached via Pair vectors or setattr!.
- **setattr!(graph, id; kw...)**: Replaced with setattr!(graph, id, ::Symbol, value) and SyntaxTree property setters using setattr!.
- **setchildren!(graph, id, children...)**: Now requires an AbstractVector{NodeId} or SyntaxList for children, rather than varargs.
- **mapchildren extra_attrs keyword parameters**: extra_attrs keyword support removed; attribute mutation now occurs via explicit setattr! after mapchildren.
- **setmeta/setmeta! signatures**: Now require explicit (key::Symbol, value) arguments instead of keyword pairs.

#### Behavioral Changes
- No intended semantic changes; updates are refactors to attribute handling and node construction APIs.

### Performance

**Compile Time:**
- {'item': 'MEASURED (author report) JuliaLowering image size reduction', 'detail': '~20% JuliaLowering package image size reduction (26.910 MiB -> 21.701 MiB) and sysbase.dylib size change (+55MB -> +45MB); precompile time unchanged.', 'evidence': [{'source': 'pr_description', 'path': 'pr-archive/JuliaLang_julia/pr_60191.json', 'loc': '64-64', 'url': 'https://github.com/JuliaLang/julia/pull/60191', 'snippet': "We currently use keyword arguments as arbitrary key-value pairs in a number of\n     places, which I've realized isn't really how they're intended to be used.\n      This change fixes this and reduces the JuliaLowering package image size by\n     about 20% on my machine from `26.910 MiB -> 21.701 MiB`, or when compiled\n     into sysbase.dylib, `+55MB -> +45MB`.  Unfortunately no change to\n     precompile time as I had hoped, but I figured this is worth doing anyway.\n     Lowering performance looks unchanged.\n"}]}

**Runtime:**
- {'item': 'No runtime performance change claimed', 'detail': 'Author reports lowering performance unchanged.', 'evidence': [{'source': 'pr_description', 'path': 'pr-archive/JuliaLang_julia/pr_60191.json', 'loc': '64-64', 'url': 'https://github.com/JuliaLang/julia/pull/60191', 'snippet': 'Lowering performance looks unchanged.\n'}]}

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are primarily API refactors in JuliaLowering node construction and attribute setters.
- Tests and internal call sites updated to the new attribute-setting style.

### Recommendations

- Update downstream JuliaLowering users to pass attribute vectors (Pair lists) and use explicit setattr! calls instead of keyword attributes.
- Consider adding a short-lived deprecation layer for keyword-based setters if external packages consume JuliaLowering APIs.
- Add targeted @ast tests that assert attribute creation order and scope_layer propagation under mapchildren-based updates.
