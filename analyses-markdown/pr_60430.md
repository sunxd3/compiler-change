# PR #60430: Don't make graph type abstract in SyntaxTree

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60430
- **Merged**: 2025-12-24 19:41 UTC
- **Labels**: `JuliaLowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60430.diff

## Scope

### Files Touched
- `JuliaSyntax/src/porcelain/syntax_graph.jl`
- `JuliaLowering/src/ast.jl`
- `JuliaLowering/src/closure_conversion.jl`
- `JuliaLowering/src/desugaring.jl`
- `JuliaLowering/src/eval.jl`
- `JuliaLowering/src/linear_ir.jl`
- `JuliaLowering/src/macro_expansion.jl`
- `JuliaLowering/src/scope_analysis.jl`

### Components
- JuliaSyntax
- JuliaLowering

### Pipeline Stages
- Parsing
- Lowering
- LinearIR

## Analysis

### Intent

Concretize SyntaxTree/SyntaxList graph typing by parameterizing on attribute storage (Attrs) and requiring SyntaxGraph{Attrs} in lowering contexts to avoid abstract graph types and reduce specialization churn.

### Direct Changes

#### 1. SyntaxTree now stores a concrete SyntaxGraph{Attrs} instead of an abstract graph type parameter, tying the tree directly to the attribute storage type.

**Component**: JuliaSyntax

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/porcelain/syntax_graph.jl:190-198**
[View on GitHub](https://github.com/JuliaLang/julia/blob/c711544f4e229c9bde575e76918ee311b72914b2/JuliaSyntax/src/porcelain/syntax_graph.jl#L190-L198)
```julia
"""
    struct SyntaxTree

An ECS-style AST used in JuliaLowering.  Unstable, but may eventually replace
SyntaxNode.
"""
struct SyntaxTree{Attrs}
    _graph::SyntaxGraph{Attrs}
    _id::NodeId
end
```

</details>

#### 2. SyntaxList is now parameterized by attribute storage and explicitly stores SyntaxGraph{Attrs}, with a constructor that infers Attrs from the graph.

**Component**: JuliaSyntax

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/porcelain/syntax_graph.jl:449-463**
[View on GitHub](https://github.com/JuliaLang/julia/blob/c711544f4e229c9bde575e76918ee311b72914b2/JuliaSyntax/src/porcelain/syntax_graph.jl#L449-L463)
```julia
#-------------------------------------------------------------------------------
# Lightweight vector of nodes ids with associated pointer to graph stored separately.
mutable struct SyntaxList{Attrs, NodeIdVecType} <: AbstractVector{SyntaxTree}
    graph::SyntaxGraph{Attrs}
    ids::NodeIdVecType
end

function SyntaxList(graph::SyntaxGraph{T}, ids::AbstractVector{NodeId}) where {T}
    SyntaxList{T, typeof(ids)}(graph, ids)
end

SyntaxList(graph::SyntaxGraph) = SyntaxList(graph, Vector{NodeId}())
SyntaxList(ctx) = SyntaxList(syntax_graph(ctx))

syntax_graph(lst::SyntaxList) = lst.graph
```

</details>

#### 3. Lowering contexts now store concrete SyntaxGraph{Attrs} and propagate Attrs through ClosureConversion and Linear IR structures, reducing abstract graph typing inside lowering passes.

**Component**: JuliaLowering

<details>
<summary>Evidence</summary>

**JuliaLowering/src/closure_conversion.jl:1-37**
[View on GitHub](https://github.com/JuliaLang/julia/blob/c711544f4e229c9bde575e76918ee311b72914b2/JuliaLowering/src/closure_conversion.jl#L1-L37)
```julia
struct ClosureInfo{Attrs}
    # Global name of the type of the closure
    type_name::SyntaxTree{Attrs}
    # Names of fields for use with getfield, in order
    field_names::SyntaxList{Attrs, Vector{NodeId}}
    # Map from the original BindingId of closed-over vars to the index of the
    # associated field in the closure type.
    field_inds::Dict{IdTag,Int}
end

struct ClosureConversionCtx{Attrs} <: AbstractLoweringContext
    graph::SyntaxGraph{Attrs}
    bindings::Bindings
    mod::Module
    closure_bindings::Dict{IdTag,ClosureBindings}
    capture_rewriting::Union{Nothing,ClosureInfo{Attrs},
                             SyntaxList{Attrs, Vector{NodeId}}}
    lambda_bindings::LambdaBindings
    # True if we're in a section of code which preserves top-level sequencing
    # such that closure types can be emitted inline with other code.
    is_toplevel_seq_point::Bool
    # True if this expression should not have toplevel effects, namely, it
    # should not declare the globals it references.  This allows generated
    # functions to refer to globals that have already been declared, without
    # triggering the "function body AST not pure" error.
    toplevel_pure::Bool
    toplevel_stmts::SyntaxList{Attrs, Vector{NodeId}}
    closure_infos::Dict{IdTag,ClosureInfo{Attrs}}
end

function ClosureConversionCtx(graph::SyntaxGraph{Attrs}, bindings::Bindings,
                              mod::Module, closure_bindings::Dict{IdTag,ClosureBindings},
                              lambda_bindings::LambdaBindings) where {Attrs}
    ClosureConversionCtx{Attrs}(
        graph, bindings, mod, closure_bindings, nothing,
        lambda_bindings, false, true, SyntaxList(graph),
        Dict{IdTag,ClosureInfo{Attrs}}())
end
```

**JuliaLowering/src/linear_ir.jl:67-93**
[View on GitHub](https://github.com/JuliaLang/julia/blob/c711544f4e229c9bde575e76918ee311b72914b2/JuliaLowering/src/linear_ir.jl#L67-L93)
```julia
struct LinearIRContext{Attrs} <: AbstractLoweringContext
    graph::SyntaxGraph{Attrs}
    code::SyntaxList{Attrs, Vector{NodeId}}
    bindings::Bindings
    next_label_id::Ref{Int}
    is_toplevel_thunk::Bool
    lambda_bindings::LambdaBindings
    return_type::Union{Nothing, SyntaxTree{Attrs}}
    break_targets::Dict{String, JumpTarget{Attrs}}
    handler_token_stack::SyntaxList{Attrs, Vector{NodeId}}
    catch_token_stack::SyntaxList{Attrs, Vector{NodeId}}
    finally_handlers::Vector{FinallyHandler{Attrs}}
    symbolic_jump_targets::Dict{String,JumpTarget{Attrs}}
    symbolic_jump_origins::Vector{JumpOrigin{Attrs}}
    meta::Dict{Symbol, Any}
    mod::Module
end

function LinearIRContext(ctx, is_toplevel_thunk, lambda_bindings, return_type)
    graph = syntax_graph(ctx)
    rett = isnothing(return_type) ? nothing : reparent(graph, return_type)
    Attrs = typeof(graph.attributes)
    LinearIRContext(graph, SyntaxList(ctx), ctx.bindings, Ref(0),
                    is_toplevel_thunk, lambda_bindings, rett,
                    Dict{String,JumpTarget{Attrs}}(), SyntaxList(ctx), SyntaxList(ctx),
                    Vector{FinallyHandler{Attrs}}(), Dict{String,JumpTarget{Attrs}}(),
                    Vector{JumpOrigin{Attrs}}(), Dict{Symbol, Any}(), ctx.mod)
end
```

</details>

#### 4. Existing tests continue to validate SyntaxTree construction/parsing behavior, indicating the change is type-structural rather than a parsing semantic change.

**Component**: JuliaSyntax

<details>
<summary>Evidence</summary>

**JuliaSyntax/test/syntax_graph.jl:45-51**
[View on GitHub](https://github.com/JuliaLang/julia/blob/c711544f4e229c9bde575e76918ee311b72914b2/JuliaSyntax/test/syntax_graph.jl#L45-L51)
```julia
@testset "SyntaxTree parsing" begin
    # Errors should fall through
    @test parsestmt(SyntaxTree, "@"; ignore_errors=true) isa SyntaxTree
    @test parsestmt(SyntaxTree, "@@@"; ignore_errors=true) isa SyntaxTree
    @test parsestmt(SyntaxTree, "(a b c)"; ignore_errors=true) isa SyntaxTree
    @test parsestmt(SyntaxTree, "'a b c'"; ignore_errors=true) isa SyntaxTree
end
```

</details>

### Secondary Effects

#### Lowering context types become more concrete, which can reduce specialization blow-up and precompile time in JuliaLowering-heavy workloads.

**Likelihood**: medium | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
LinearIRContext(ctx, ...)  [JuliaLowering/src/linear_ir.jl:85-93]
  -> graph = syntax_graph(ctx)  [JuliaLowering/src/linear_ir.jl:86]
  -> Attrs = typeof(graph.attributes)  [JuliaLowering/src/linear_ir.jl:88]
  -> LinearIRContext{Attrs} stores SyntaxGraph{Attrs} and SyntaxList{Attrs,...}
     (replaces abstract graph typing for JumpTarget/JumpOrigin/etc.)
```
</details>

**Downstream Surfaces:**
- Lowering pass caching / method instance count
- Precompilation time for JuliaLowering consumers

#### Custom graphs are no longer accepted by SyntaxTree/SyntaxList-based lowering contexts without wrapping in SyntaxGraph{Attrs}, reducing polymorphism at the SyntaxTree boundary.

**Likelihood**: low | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
SyntaxTree{Attrs} stores _graph::SyntaxGraph{Attrs}  [JuliaSyntax/src/porcelain/syntax_graph.jl:195-197]
  -> SyntaxList{Attrs,...} stores graph::SyntaxGraph{Attrs}  [JuliaSyntax/src/porcelain/syntax_graph.jl:451-453]
  -> ClosureConversionCtx/LinearIRContext now require SyntaxGraph{Attrs}  [JuliaLowering/src/closure_conversion.jl:11-12]
```
</details>

**Downstream Surfaces:**
- Packages that construct SyntaxTree with non-SyntaxGraph graphs
- Custom AST graph experiments that relied on graph-type polymorphism

### Compatibility

#### Internal API Changes
- **SyntaxTree{Attrs}::_graph**: Now concretely typed as SyntaxGraph{Attrs} instead of a generic graph type parameter, so type-parameterized extensions on SyntaxTree{GraphType} must adapt to Attrs-based typing.
- **SyntaxList{Attrs}::graph**: Now concretely typed as SyntaxGraph{Attrs}; downstream code depending on SyntaxList{GraphType} polymorphism will need refactoring.

### Performance

**Compile Time:**
- ESTIMATED: fewer method instances due to concrete SyntaxGraph{Attrs} typing in lowering contexts; verify with precompile metrics for JuliaLowering-heavy packages.

### Risk Assessment

**Level**: low

**Rationale:**
- No algorithmic behavior changes in parsing/lowering; changes are type-structural.
- Potential impact is mostly on internal API expectations about graph type parameters.

### Recommendations

- Run package CI or targeted precompile benchmarks for tools that specialize on SyntaxTree/SyntaxList types to confirm reduced method instance counts.
