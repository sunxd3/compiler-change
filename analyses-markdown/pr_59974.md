# PR #59974: inference: revisit all methods in cycle

## Metadata

- **Author**: vtjnash
- **URL**: https://github.com/JuliaLang/julia/pull/59974
- **Merged**: 2025-11-01 02:52 UTC
- **Labels**: `compiler:inference`, `backport 1.10`, `backport 1.11`
- **Diff**: https://github.com/JuliaLang/julia/pull/59974.diff

## Scope

### Files Touched
- `Compiler/src/typeinfer.jl`

### Components
- Compiler

### Pipeline Stages
- TypeInference

## Analysis

### Intent

Ensure inference revisits all methods participating in recursive cycles so cached results do not get stuck at Union{}; keep cycle backedges lazy to avoid extra allocations.

**Related Issues:**
- https://github.com/JuliaLang/julia/issues/59943

### Direct Changes

#### 1. Cycle merging now only normalizes cycle IDs; it no longer adds backedges during the merge walk.

**Component**: Compiler/src/typeinfer.jl

<details>
<summary>Evidence</summary>

**Compiler/src/typeinfer.jl:893-905**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f4847bf687ab0fa37fdcd237512d5ec6486ae788/Compiler/src/typeinfer.jl#L893-L905)
```julia
function merge_call_chain!(::AbstractInterpreter, parent::InferenceState, child::InferenceState)
    # update all cycleid to be in the same group
    frames = parent.callstack::Vector{AbsIntState}
    @assert child.callstack === frames
    ancestorid = child.cycleid
    # ensure that walking the callstack has the same cycleid (DAG)
    for frameid = reverse(ancestorid:length(frames))
        frame = frames[frameid]::InferenceState
        frame.cycleid == ancestorid && break
        @assert frame.cycleid > ancestorid
        frame.cycleid = ancestorid
    end
end
```

</details>

#### 2. Adding a cycle backedge no longer updates caller world-age; it only records the (caller, pc) pair.

**Component**: Compiler/src/typeinfer.jl

<details>
<summary>Evidence</summary>

**Compiler/src/typeinfer.jl:907-910**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f4847bf687ab0fa37fdcd237512d5ec6486ae788/Compiler/src/typeinfer.jl#L907-L910)
```julia
function add_cycle_backedge!(caller::InferenceState, frame::InferenceState)
    backedge = (caller, caller.currpc)
    contains_is(frame.cycle_backedges, backedge) || push!(frame.cycle_backedges, backedge)
    return frame
end
```

</details>

#### 3. Cycle backedges are now recorded when returning results from cyclic inference, including the deferred task path.

**Component**: Compiler/src/typeinfer.jl

<details>
<summary>Evidence</summary>

**Compiler/src/typeinfer.jl:1096-1130**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f4847bf687ab0fa37fdcd237512d5ec6486ae788/Compiler/src/typeinfer.jl#L1096-L1130)
```julia
let mresult = Future{MethodCallResult}()
    push!(caller.tasks, function get_infer_result(interp, caller)
        update_valid_age!(caller, frame.world.valid_worlds)
        local isinferred = is_inferred(frame)
        local edge = isinferred ? edge_ci : nothing
        local effects = isinferred ? frame.result.ipo_effects : # effects are adjusted already within `finish` for ipo_effects
            adjust_effects(effects_for_cycle(frame.ipo_effects), method)
        local bestguess = frame.bestguess
        local exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)
        local volatile_inf_result = if isinferred && edge_ci isa CodeInstance
            result.ci_as_edge = edge_ci # set the edge for the inliner usage
            VolatileInferenceResult(result)
        end
        isinferred || add_cycle_backedge!(caller, frame)
        mresult[] = MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects,
            edge, edgecycle, edgelimited, volatile_inf_result)
        return true
    end)
    return mresult
end
update_valid_age!(caller, frame.world.valid_worlds)
effects = adjust_effects(effects_for_cycle(frame.ipo_effects), method)
bestguess = frame.bestguess
exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)
add_cycle_backedge!(caller, frame)
return Future(MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects, nothing, edgecycle, edgelimited))
```

</details>

### Secondary Effects

#### All call sites in a recursion cycle are re-visited when cycle effects are finalized, avoiding stale cached results (e.g., Union{}).

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
resolve_call_cycle!(interp, mi, caller)  [typeinfer.jl:928-951]
  -> merge_call_chain!(interp, parent, frame)  [typeinfer.jl:893-905]
  -> typeinf_edge(...)
     adds backedges for each cycle participant via add_cycle_backedge!  [typeinfer.jl:1096-1130]
  -> adjust_cycle_frame!(sv, cycle_valid_worlds, cycle_valid_effects)
     walks sv.cycle_backedges to update call-site flags  [typeinfer.jl:316-328]
```
</details>

**Downstream Surfaces:**
- Inference caching and cycle revalidation
- Effects propagation through recursive call graphs

#### World-age updates for cycle callers are now tied to explicit inference result usage rather than cycle-merge bookkeeping.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
add_cycle_backedge! no longer updates valid age (typeinfer.jl:907-910)
  -> update_valid_age!(caller, frame.world.valid_worlds) remains in typeinf_edge
     before recording backedges (typeinfer.jl:1096-1130)
```
</details>

**Downstream Surfaces:**
- Inference world-range tracking for recursive edges

### Compatibility

#### Behavioral Changes
- Recursive inference cycles now guarantee call-site backedges are recorded when results are consumed, reducing chances of caching bottom (Union{}) without re-visitation.

### Performance

**Compile Time:**
- ESTIMATED: negligible; backedges are still created lazily, but now only at result consumption sites.

**Runtime:**
- ESTIMATED: indirect improvements when recursive inference no longer caches Union{} and forces re-inference on call sites.

### Risk Assessment

**Level**: medium

**Rationale:**
- Touches recursion-cycle handling in type inference; changes which call sites are revalidated in cycles.
- Behavioral change is localized to recursive/cyclic call graphs, but could affect inference stability.

### Recommendations

- Consider adding a focused regression test alongside existing cycle tests in Compiler/test/inference.jl to lock in the multi-cycle revisit behavior.
- Downstream tooling that inspects inference cache stability should re-run tests that involve recursive inference (e.g., analysis of code_typed for recursive functions).
