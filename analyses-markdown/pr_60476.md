# PR #60476: [JuliaSyntax] Add type-asserts to the results of `parse_brackets()`

## Metadata

- **Author**: JamesWrigley
- **URL**: https://github.com/JuliaLang/julia/pull/60476
- **Merged**: 2026-01-05 04:25 UTC
- **Labels**: `backport 1.12`, `backport 1.13`
- **Diff**: https://github.com/JuliaLang/julia/pull/60476.diff

## Scope

### Files Touched
- `JuliaSyntax/src/julia/parser.jl`

### Components
- JuliaSyntax

### Pipeline Stages
- Parsing

## Analysis

### Intent

Enforce concrete NamedTuple return types from parse_brackets callbacks to stabilize parser option handling and address JuliaSyntax issue 600 regressions.

**Related Issues:**
- https://github.com/JuliaLang/JuliaSyntax.jl/issues/600
- https://github.com/JuliaLang/JuliaSyntax.jl/pull/615

### Direct Changes

#### 1. Type-assert parse_brackets callback results in parse_unary/parse_function_signature/parse_paren/parse_string so option tuples have fixed fields and RawFlags delimiter metadata.

**Component**: JuliaSyntax parser

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/julia/parser.jl:1272-1283**
[View on GitHub](https://github.com/JuliaLang/julia/blob/05c973aa9bf85995b92ac5675d61913c2deb98a7/JuliaSyntax/src/julia/parser.jl#L1272-L1283)
```julia
mark_before_paren = position(ps)
bump(ps, TRIVIA_FLAG) # (
initial_semi = peek(ps, skip_newlines=true) == K";"
opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
    is_paren_call = had_commas || had_splat               ||
                    (initial_semi && num_subexprs > 0)    ||
                    (initial_semi && num_semis == 1)      ||
                    (num_semis == 0 && num_subexprs == 0)
    return (needs_parameters=is_paren_call,
            is_paren_call=is_paren_call,
            is_block=!is_paren_call && num_semis > 0)
end::NamedTuple{(:needs_parameters, :is_paren_call, :is_block, :delim_flags), Tuple{Bool, Bool, Bool, RawFlags}}
```

**JuliaSyntax/src/julia/parser.jl:2218-2246**
[View on GitHub](https://github.com/JuliaLang/julia/blob/05c973aa9bf85995b92ac5675d61913c2deb98a7/JuliaSyntax/src/julia/parser.jl#L2218-L2246)
```julia
opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
    _parsed_call = was_eventually_call(ps)
    _maybe_grouping_parens = !had_commas && !had_splat && num_semis == 0 && num_subexprs == 1
    next_token_pos = if peek(ps, 1, skip_newlines=false) == K")"
        2
    else
        3
    end
    token_after_paren = peek(ps, next_token_pos, skip_newlines=false)
    has_newline_after_paren = _maybe_grouping_parens && token_after_paren == K"NewlineWs"
    next_kind = peek(ps, 2, skip_newlines=_maybe_grouping_parens && !has_newline_after_paren)
    _needs_parse_call = next_kind âˆˆ KSet"( ."
    _is_anon_func = (!_needs_parse_call && !_parsed_call) || had_commas
    return (needs_parameters      = _is_anon_func,
            is_anon_func          = _is_anon_func,
            parsed_call           = _parsed_call,
            needs_parse_call      = _needs_parse_call,
            maybe_grouping_parens = _maybe_grouping_parens)
end::NamedTuple{(:needs_parameters, :is_anon_func, :parsed_call, :needs_parse_call, :maybe_grouping_parens, :delim_flags),
                Tuple{Bool, Bool, Bool, Bool, Bool, RawFlags}}
```

**JuliaSyntax/src/julia/parser.jl:3318-3333**
[View on GitHub](https://github.com/JuliaLang/julia/blob/05c973aa9bf85995b92ac5675d61913c2deb98a7/JuliaSyntax/src/julia/parser.jl#L3318-L3333)
```julia
if prev_chunk_newline
    indent_ref_i = first_byte(t)
    indent_ref_len = 0
end
bump(ps, TRIVIA_FLAG)
k = peek(ps)
if k == K"("
    m = position(ps)
    bump(ps, TRIVIA_FLAG)
    opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
        return (needs_parameters=false,
                simple_interp=!had_commas && num_semis == 0 && num_subexprs == 1)
    end::NamedTuple{(:needs_parameters, :simple_interp, :delim_flags), Tuple{Bool, Bool, RawFlags}}
```

</details>

#### 2. Assert NamedTuple shapes for parse_call_arglist and parse_vect bracket parsing to keep needs_parameters/num_subexprs types concrete.

**Component**: JuliaSyntax parser

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/julia/parser.jl:2775-2798**
[View on GitHub](https://github.com/JuliaLang/julia/blob/05c973aa9bf85995b92ac5675d61913c2deb98a7/JuliaSyntax/src/julia/parser.jl#L2775-L2798)
```julia
function parse_call_arglist(ps::ParseState, closer)
    ps = ParseState(ps, for_generator=true)

    parse_brackets(ps, closer, false) do _, _, _, _
        return (needs_parameters=true,)
    end::NamedTuple{(:needs_parameters, :delim_flags), Tuple{Bool, RawFlags}}
end

function parse_vect(ps::ParseState, closer, prefix_trailing_comma)
    opts = parse_brackets(ps, closer) do _, _, _, num_subexprs
        return (needs_parameters=true,
                num_subexprs=num_subexprs)
    end::NamedTuple{(:needs_parameters, :num_subexprs, :delim_flags), Tuple{Bool, Int, RawFlags}}
    delim_flags = opts.delim_flags
```

</details>

#### 3. Parser tests continue to assert expected AST for prefix operator calls and bracketed argument lists; these serve as concrete before/after behavior references.

**Component**: JuliaSyntax tests

<details>
<summary>Evidence</summary>

**JuliaSyntax/test/parser.jl:204-245**
[View on GitHub](https://github.com/JuliaLang/julia/blob/05c973aa9bf85995b92ac5675d61913c2deb98a7/JuliaSyntax/test/parser.jl#L204-L245)
```julia
JuliaSyntax.parse_unary => [
    ":T"       => "(quote-: T)"
    "in::T"    => "(::-i in T)"
    "isa::T"   => "(::-i isa T)"
    "-2^x"     => "(call-pre - (call-i 2 ^ x))"
    "-2[1, 3]" => "(call-pre - (ref 2 1 3))"
    "+{T}(x::T)"  =>  "(call (curly + T) (::-i x T))"
    "*(x)"        =>  "(call * x)"
    ".*(x)"       =>  "(call (. *) x)"
    "+(a,b)"   =>  "(call + a b)"
    "+(a,)"    =>  "(call-, + a)"
    ".+(a,)"   =>  "(call-, (. +) a)"
    "(.+)(a)"  =>  "(call (parens (. +)) a)"
    "(.~(a))"  =>  "(parens (dotcall-pre ~ (parens a)))"
    "+(a=1,)"  =>  "(call-, + (= a 1))"
    "+(a...)"  =>  "(call + (... a))"
    "+(a;b,c)" =>  "(call + a (parameters b c))"
    "+(;a)"    =>  "(call + (parameters a))"
    "+(;;a)"   =>  "(call + (parameters) (parameters a))"
    "+()"      =>  "(call +)"
    "+(\n;a)"  =>  "(call + (parameters a))"
    "+(;)"     =>  "(call + (parameters))"
```

</details>

### Secondary Effects

#### Invalid parse_brackets option tuples now fail fast with a TypeError, rather than propagating loosely-typed opts fields into later parse logic.

**Likelihood**: low | **Impact**: low

<details>
<summary>Mechanism</summary>

```
parse_unary(...) [parser.jl:1272-1311]
  -> parse_brackets(...) [parser.jl:1275]
    -> after_parse(...) returns NamedTuple
    -> result asserted to NamedTuple{(:needs_parameters,:is_paren_call,:is_block,:delim_flags),Tuple{Bool,Bool,Bool,RawFlags}} [parser.jl:1283]
  -> opts.delim_flags used in emit(...) [parser.jl:1307-1311]
parse_brackets(...) itself appends delim_flags before returning [parser.jl:3272-3281].
```
</details>

**Downstream Surfaces:**
- JuliaSyntax.parse_unary/parse_paren/parse_string callers
- SyntaxTree/SyntaxNode parse output consumers

#### More stable type inference for opts NamedTuples in parser hot paths, potentially reducing dynamic dispatch during parsing (ESTIMATED).

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
parse_call_arglist(...) [parser.jl:2775-2780]
  -> parse_brackets(...) [parser.jl:2778]
    -> return asserted NamedTuple{(:needs_parameters,:delim_flags),Tuple{Bool,RawFlags}}
This keeps needs_parameters/delim_flags concrete for subsequent code paths, improving compiler specialization for parsing routines.
```
</details>

**Downstream Surfaces:**
- Parser throughput for code with heavy bracket syntax

### Compatibility

#### Internal API Changes
- **parse_brackets after_parse return tuple fields**: Call sites now assert exact NamedTuple field sets and types (Bool fields plus RawFlags delim_flags).

#### Behavioral Changes
- If an after_parse callback returns a NamedTuple with unexpected fields or non-Bool/RawFlags types, parsing throws a TypeError instead of silently proceeding. *(Impact: low)*

### Performance

**Compile Time:**
- low

**Runtime:**
- low

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are limited to type assertions on internal NamedTuple shapes and do not alter parsing logic for valid inputs.
- Potential failures only occur if internal callbacks return malformed option tuples.

### Recommendations

- If downstream tooling patches JuliaSyntax parser helpers, ensure parse_brackets callbacks return NamedTuples with the asserted fields and RawFlags delim_flags.
- Consider adding a small parser test that exercises a parse_brackets path and validates delim_flags presence to prevent regressions.
