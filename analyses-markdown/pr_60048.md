# PR #60048: Backports for 1.13.0-alpha1

## Metadata

- **Author**: KristofferC
- **URL**: https://github.com/JuliaLang/julia/pull/60048
- **Merged**: 2025-11-17 07:25 UTC
- **Labels**: `release`
- **Diff**: https://github.com/JuliaLang/julia/pull/60048.diff

## Scope

### Files Touched
- `Compiler/src/tfuncs.jl`
- `Compiler/test/effects.jl`

### Components
- Compiler.tfuncs
- Compiler.Effects

### Pipeline Stages
- TypeInference
- Effects

## Analysis

### Intent

Backport compiler and runtime fixes for 1.13.0-alpha1, including correcting pointer arithmetic type inference for Const pointers and adding a regression test for null-pointer offset behavior.

**Related Issues:**
- https://github.com/JuliaLang/julia/issues/60009

### Direct Changes

#### 1. Pointer arithmetic tfunc now widens Const pointers instead of returning the const lattice element, so inference yields a Ptr type rather than preserving a constant pointer value.

**Component**: Compiler.tfuncs

<details>
<summary>Evidence</summary>

**Compiler/src/tfuncs.jl:710-712**
[View on GitHub](https://github.com/JuliaLang/julia/blob/25da06e0cd4e808466066639fd4bb03c709829c6/Compiler/src/tfuncs.jl#L710-L712)
```julia
@nospecs function pointerarith_tfunc(ùïÉ::AbstractLattice, ptr, offset)
    return widenconst(ptr)
end
```

</details>

#### 2. Adds a regression test asserting pointer arithmetic on C_NULL produces the expected non-null offset pointer value.

**Component**: Compiler.Effects

<details>
<summary>Evidence</summary>

**Compiler/test/effects.jl:1491-1495**
[View on GitHub](https://github.com/JuliaLang/julia/blob/25da06e0cd4e808466066639fd4bb03c709829c6/Compiler/test/effects.jl#L1491-L1495)
```julia
# https://github.com/JuliaLang/julia/issues/60009
function null_offset(offset)
    Ptr{UInt8}(C_NULL) + offset
end
@test null_offset(Int(100)) == Ptr{UInt8}(UInt(100))
```

</details>

### Secondary Effects

#### Type inference for add/sub on pointers no longer preserves Const pointer lattice elements, which can reduce constant propagation for pointer arithmetic but avoids incorrect constant results when offsets vary at runtime.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
add_tfunc(add_ptr, 2, 2, pointerarith_tfunc, 1)  [Compiler/src/tfuncs.jl:756]
  -> pointerarith_tfunc(ùïÉ, ptr, offset)  [Compiler/src/tfuncs.jl:710-712]
     now returns widenconst(ptr) instead of a Const lattice element
  -> inference result for Ptr arithmetic becomes widened to Ptr{T}
```
</details>

**Downstream Surfaces:**
- Core.Compiler.tfuncs (type inference for pointer arithmetic)
- Const-prop dependent tooling (e.g., GPUCompiler)

### Compatibility

#### Internal API Changes
- **Core.Compiler.pointerarith_tfunc**: Return value now uses widenconst(ptr) for Const pointers, reducing const-precision but avoiding incorrect Const pointer results.

#### Behavioral Changes
- Runtime result unchanged, but inference no longer forces Const pointer results; test now locks expected behavior for C_NULL offsets.

### Performance

**Compile Time:**
- Negligible (single widenconst call). ESTIMATED.

**Runtime:**
- No runtime change expected; adjustment is to inference-only tfunc. ESTIMATED.

### Risk Assessment

**Level**: low

**Rationale:**
- Change is localized to an inference tfunc and validated by a new regression test.
- Effect is limited to Const pointer lattice handling for add/sub pointer arithmetic.

### Recommendations

- Downstream tooling that depends on Const-prop of pointer arithmetic should account for widened results in inference outputs.
