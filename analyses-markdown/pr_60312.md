# PR #60312: Backports for 1.13.0-beta1

## Metadata

- **Author**: KristofferC
- **URL**: https://github.com/JuliaLang/julia/pull/60312
- **Merged**: 2026-01-09 13:31 UTC
- **Labels**: `release`
- **Diff**: https://github.com/JuliaLang/julia/pull/60312.diff

## Scope

### Files Touched
- `Compiler/src/abstractinterpretation.jl`
- `Compiler/src/typeinfer.jl`
- `base/timing.jl`
- `test/misc.jl`

### Components
- Compiler.AbstractInterpretation
- Compiler.TypeInference
- Base.Timing

### Pipeline Stages
- TypeInference
- AbstractInterpretation

## Analysis

### Intent

Backport a set of fixes for the 1.13.0-beta1 release branch, including compiler inference/compilation queue handling and Base timing macro behavior.

**Related Issues:**
- https://github.com/JuliaLang/julia/issues/60444

### Direct Changes

#### 1. Fixes the exception widening predicate in abstract_invoke to consult the current CodeInstance/Method owner, avoiding a stale reference when computing ErrorException unions.

**Component**: Compiler.AbstractInterpretation

<details>
<summary>Evidence</summary>

**Compiler/src/abstractinterpretation.jl:2246-2249**
[View on GitHub](https://github.com/JuliaLang/julia/blob/1ef81a6256ad21d84cc7aa7dddd4a05e8e9fc760/Compiler/src/abstractinterpretation.jl#L2246-L2249)
```julia
# TODO: When we add curing, we may want to assume this is nothrow
if (method_or_ci.owner === Nothing && method_or_ci.def.def isa Method)
    exct = Union{exct, ErrorException}
end
```

</details>

#### 2. collectinvokes! now recognizes :new expressions that construct Function-typed structs and enqueues a callable specialization for invokelatest precompilation.

**Component**: Compiler.TypeInference

<details>
<summary>Evidence</summary>

**Compiler/src/typeinfer.jl:1466-1519**
[View on GitHub](https://github.com/JuliaLang/julia/blob/1ef81a6256ad21d84cc7aa7dddd4a05e8e9fc760/Compiler/src/typeinfer.jl#L1466-L1519)
```julia
function collectinvokes!(workqueue::CompilationQueue, ci::CodeInfo, sptypes::Vector{VarState};
                         invokelatest_queue::Union{CompilationQueue,Nothing} = nothing)
    src = ci.code
    for i = 1:length(src)
        stmt = src[i]
        isexpr(stmt, :(=)) && (stmt = stmt.args[2])
        if isexpr(stmt, :invoke) || isexpr(stmt, :invoke_modify)
            edge = stmt.args[1]
            edge isa CodeInstance && isdefined(edge, :inferred) && push!(workqueue, edge)
        end

        invokelatest_queue === nothing && continue
        if isexpr(stmt, :call)
            farg = stmt.args[1]
            !applicable(argextype, farg, ci, sptypes) && continue # TODO: Why is this failing during bootstrap
            ftyp = widenconst(argextype(farg, ci, sptypes))

            if ftyp === typeof(Core.finalizer) && length(stmt.args) == 3
                finalizer = argextype(stmt.args[2], ci, sptypes)
                obj = argextype(stmt.args[3], ci, sptypes)
                atype = argtypes_to_type(Any[finalizer, obj])
            else
                # No dynamic dispatch to resolve / enqueue
                continue
            end
        elseif isexpr(stmt, :cfunction) && length(stmt.args) == 5
            (_, f, _, at, _) = stmt.args
            linfo = ci.parent

            linfo isa MethodInstance || continue
            at isa SimpleVector || continue

            ft = argextype(f, ci, sptypes)
            argtypes = Any[ft]
            for i = 1:length(at)
                push!(argtypes, sp_type_rewrap(at[i], linfo, #= isreturn =# false))
            end
            atype = argtypes_to_type(argtypes)
        elseif isexpr(stmt, :new)
            # When creating a struct of Function type, check to see if we should
            # proactively compile the lambda
            t, _, _, _ = instanceof_tfunc(argextype(stmt.args[1], ci, sptypes))
            t <: Function || continue
            atype = Tuple{t, Vararg}
        else
            # TODO: handle other StmtInfo like OpaqueClosure?
            continue
        end
        let workqueue = invokelatest_queue
            # make a best-effort attempt to enqueue the relevant code for the dynamic invokelatest call
            mi = compileable_specialization_for_call(workqueue.interp, atype)
            mi === nothing && continue

            push!(workqueue, mi)
        end
    end
end
```

**Compiler/src/typeinfer.jl:1466,1557,1645**
[View on GitHub](https://github.com/JuliaLang/julia/blob/1ef81a6256ad21d84cc7aa7dddd4a05e8e9fc760/Compiler/src/typeinfer.jl#L1466-L1657)
```julia
Compiler/src/typeinfer.jl
1466:function collectinvokes!(workqueue::CompilationQueue, ci::CodeInfo, sptypes::Vector{VarState};
1557:        collectinvokes!(workqueue, src, sptypes)
1645:                collectinvokes!(workqueue, src, sptypes; invokelatest_queue)
```

</details>

#### 3. The @allocated machinery now treats dotted operators (e.g. .+) as non-simple calls, forcing wrapping so allocation measurement covers broadcasted expressions.

**Component**: Base.Timing

<details>
<summary>Evidence</summary>

**base/timing.jl:493-509**
[View on GitHub](https://github.com/JuliaLang/julia/blob/1ef81a6256ad21d84cc7aa7dddd4a05e8e9fc760/base/timing.jl#L493-L509)
```julia
function is_simply_call(@nospecialize ex)
    is_simple_atom(a) = a isa QuoteNode || a isa Symbol || !isa_ast_node(a)
    Meta.isexpr(ex, :call) || return false
    for a in ex.args
        is_simple_atom(a) && continue
        Meta.isexpr(a, :..., 1) && is_simple_atom(a.args[1]) && continue
        return false
    end
    # Ensure Expr(:call, .+, ...) get wrapped
    if ex.args[1] isa Symbol
        sa = String(ex.args[1]::Symbol)
        startswith(sa, ".") &&
            !endswith(sa, ".") &&
            isoperator(Symbol(sa[2:end])) &&
            return false
    end
    return true
end
```

**test/misc.jl:1552-1565**
[View on GitHub](https://github.com/JuliaLang/julia/blob/1ef81a6256ad21d84cc7aa7dddd4a05e8e9fc760/test/misc.jl#L1552-L1565)
```julia
@testset "Base/timing.jl" begin
    @test Base.jit_total_bytes() >= 0

    # sanity check `@allocations` returns what we expect in some very simple cases.
    @test (() -> @allocations "a")() == 0
    "a" * Base.inferencebarrier("b")
    @test (() -> @allocations "a" * Base.inferencebarrier("b"))() == 1
    # test that you can grab the value from @allocated
    @allocated _x = 1+2
    @test _x === 3

    # test `@allocated` works for dotted operations
    @test (@allocated 1 .+ 1) == 0
end
```

</details>

### Secondary Effects

#### Callable struct construction inside invokelatest-tracked CodeInfo now triggers proactive specialization enqueueing, which can reduce runtime latency when calling those callable objects via invokelatest.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
collectinvokes!(workqueue, ci, sptypes; invokelatest_queue)  [typeinfer.jl:1466-1519]
  detects Expr(:new, ...) where t <: Function
  -> atype = Tuple{t, Vararg}
  -> compileable_specialization_for_call(...) and push! to invokelatest_queue
add_codeinsts_to_jit!() calls collectinvokes! for CodeInfo  [typeinfer.jl:1554-1559]
compile!() also calls collectinvokes! when scanning CodeInfo  [typeinfer.jl:1642-1646]
```
</details>

**Downstream Surfaces:**
- Invocation of callable structs via invokelatest (e.g., closures stored in structs)
- Packages using custom Function subtypes to carry state (e.g., GPUCompiler, DifferentialEquations caches)

#### Exception effect metadata from abstract_invoke is more accurate for ownerless CodeInstances, which can slightly adjust nothrow/effects-driven optimizations and diagnostics.

**Likelihood**: low | **Impact**: low

<details>
<summary>Mechanism</summary>

```
abstract_invoke() now unions ErrorException based on method_or_ci.def.def  [abstractinterpretation.jl:2246-2249]
-> CallMeta uses exct to compute Effects(..., nothrow=(exct===Bottom))
-> downstream passes that consult effects may see a more conservative nothrow flag
```
</details>

**Downstream Surfaces:**
- Inference-driven optimizations that rely on nothrow/effects flags (e.g., inlining decisions)
- JET diagnostics that display potential exception paths

### Compatibility

#### Behavioral Changes
- @allocated now consistently reports on dotted (broadcast) operator expressions by wrapping them like other non-simple calls.

### Performance

**Compile Time:**
- ESTIMATED: minor extra queue work proportional to number of such expressions in a CodeInfo.

**Runtime:**
- ESTIMATED: small latency reduction for affected call sites.

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are narrowly scoped to inference queueing and exception metadata, with tests added for @allocated behavior.
- No new public compiler APIs or data structure layouts are introduced.

### Recommendations

- Downstream tooling that inspects effects/nothrow flags (JET, IRTools) should validate diagnostics on invokelatest-heavy workloads.
- Packages that construct callable structs and rely on invokelatest may see slightly different precompile coverage; consider re-running precompile tests.
