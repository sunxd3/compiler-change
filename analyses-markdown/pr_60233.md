# PR #60233: [JuliaLowering] Fix generated functions when `expr_compat_mode=true`

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60233
- **Merged**: 2025-11-25 12:34 UTC
- **Labels**: `compiler:lowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60233.diff

## Scope

### Files Touched
- `JuliaLowering/src/desugaring.jl`
- `JuliaLowering/src/eval.jl`
- `JuliaLowering/src/runtime.jl`
- `JuliaLowering/src/syntax_graph.jl`
- `JuliaLowering/src/utils.jl`
- `JuliaLowering/test/functions.jl`
- `JuliaLowering/test/functions_ir.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering
- MacroExpansion
- IRPrinting

## Analysis

### Intent

Ensure generated functions honor expr_compat_mode by threading the flag into
GeneratedFunctionStub and macro expansion contexts, and reduce IR printing
verbosity for generated functions that keep full green tree provenance.


**Related Issues:**
- https://github.com/JuliaLang/julia/issues/60226

### Direct Changes

#### 1. Pass expr_compat_mode into GeneratedFunctionStub creation for generated
functions so runtime expansion can use the same compatibility mode.


**Component**: JuliaLowering/desugaring

<details>
<summary>Evidence</summary>

**JuliaLowering/src/desugaring.jl:2547-2582**
[View on GitHub](https://github.com/JuliaLang/julia/blob/eca649c6bbfcc29e90333bd6850d9b165fe19ecc/JuliaLowering/src/desugaring.jl#L2547-L2582)
```julia
nongen_body = @ast ctx body [K"block"
    [K"meta"
        "generated"::K"Symbol"
        [K"new"
            GeneratedFunctionStub::K"Value" # Use stub type from JuliaLowering
            ctx.expr_compat_mode::K"Value"
            gen_name
            sourceref(srcref)::K"Value"
            [K"call"
                "svec"::K"core"
                "#self#"::K"Symbol"
                (stub_argname(n,i)::K"Symbol"(n) for (i,n) in enumerate(arg_names[2:end]))...
            ]
            [K"call"
                "svec"::K"core"
                (n.name_val::K"Symbol"(n) for n in typevar_names)...
            ]
        ]
    ]
    split_generated(ctx, body, false)
]
```

</details>

#### 2. GeneratedFunctionStub now carries expr_compat_mode and uses it to build
MacroExpansionContext/MacroContext. Expr results from generator are
converted to SyntaxTree using expr_to_syntaxtree with a LineNumberNode
derived from the stub's source reference.


**Component**: JuliaLowering/runtime

<details>
<summary>Evidence</summary>

**JuliaLowering/src/runtime.jl:290-357**
[View on GitHub](https://github.com/JuliaLang/julia/blob/eca649c6bbfcc29e90333bd6850d9b165fe19ecc/JuliaLowering/src/runtime.jl#L290-L357)
```julia
struct GeneratedFunctionStub
    expr_compat_mode::Bool
    gen::Function
    srcref::Union{SyntaxTree,LineNumberNode,SourceRef}
    argnames::Core.SimpleVector
    spnames::Core.SimpleVector
end

function (g::GeneratedFunctionStub)(world::UInt, source::Method, @nospecialize args...)
    macro_world = Base.tls_world_age()
    ctx1 = MacroExpansionContext(graph, __module__, g.expr_compat_mode, macro_world)

    layer = only(ctx1.scope_layers)

    mctx = MacroContext(syntax_graph(ctx1), g.srcref, layer, g.expr_compat_mode)
    ex0 = g.gen(mctx, args...)
    if ex0 isa Expr
        ex0 = expr_to_syntaxtree(ctx1, ex0, source_location(LineNumberNode, g.srcref))
    end
    if ex0 isa SyntaxTree
        if !is_compatible_graph(ctx1, ex0)
            ex0 = copy_ast(ctx1, ex0)
        end
    else
        ex0 = @ast ctx1 g.srcref ex0::K"Value"
    end
    ex1 = expand_forms_1(ctx1, reparent(ctx1, ex0))
    ctx1 = MacroExpansionContext(delete_attributes(graph, :__macro_ctx__),
                                 ctx1.bindings, ctx1.scope_layers,
                                 ctx1.scope_layer_stack, g.expr_compat_mode,
                                 macro_world)
    ex1 = reparent(ctx1, ex1)

    ctx2, ex2 = expand_forms_2(ctx1, ex1)
```

</details>

#### 3. to_lowered_expr now preserves LineNumberNode values by wrapping them in
QuoteNode when lowering Value nodes.


**Component**: JuliaLowering/eval

<details>
<summary>Evidence</summary>

**JuliaLowering/src/eval.jl:350-374**
[View on GitHub](https://github.com/JuliaLang/julia/blob/eca649c6bbfcc29e90333bd6850d9b165fe19ecc/JuliaLowering/src/eval.jl#L350-L374)
```julia
elseif k == K"SourceLocation"
    QuoteNode(source_location(LineNumberNode, ex))
elseif k == K"Symbol"
    QuoteNode(Symbol(ex.name_val))
elseif k == K"slot"
    Core.SlotNumber(ex.var_id)
elseif k == K"static_parameter"
    Expr(:static_parameter, ex.var_id)
elseif k == K"SSAValue"
    Core.SSAValue(ex.var_id + stmt_offset)
elseif k == K"return"
    Core.ReturnNode(_to_lowered_expr(ex[1], stmt_offset))
elseif k == K"inert"
    e1 = ex[1]
    getmeta(ex, :as_Expr, false) ? QuoteNode(Expr(e1)) : e1
elseif k == K"code_info"
    ir = to_code_info(ex[1], ex.slots, ex.meta)
    if ex.is_toplevel_thunk
        Expr(:thunk, ir)
    else
        ir
    end
elseif k == K"Value"
    ex.value isa LineNumberNode ? QuoteNode(ex.value) : ex.value
```

</details>

#### 4. IR printing now shows SourceRef values distinctly when Value nodes hold a
SourceRef, reducing huge provenance dumps for generated stubs.


**Component**: JuliaLowering/syntax_graph

<details>
<summary>Evidence</summary>

**JuliaLowering/src/syntax_graph.jl:466-505**
[View on GitHub](https://github.com/JuliaLang/julia/blob/eca649c6bbfcc29e90333bd6850d9b165fe19ecc/JuliaLowering/src/syntax_graph.jl#L466-L505)
```julia
function _value_string(ex)
    k = kind(ex)
    str = k in KSet"Identifier StrMacroName CmdMacroName" || is_operator(k) ? ex.name_val :
          k == K"Placeholder" ? ex.name_val           :
          k == K"SSAValue"    ? "%"                   :
          k == K"BindingId"   ? "#"                   :
          k == K"label"       ? "label"               :
          k == K"core"        ? "core.$(ex.name_val)" :
          k == K"top"         ? "top.$(ex.name_val)"  :
          k == K"Symbol"      ? ":$(ex.name_val)" :
          k == K"globalref"   ? "$(ex.mod).$(ex.name_val)" :
          k == K"slot"        ? "slot" :
          k == K"latestworld" ? "latestworld" :
          k == K"static_parameter" ? "static_parameter" :
          k == K"symbolic_label" ? "label:$(ex.name_val)" :
          k == K"symbolic_goto" ? "goto:$(ex.name_val)" :
          k == K"SourceLocation" ?
              "SourceLocation:$(JuliaSyntax.filename(ex)):$(join(source_location(ex), ':'))" :
          k == K"Value" && ex.value isa SourceRef ?
              "SourceRef:$(JuliaSyntax.filename(ex)):$(join(source_location(ex), ':'))" :
          repr(get(ex, :value, nothing))
    id = get(ex, :var_id, nothing)
    if isnothing(id)
        id = get(ex, :id, nothing)
    end
    if !isnothing(id)
        idstr = subscript_str(id)
        str = "$(str)$idstr"
    end
```

</details>

### Secondary Effects

#### Generated functions that return Expr now reliably enter JuliaLowering's
macro expansion and desugaring with expr_compat_mode enabled, enabling
Expr-based macro output (including raw string macros) to round-trip in
compatibility mode.


**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
expand_function_generator(...) creates GeneratedFunctionStub with ctx.expr_compat_mode
  -> GeneratedFunctionStub.call uses g.expr_compat_mode to build MacroExpansionContext
     and MacroContext before calling g.gen
  -> if generator returns Expr, expr_to_syntaxtree(ctx1, ex0, source_location(...))
     converts it to SyntaxTree for subsequent expand_forms_1/expand_forms_2
```
</details>

**Downstream Surfaces:**
- @generated functions in stdlibs using expr_compat_mode
- Macro-heavy generated functions in packages using JuliaLowering

#### IR dumps for generated-function metadata become shorter and more stable
because SourceRef values are rendered as SourceRef:filename:line ranges
instead of full green-tree provenance.


**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
_value_string(ex) recognizes K"Value" nodes with SourceRef values and emits
a compact SourceRef string, which is used by syntax tree/IR printing.
```
</details>

**Downstream Surfaces:**
- JuliaLowering.print_ir output in tests and tooling
- Debugger/IR inspection tools that display SyntaxTree values

### Compatibility

#### Internal API Changes
- **JuliaLowering.GeneratedFunctionStub.expr_compat_mode**: New boolean field added and threaded into macro expansion contexts.

#### Behavioral Changes
- Generated functions executing in expr_compat_mode now accept Expr output
and macro usage that previously failed or produced mismatched syntax trees.


### Performance

**Compile Time:**
- ESTIMATED: negligible. The new expr_to_syntaxtree conversion only runs
when generator returns an Expr; otherwise behavior is unchanged.


**Runtime:**
- None expected; changes are compile-time/lowering only.

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are localized to generated-function lowering and macro expansion contexts.
- Behavior locked in by generated-function tests running in both compat modes.

### Recommendations

- If tooling parses printed IR, update expectations for GeneratedFunctionStub fields and SourceRef formatting.
- Consider adding a dedicated test for expr_compat_mode with Expr-returning generators beyond raw string macros.
