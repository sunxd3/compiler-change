# PR #60373: `Expr`/`SyntaxTree` parity: trivial conversions

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60373
- **Merged**: 2025-12-16 23:39 UTC
- **Labels**: `JuliaLowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60373.diff

## Scope

### Files Touched
- `JuliaLowering/src/compat.jl`
- `JuliaLowering/src/kinds.jl`
- `JuliaLowering/test/compat.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering
- MacroExpansion

## Analysis

### Intent

Add trivial conversions between Expr and the new Expr-like SyntaxTree (EST)
so round-tripping is possible and future syntax-evolution steps can build on
a stable conversion layer.


### Direct Changes

#### 1. Introduce Expr -> EST conversion with explicit handling for symbols, QuoteNode, scope layers, and unknown heads.

**Component**: JuliaLowering/src/compat.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/compat.jl:633-707**
[View on GitHub](https://github.com/JuliaLang/julia/blob/1cff13010c1abd587d603c76394db6f00ef62a12/JuliaLowering/src/compat.jl#L633-L707)
```julia
function expr_to_est(@nospecialize(e), lnn::LineNumberNode=LineNumberNode(0, :none))
    graph = ensure_attributes!(
        SyntaxGraph(),
        kind=Kind, syntax_flags=UInt16,
        source=SourceAttrType, var_id=Int, value=Any,
        name_val=String, is_toplevel_thunk=Bool,
        scope_layer=LayerId, meta=CompileHints,
        toplevel_pure=Bool)
    SyntaxTree(graph, _expr_to_est(graph, e, lnn)[1])
end

function _expr_to_est(graph::SyntaxGraph, @nospecialize(e), src::LineNumberNode)
    st = if e === Core.nothing
        setattr!(makeleaf(graph, src, K"core"), :name_val, "nothing")
    elseif e isa Symbol
        setattr!(makeleaf(graph, src, K"Identifier"), :name_val, String(e))
    elseif e isa QuoteNode
        cid, _ = _expr_to_est(graph, e.value, src)
        makenode(graph, src, K"inert", NodeId[cid])
    elseif e isa Expr && e.head === :scope_layer
        @assert length(e.args) === 2 && e.args[1] isa Symbol
        ident = makeleaf(graph, src, K"Identifier")
        setattr!(ident, :name_val, String(e.args[1]))
        setattr!(ident, :scope_layer, e.args[2])
    elseif e isa Expr
        head_s = string(e.head)
        st_k = find_kind(head_s)
        old_src = _get_inner_lnn(e, src)
        cs = NodeId[]
        rm_linenodes = e.head in (:block, :toplevel)
        for arg in e.args
            if rm_linenodes && arg isa LineNumberNode
                src = arg
            else
                cid, src = _expr_to_est(graph, arg, src)
                push!(cs, cid)
            end
        end
        if isnothing(st_k)
            setattr!(makenode(graph, src, K"unknown_head", cs), :name_val, head_s)
        else
            makenode(graph, old_src, st_k, cs)
        end
    else
        @assert !isa_lowering_ast_node(e)
        if e isa LineNumberNode
            src = e
        end
        setattr!(makeleaf(graph, src, K"Value"), :value, e)
    end

    return st._id, src
end
```

</details>

#### 2. Introduce EST -> Expr conversion, including special handling for K"Value" and unknown heads.

**Component**: JuliaLowering/src/compat.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/compat.jl:709-745**
[View on GitHub](https://github.com/JuliaLang/julia/blob/1cff13010c1abd587d603c76394db6f00ef62a12/JuliaLowering/src/compat.jl#L709-L745)
```julia
function est_to_expr(st::SyntaxTree)
    k = kind(st)
    return if k === K"Identifier"
        n = Symbol(st.name_val)
        hasattr(st, :scope_layer) ? Expr(:scope_layer, n, st.scope_layer) : n
    elseif k === K"Value"
        v = st.value
        isa_lowering_ast_node(v) ? QuoteNode(v) : v
    elseif k === K"core" && numchildren(st) === 0 && st.name_val === "nothing"
        nothing
    elseif k === K"inert"
        QuoteNode(est_to_expr(st[1]))
    else
        @assert !is_leaf(st)
        head = Symbol(k === K"unknown_head" ? st.name_val : untokenize(k))
        need_lnns = head in (:block, :toplevel)
        out = Expr(head)
        for c in children(st)
            need_lnns && push!(out.args, source_location(LineNumberNode, c))
            push!(out.args, est_to_expr(c))
        end
        n = length(out.args)
        if (k === K"module" && 3 <= n <= 4 && kind(st[end]) === K"block") ||
            (k in KSet"function macro" && n === 2 && kind(st[end]) === K"block")
            pushfirst!(out.args[end].args, source_location(LineNumberNode, st))
        end
        out
    end
end
```

</details>

#### 3. Register a new extension kind (unknown_head) so EST can represent Expr heads without a known SyntaxKind.

**Component**: JuliaLowering/src/kinds.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/kinds.jl:3-28**
[View on GitHub](https://github.com/JuliaLang/julia/blob/1cff13010c1abd587d603c76394db6f00ef62a12/JuliaLowering/src/kinds.jl#L3-L28)
```julia
function _register_kinds()
    JuliaSyntax.register_kinds!(JuliaLowering, 1, [
        "BEGIN_EXTENSION_KINDS"
            "atomic"
            "generated"
            "gc_preserve"
            "gc_preserve_begin"
            "gc_preserve_end"
            "Value"
            "Symbol"
            "inert"
            "unknown_head"
            "inbounds"
            "boundscheck"
            "inline"
            "noinline"
            "loopinfo"
            "foreigncall"
            "cfunction"
            "opaque_closure"
            "isdefined"
            "throw_undef_if_not"
            "symbolic_label"
            "symbolic_goto"
            "new"
            "splatnew"
            "escape"
            "hygienic_scope"
            "static_eval"
            "extension"
        "END_EXTENSION_KINDS"
```

</details>

#### 4. Add round-trip tests for Expr<->EST, including bulk parsing and special Value quoting behavior.

**Component**: JuliaLowering/test/compat.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/test/compat.jl:636-775**
[View on GitHub](https://github.com/JuliaLang/julia/blob/1cff13010c1abd587d603c76394db6f00ef62a12/JuliaLowering/test/compat.jl#L636-L775)
```julia
@testset "Expr<->EST" begin

    local roundtrip = e->JuliaLowering.est_to_expr(JuliaLowering.expr_to_est(e))

    local expr_syntax = Any[
        LineNumberNode(1)
        :foo
        Expr(:foo, 1)
        GlobalRef(Core, :nothing)
        nothing
    ]

    @testset "special cases: Value implicitly quotes AST nodes" begin
        @test JL.est_to_expr(@ast_ :foo::K"Value") ==
            JL.est_to_expr(@ast_ [K"inert" "foo"::K"Identifier"]) ==
            QuoteNode(:foo)
    end

    @testset "bulk parsed code, no linenodes" begin
        jl_dir = joinpath(@__DIR__, "..")
        test_each_in_path(roundtrip, jl_dir)
    end

    @testset "linenodes equal (modules and functions have extra)" begin
        e = JuliaSyntax.parseall(Expr, """
        module M
        function f()
            if x
                j
            elseif y
                let
                    y
                end
            end
        end
        begin
            1
        end
        end
        """; filename="foo")

        @test e == roundtrip(e)
    end
end
```

</details>

### Secondary Effects

#### Round-tripping preserves unknown Expr heads by storing the head string in K"unknown_head" nodes.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
_expr_to_est(graph, e, src) [compat.jl:659]
  uses find_kind(head_s) [compat.jl:675]
  -> when nothing, makenode(..., K"unknown_head", cs) and setattr! :name_val [compat.jl:687-688]
est_to_expr(st) [compat.jl:709]
  -> head = Symbol(k === K"unknown_head" ? st.name_val : untokenize(k)) [compat.jl:731]
```
</details>

**Downstream Surfaces:**
- Tools that inspect SyntaxTree kinds (JuliaSyntax-based tooling, macro tools)

#### K"Value" nodes containing AST nodes now round-trip as QuoteNode to preserve quotation semantics.

**Likelihood**: medium | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
est_to_expr(st) [compat.jl:709]
  when k === K"Value", v = st.value [compat.jl:714-716]
  -> isa_lowering_ast_node(v) ? QuoteNode(v) : v [compat.jl:722]
Tests enforce Value-quoted AST behavior [test/compat.jl:677-686].
```
</details>

**Downstream Surfaces:**
- Macro tooling that embeds Expr/Symbol inside SyntaxTree values

#### Block/toplevel conversions drop embedded LineNumberNode children and re-insert them on EST->Expr conversion.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
_expr_to_est(graph, e, src) [compat.jl:659]
  rm_linenodes = e.head in (:block, :toplevel) [compat.jl:678]
  -> LineNumberNode children update src but are not converted [compat.jl:679-685]
est_to_expr(st) [compat.jl:709]
  need_lnns = head in (:block, :toplevel) [compat.jl:732]
  -> push source_location(LineNumberNode, c) before each child [compat.jl:735]
```
</details>

**Downstream Surfaces:**
- Tools that compare Expr trees with or without line nodes

### Compatibility

#### Internal API Changes
- **Kind registry extension list**: Adds K"unknown_head" to extension kinds to represent Expr heads without a known SyntaxKind.

#### Behavioral Changes
- Expr <-> SyntaxTree round-trips now normalize AST nodes embedded in K"Value" to QuoteNode in the resulting Expr.

### Performance

**Compile Time:**
- ESTIMATED: O(n) traversal per Expr<->EST conversion where n = number of AST nodes, due to recursive traversal in _expr_to_est/est_to_expr.

**Runtime:**
- No runtime execution impact; conversions are tooling/lowering utilities only.

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are additive conversion utilities and tests within JuliaLowering.
- Behavioral differences are limited to EST/Expr round-tripping, not core execution semantics.

### Recommendations

- Downstream tooling that pattern-matches on SyntaxTree kinds should add a fallback for K"unknown_head".
- When storing Expr/Symbol inside K"Value", expect est_to_expr to return QuoteNode for AST nodes, per tests.
