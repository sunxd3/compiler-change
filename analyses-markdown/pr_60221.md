# PR #60221: JuliaSyntax: fix anonymous function parsing

## Metadata

- **Author**: IanButterworth
- **URL**: https://github.com/JuliaLang/julia/pull/60221
- **Merged**: 2025-12-19 12:34 UTC
- **Labels**: `parser`, `bugfix`
- **Diff**: https://github.com/JuliaLang/julia/pull/60221.diff

## Scope

### Files Touched
- `JuliaSyntax/src/julia/parser.jl`
- `JuliaSyntax/test/parser.jl`

### Components
- JuliaSyntax

### Pipeline Stages
- Parsing

## Analysis

### Intent

Fix parsing ambiguity where a newline after a parenthesized function name/argument list was incorrectly treated as a continuation for a call or property access, ensuring anonymous function signatures parse correctly.

**Related Issues:**
- https://github.com/JuliaLang/julia/issues/60202

### Direct Changes

#### 1. When parsing a function signature that starts with parentheses, explicitly detect whether a newline immediately follows the closing `)` and avoid skipping it when deciding if the construct is a call or an anonymous-function parameter list.

**Component**: JuliaSyntax parser

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/julia/parser.jl:2211-2244**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6e246b21c8f834390e8e911fef9a0c844a7d970e/JuliaSyntax/src/julia/parser.jl#L2211-L2244)
```julia
# When an initial parenthesis is present, we need to distinguish
# between
# * The function name in parens, followed by (args...)
# * An anonymous function argument list in parens
# * The whole function declaration, in parens
bump(ps, TRIVIA_FLAG)
is_empty_tuple = peek(ps, skip_newlines=true) == K")"
opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
    _parsed_call = was_eventually_call(ps)
    _maybe_grouping_parens = !had_commas && !had_splat && num_semis == 0 && num_subexprs == 1
    # Check if there's a newline between `)` and the next `(` or `.`.
    # We need to find where `)` is and check what immediately follows it.
    # If peek(1, skip_newlines=false) is `)`, we're directly before it.
    # Otherwise there's whitespace/newline before `)`.
    next_token_pos = if peek(ps, 1, skip_newlines=false) == K")"
        # Directly before ), token after ) is at 2
        2
    else
        # There's whitespace before ), so ) is at 2
        # and what follows ) is at 3
        3
    end
    token_after_paren = peek(ps, next_token_pos, skip_newlines=false)
    # If token_after_paren is a newline, this is an anonymous function
    has_newline_after_paren = _maybe_grouping_parens && token_after_paren == K"NewlineWs"
    # Get the next significant token to determine if we need to parse a call
    next_kind = peek(ps, 2, skip_newlines=_maybe_grouping_parens && !has_newline_after_paren)
    _needs_parse_call = next_kind âˆˆ KSet"( ."
    _is_anon_func = (!_needs_parse_call && !_parsed_call) || had_commas
    return (needs_parameters      = _is_anon_func,
            is_anon_func          = _is_anon_func,
            parsed_call           = _parsed_call,
            needs_parse_call      = _needs_parse_call,
            maybe_grouping_parens = _maybe_grouping_parens)
end
```

</details>

#### 2. Add parser tests that lock in the corrected behavior for anonymous functions when a newline appears between the closing parameter paren and the function body or a following empty tuple expression.

**Component**: JuliaSyntax tests

<details>
<summary>Evidence</summary>

**JuliaSyntax/test/parser.jl:613-616**
[View on GitHub](https://github.com/JuliaLang/julia/blob/6e246b21c8f834390e8e911fef9a0c844a7d970e/JuliaSyntax/test/parser.jl#L613-L616)
```julia
"function (x) body end"=>  "(function (tuple-p x) (block body))"
"function (x)\n    body\nend"=>  "(function (tuple-p x) (block body))"
"function (x)\n() end" =>  "(function (tuple-p x) (block (tuple-p)))"
"function (x,y) end"   =>  "(function (tuple-p x y) (block))"
```

</details>

### Secondary Effects

#### Anonymous function signatures are favored when a newline directly follows a parenthesized head, preventing accidental parsing as a call or property access continuation.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
parse_resword() dispatches to parse_function_signature() for `function`  [parser.jl:1977-1981]
  -> parse_function_signature() uses parse_brackets() to inspect the parenthesized head  [parser.jl:2211-2244]
  -> token_after_paren == K"NewlineWs" gates skip_newlines=false when peeking the next token  [parser.jl:2233-2237]
  -> _needs_parse_call becomes false, so _is_anon_func becomes true  [parser.jl:2238-2240]
```
</details>

**Downstream Surfaces:**
- JuliaSyntax parse trees for function definitions
- Macro tooling or formatters that depend on JuliaSyntax AST shape

### Compatibility

#### Internal API Changes
- **JuliaSyntax parser decisions in parse_function_signature**: Now treats a newline immediately after a parenthesized head as evidence for anonymous-function parameters, altering the emitted AST for those inputs.

#### Behavioral Changes
- `function (x)
() end` and similar newline-separated forms parse as anonymous-function definitions with the expected body, rather than being interpreted as a call continuation.

### Performance

**Compile Time:**
- ESTIMATED: a couple of extra peek operations per function signature with parenthesized heads; expected negligible cost.

### Risk Assessment

**Level**: low

**Rationale:**
- Change is confined to JuliaSyntax parsing of function signatures and guarded by new tests.
- No changes to lowering, inference, or codegen stages.

### Recommendations

- Downstream parser consumers should add or update tests for newline-separated anonymous function signatures to reflect the new AST shape.
