# PR #60370: Move `SyntaxGraph`/`SyntaxTree` from JuliaLowering to JuliaSyntax

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60370
- **Merged**: 2025-12-12 20:51 UTC
- **Labels**: `JuliaLowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60370.diff

## Scope

### Files Touched
- `JuliaLowering/src/JuliaLowering.jl`
- `JuliaLowering/src/ast.jl`
- `JuliaLowering/src/compat.jl`
- `JuliaLowering/src/desugaring.jl`
- `JuliaSyntax/src/JuliaSyntax.jl`
- `JuliaSyntax/src/porcelain/syntax_graph.jl`
- `JuliaSyntax/src/porcelain/syntax_node.jl`
- `JuliaSyntax/test/runtests.jl`
- `JuliaSyntax/test/syntax_graph.jl`
- `JuliaSyntax/test/syntax_node.jl`

### Components
- JuliaSyntax
- JuliaLowering

### Pipeline Stages
- Parsing
- ASTDataStructures

## Analysis

### Intent

Move the ECS-style SyntaxGraph/SyntaxTree infrastructure and related helpers/tests from JuliaLowering into JuliaSyntax, clarifying the distinction between SyntaxNode and SyntaxTree while keeping JuliaLowering functionality wired through JuliaSyntax.

### Direct Changes

#### 1. Defines SyntaxGraph and SyntaxTree in JuliaSyntax porcelain, documenting SyntaxTree as an unstable ECS-style AST and providing core graph/attribute machinery there.

**Component**: JuliaSyntax/porcelain

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/porcelain/syntax_graph.jl:1-199**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/src/porcelain/syntax_graph.jl#L1-L199)
```julia
"""
Directed graph with arbitrary attributes on nodes. Used here for representing
one or several syntax trees.

TODO: Global attributes!
"""
mutable struct SyntaxGraph{Attrs}
    edge_ranges::Vector{UnitRange{Int}}
    edges::Vector{NodeId}
    attributes::Attrs
end

SyntaxGraph() = SyntaxGraph{Dict{Symbol,Any}}(Vector{UnitRange{Int}}(),
                                              Vector{NodeId}(), Dict{Symbol,Any}())

"""
    struct SyntaxTree

An ECS-style AST used in JuliaLowering.  Unstable, but may eventually replace
SyntaxNode.
"""
struct SyntaxTree{GraphType}
    _graph::GraphType
    _id::NodeId
end
```

</details>

#### 2. JuliaLowering now imports SyntaxGraph/SyntaxTree and related helpers directly from JuliaSyntax, relying on JuliaSyntax-provided constructors and traversal utilities.

**Component**: JuliaLowering

<details>
<summary>Evidence</summary>

**JuliaLowering/src/JuliaLowering.jl:15-28**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaLowering/src/JuliaLowering.jl#L15-L28)
```julia
using .JuliaSyntax: highlight, Kind, @KSet_str, is_leaf, children, numchildren,
    head, kind, flags, has_flags, filename, first_byte, last_byte, byte_range,
    sourcefile, source_location, span, sourcetext, is_literal, is_infix_op_call,
    is_postfix_op_call, @isexpr, SyntaxHead, is_syntactic_operator,
    SyntaxGraph, SyntaxTree, SyntaxList, NodeId, SourceRef, SourceAttrType,
    ensure_attributes, ensure_attributes!, delete_attributes, newnode!, hasattr,
    setattr, setattr!, syntax_graph, is_compatible_graph,
    check_compatible_graph, copy_node, copy_ast, provenance, sourceref,
    reparent, makeleaf, makenode, mapchildren, mapleaf, flattened_provenance
```

**JuliaSyntax/src/porcelain/syntax_graph.jl:570-615**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/src/porcelain/syntax_graph.jl#L570-L615)
```julia
#-------------------------------------------------------------------------------
# AST creation utilities

# TODO: "proto", if SyntaxTree, is rarely different from srcref. reorganize to:
# newnode/newleaf(ctx, srcref, k::Kind[, attrs])
# makenode/makeleaf(ctx, old::SyntaxTree[, attrs])

_node_id(graph::SyntaxGraph, ex::SyntaxTree) = (check_compatible_graph(graph, ex); ex._id)

function makeleaf(graph::SyntaxGraph, srcref, proto::Union{Kind, SyntaxTree})
    id = newnode!(graph)
    ex = SyntaxTree(graph, id)
    copy_attrs!(ex, proto, true)
    ex.source = _unpack_srcref(graph, srcref)
    return ex
end

function makenode(ctx, srcref, proto, children, attrs=nothing)
    graph = syntax_graph(ctx)
    ex = isnothing(attrs) ? makeleaf(graph, srcref, proto) :
        makeleaf(graph, srcref, proto, attrs)
    setchildren!(graph, ex._id, children isa SyntaxList ? children.ids : children)
    return ex
end
```

</details>

#### 3. JuliaLowering supplies SyntaxTree-to-Expr conversion hooks by overriding JuliaSyntax leaf/child fixups and routing Base.Expr to JuliaSyntax.to_expr.

**Component**: JuliaLowering/compat

<details>
<summary>Evidence</summary>

**JuliaLowering/src/compat.jl:591-628**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaLowering/src/compat.jl#L591-L628)
```julia
function JuliaSyntax._expr_leaf_val(ex::SyntaxTree, _...)
    name = get(ex, :name_val, nothing)
    if !isnothing(name)
        n = Symbol(name)
        if kind(ex) === K"Symbol"
            return QuoteNode(n)
        elseif hasattr(ex, :scope_layer)
            Expr(:scope_layer, n, ex.scope_layer)
        else
            n
        end
    else
        val = get(ex, :value, nothing)
        if kind(ex) == K"Value" && val isa Expr || val isa LineNumberNode
            # Expr AST embedded in a SyntaxTree should be quoted rather than
            # becoming part of the output AST.
            QuoteNode(val)
        else
            val
        end
    end
end

function JuliaSyntax.fixup_Expr_child(::Type{<:SyntaxTree}, head::SyntaxHead,
                                      @nospecialize(arg), first::Bool)
    isa(arg, Expr) || return arg
    k = kind(head)
    coalesce_dot = k in KSet"call dotcall curly" ||
                   (k == K"quote" && has_flags(head, JuliaSyntax.COLON_QUOTE))
    if @isexpr(arg, :., 1) && arg.args[1] isa Tuple
        h, a = arg.args[1]::Tuple{SyntaxHead,Any}
        arg = ((coalesce_dot && first) || is_syntactic_operator(h)) ?
            Symbol(".", a) : Expr(:., a)
    end
    return arg
end

Base.Expr(ex::SyntaxTree) = JuliaSyntax.to_expr(ex)
```

**JuliaSyntax/src/integration/expr.jl:220-261**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/src/integration/expr.jl#L220-L261)
```julia
_expr_leaf_val(node::SyntaxNode, _...) = node.val
_expr_leaf_val(cursor::RedTreeCursor, txtbuf::Vector{UInt8}, txtbuf_offset::UInt32) =
    parse_julia_literal(txtbuf, head(cursor), byte_range(cursor) .+ txtbuf_offset)
# Extended in JuliaLowering to support `node_to_expr(::SyntaxTree, ...)`

function node_to_expr(cursor, source, txtbuf::Vector{UInt8}, txtbuf_offset::UInt32=UInt32(0))
    if !should_include_node(cursor)
        return nothing
    end

    nodehead = head(cursor)
    k = kind(cursor)
    srcrange::UnitRange{UInt32} = byte_range(cursor)
    if is_leaf(cursor)
        if is_error(k)
            return k == K"error" ?
                Expr(:error) :
                Expr(:error, "$(_token_error_descriptions[k]): `$(source[srcrange])`")
        elseif k == K"VERSION"
            nv = numeric_flags(flags(nodehead))
            return VersionNumber(1, nv ÷ 10, nv % 10)
        else
            scoped_val = _expr_leaf_val(cursor, txtbuf, txtbuf_offset)
            val = @isexpr(scoped_val, :scope_layer) ? scoped_val.args[1] : scoped_val
            if val isa Union{Int128,UInt128,BigInt}
                str = replace(source[srcrange], '_'=>"")
                macname = val isa Int128  ? Symbol("@int128_str")  :
                        val isa UInt128 ? Symbol("@uint128_str") :
                        Symbol("@big_str")
                return Expr(:macrocall, GlobalRef(Core, macname), nothing, str)
            elseif is_identifier(k)
                val2 = lower_identifier_name(val, k)
                return @isexpr(scoped_val, :scope_layer) ?
                    Expr(:scope_layer, val2, scoped_val.args[2]) : val2
            else
                return scoped_val
            end
        end
    end
```

**rg output:fixup_Expr_child**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/src/integration/expr.jl#L148)
```julia
JuliaSyntax/src/integration/expr.jl
148:function fixup_Expr_child(::Type, head::SyntaxHead, @nospecialize(arg), first::Bool)

JuliaLowering/src/compat.jl
614:function JuliaSyntax.fixup_Expr_child(::Type{<:SyntaxTree}, head::SyntaxHead,
```

</details>

#### 4. SyntaxGraph/SyntaxTree tests now live under JuliaSyntax and are only run for VERSION >= v"1.12", with parsing/error and copy_ast behavior asserted there.

**Component**: JuliaSyntax/tests

<details>
<summary>Evidence</summary>

**JuliaSyntax/test/runtests.jl:18-24**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/test/runtests.jl#L18-L24)
```julia
include("parse_stream.jl")
include("parser.jl")
include("green_node.jl")
include("syntax_node.jl")
if VERSION >= v"1.12"
    include("syntax_graph.jl")
end
```

**JuliaSyntax/test/syntax_graph.jl:45-101**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/test/syntax_graph.jl#L45-L101)
```julia
@testset "SyntaxTree parsing" begin
    # Errors should fall through
    @test parsestmt(SyntaxTree, "@"; ignore_errors=true) isa SyntaxTree
    @test parsestmt(SyntaxTree, "@@@"; ignore_errors=true) isa SyntaxTree
    @test parsestmt(SyntaxTree, "(a b c)"; ignore_errors=true) isa SyntaxTree
    @test parsestmt(SyntaxTree, "'a b c'"; ignore_errors=true) isa SyntaxTree
end

@testset "SyntaxTree utils" begin
    "For filling required attrs in graphs created by hand"
    function testgraph(edge_ranges, edges, more_attrs...)
        kinds = Dict(map(i->(i=>K"block"), eachindex(edge_ranges)))
        sources = Dict(map(i->(i=>LineNumberNode(i)), eachindex(edge_ranges)))
        SyntaxGraph(
            edge_ranges,
            edges,
            Dict(:kind => kinds, :source => sources, more_attrs...))
    end

    @testset "copy_ast" begin
        g = testgraph([1:1, 2:2, 0:-1, 3:3, 4:4, 0:-1, 5:5, 6:6, 0:-1],
                      [2, 3, 5, 6, 8, 9],
                      :source => Dict(enumerate([
                          map(i->i+3, 1:6)...
                          map(LineNumberNode, 7:9)...])))
        st = SyntaxTree(g, 1)
        stcopy = copy_ast(g, st)
        @test length(g.edge_ranges) === 18
        @test st._id != stcopy._id
        @test st ≈ stcopy
        @test st.source !== stcopy.source
        @test st.source[1] !== stcopy.source[1]
        @test st.source[1][1] !== stcopy.source[1][1]

        stcopy2 = copy_ast(g, st; copy_source=false)
        @test length(g.edge_ranges) === 21
        @test st._id != stcopy2._id
        @test st ≈ stcopy2
        @test st.source === stcopy2.source
        @test st.source[1] === stcopy2.source[1]
        @test st.source[1][1] === stcopy2.source[1][1]

        new_g = ensure_attributes!(SyntaxGraph(); attrdefs(g)...)
        stcopy3 = copy_ast(new_g, st)
        @test length(new_g.edge_ranges) === 9
        @test st ≈ stcopy3

        new_g = ensure_attributes!(SyntaxGraph(); attrdefs(g)...)
        @test_throws ErrorException copy_ast(new_g, st; copy_source=false)
    end
end
```

</details>

### Secondary Effects

#### Downstream tooling that previously reached for JuliaLowering.SyntaxGraph/SyntaxTree will need to import these definitions from JuliaSyntax (or rely on any re-exports), since the owning module is now JuliaSyntax porcelain.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
JuliaLowering loads SyntaxGraph/SyntaxTree utilities from JuliaSyntax  [JuliaLowering.jl:15-23]
  -> SyntaxGraph/SyntaxTree are now defined in JuliaSyntax porcelain  [syntax_graph.jl:1-199]
  -> JuliaSyntax includes syntax_graph.jl only on VERSION >= v"1.12"  [JuliaSyntax.jl:99-105]
```
</details>

**Downstream Surfaces:**
- JuliaLowering internal consumers importing SyntaxGraph/SyntaxTree
- Downstream packages (AST tooling) that used JuliaLowering.SyntaxTree
- JuliaSyntax-based parsing utilities when running on 1.12+

#### SyntaxTree-to-Expr conversion now hinges on JuliaSyntax.to_expr with SyntaxTree-specific overrides, which can affect how dot calls and scope layers are reconstructed for tooling that converts SyntaxTree back to Expr.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
Base.Expr(ex::SyntaxTree) calls JuliaSyntax.to_expr(ex)  [compat.jl:628]
  -> to_expr(...) uses fixup_Expr_child(typeof(node), ...) for wrapper handling  [integration/expr.jl:690-696]
  -> JuliaSyntax.fixup_Expr_child(::Type{<:SyntaxTree}, ...) overrides dot/quote fixups  [compat.jl:614-626]
  -> node_to_expr(...) calls _expr_leaf_val(...) to extract leaf values  [integration/expr.jl:225-245]
  -> JuliaSyntax._expr_leaf_val(::SyntaxTree, ...) overrides symbol/Value handling  [compat.jl:591-611]
```
</details>

**Downstream Surfaces:**
- Macro tools that call Base.Expr(::SyntaxTree)
- JuliaLowering @SyntaxTree macro expansions that round-trip through Expr

### Compatibility

#### Internal API Changes
- **JuliaSyntax.SyntaxGraph / JuliaSyntax.SyntaxTree**: Ownership moved into JuliaSyntax porcelain (loaded conditionally for VERSION >= v"1.12"), while JuliaLowering now imports these APIs rather than defining them locally.

#### Behavioral Changes
- SyntaxTree parsing error tolerance and copy_ast behavior are now validated in JuliaSyntax's test suite (1.12+), preserving existing behavior after the move.

### Performance

**Compile Time:**
- ESTIMATED: No material compile-time impact; this PR primarily relocates code without altering algorithms.

**Runtime:**
- ESTIMATED: No runtime performance change expected; behavior is code movement and API re-homing.

### Risk Assessment

**Level**: low

**Rationale:**
- Change is mostly code motion and namespace adjustments; functional behavior is locked in by ported tests.
- Potential for minor API breakage if downstream tooling imported JuliaLowering.SyntaxGraph/SyntaxTree without updating imports.

### Recommendations

- Downstream tooling should import SyntaxGraph/SyntaxTree from JuliaSyntax and guard on VERSION >= v"1.12" if needed.
- Add release notes highlighting the module move for any external users of SyntaxTree/SyntaxGraph APIs.
