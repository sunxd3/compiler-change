# PR #60170: [JuliaLowering] Reconstruct macro name before, not during, macro expansion

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60170
- **Merged**: 2025-12-04 21:30 UTC
- **Labels**: `compiler:lowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60170.diff

## Scope

### Files Touched
- `JuliaLowering/src/ast.jl`
- `JuliaLowering/src/compat.jl`
- `JuliaLowering/src/macro_expansion.jl`
- `JuliaLowering/src/syntax_graph.jl`
- `JuliaLowering/test/compat.jl`
- `JuliaLowering/test/macros.jl`
- `JuliaLowering/test/macros_ir.jl`
- `JuliaLowering/test/utils.jl`
- `test/JuliaLowering_stdlibs.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Parsing
- Lowering
- MacroExpansion

## Analysis

### Intent

Move macro-name reconstruction into SyntaxGraph lowering so macro expansion sees identifiers (e.g., @mac) directly, simplifying macro name handling and fixing edge cases like @__dot__ and @static in @preserve.

**Related Issues:**
- https://github.com/JuliaLang/JuliaLowering.jl/issues/121

### Direct Changes

#### 1. Convert macro-name nodes (macro_name / StrMacroName / CmdMacroName) into K"Identifier" with @-prefixed name_val during green->AST conversion, including dotted macro paths.

**Component**: JuliaLowering/src/syntax_graph.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/syntax_graph.jl:889-906**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/syntax_graph.jl#L889-L906)
```julia
elseif k === K"CmdMacroName" || k === K"StrMacroName"
    name = lower_identifier_name(ex.name_val, k)
    setattr!(makeleaf(graph, ex, K"Identifier"),
             :name_val, name)
elseif k === K"macro_name"
    # M.@x parses to (. M (macro_name x))
    # @M.x parses to (macro_name (. M x))
    # We want (. M @x) (both identifiers) in either case
    @assert numchildren(ex) === 2 && kind(ex[1]) === K"@"
    id = ex[2]
    mname_raw = (kind(id) === K"." ? id[2] : id).name_val
    mac_id = setattr!(makeleaf(graph, ex, K"Identifier"), :name_val,
                      lower_identifier_name(mname_raw, K"macro_name"))
    if kind(id) === K"."
        makenode(graph, ex, ex, NodeId[id[1]._id, mac_id._id])
    else
        mac_id
    end
```

</details>

#### 2. Macro expansion now operates on the reconstructed identifier directly (no fixup pass) and builds cmdstring macrocalls with @cmd identifiers.

**Component**: JuliaLowering/src/macro_expansion.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/macro_expansion.jl:155-183**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/macro_expansion.jl#L155-L183)
```julia
function eval_macro_name(ctx::MacroExpansionContext, mctx::MacroContext, ex0::SyntaxTree)
    mod = current_layer(ctx).mod
    ex = expand_forms_1(ctx, ex0)
    try
        if kind(ex) === K"Value"
            !(ex.value isa GlobalRef) ? ex.value :
                Base.invoke_in_world(ctx.macro_world, getglobal,
                                     ex.value.mod, ex.value.name)
        elseif kind(ex) === K"Identifier"
            layer = get(ex, :scope_layer, nothing)
            if !isnothing(layer)
                mod = ctx.scope_layers[layer].mod
            end
            Base.invoke_in_world(ctx.macro_world, getproperty,
                                 mod, Symbol(ex.name_val))
        elseif kind(ex) === K"." &&
                (ed = _eval_dot(ctx.macro_world, mod, ex); !isnothing(ed))
            ed
        else
            ctx2, ex2 = expand_forms_2(ctx, ex)
            ctx3, ex3 = resolve_scopes(ctx2, ex2)
            ctx4, ex4 = convert_closures(ctx3, ex3)
            ctx5, ex5 = linearize_ir(ctx4, ex4)
            expr_form = to_lowered_expr(ex5)
            ccall(:jl_toplevel_eval, Any, (Any, Any), mod, expr_form)
        end
    catch err
        throw(MacroExpansionError(mctx, ex, "Macro not found", :all, err))
    end
end
```

**JuliaLowering/src/macro_expansion.jl:488-491**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/macro_expansion.jl#L488-L491)
```julia
elseif k == K"cmdstring"
    @chk numchildren(ex) == 1
    e2 = @ast ctx ex [K"macrocall" "@cmd"::K"core" ex[1]]
    expand_macro(ctx, e2)
```

</details>

#### 3. Compat Expr->SyntaxTree conversion treats macrocall names as @-prefixed identifiers, including @__dot__ rewriting and do-block macrocalls without wrapping a macro_name node.

**Component**: JuliaLowering/src/compat.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/compat.jl:262-274**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/compat.jl#L262-L274)
```julia
elseif e.head === :macrocall
    @assert nargs >= 2
    a1,a1_esc = unwrap_esc(e.args[1])
    child_exprs = collect_expr_parameters(e, 3)
    if child_exprs[2] isa LineNumberNode
        src = child_exprs[2]
    end
    deleteat!(child_exprs, 2)
    if a1 isa Symbol && a1 === Symbol("@__dot__")
        child_exprs[1] = Symbol("@.")
    elseif a1 isa Expr && nargs === 2 && a1.args[2] === Symbol("@__dot__")
        child_exprs[1] = Expr(a1.head, a1.args[1], Symbol("@."))
    elseif a1 isa GlobalRef && a1.mod === Core
        # Syntax-introduced macrocalls are listed here for reference.  We
        # probably don't need to convert these.
        if a1.name === Symbol("@cmd")
        elseif a1.name === Symbol("@doc") && nargs === 4 # two macro args only
            # Single-arg @doc is a lookup not corresponding to K"doc"
            # Revise sometimes calls @doc with three args, but probably shouldn't
            st_k = K"doc"
            child_exprs = child_exprs[2:3]
```

**JuliaLowering/src/compat.jl:406-422**
[View on GitHub](https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/compat.jl#L406-L422)
```julia
elseif e.head === :do
    # Expr:
    # (do (call f args...) (-> (tuple lam_args...) (block ...)))
    # SyntaxTree:
    # (call f args... (do (tuple lam_args...) (block ...)))
    if e.args[1].head === :macrocall
        st_k = K"macrocall"
        callargs = collect_expr_parameters(e.args[1], 3)
        if callargs[2] isa LineNumberNode
            src = callargs[2]
        end
        deleteat!(callargs, 2)
    else
        callargs = collect_expr_parameters(e.args[1], 2)
        st_k = K"call"
    end
    child_exprs = Any[callargs..., Expr(:do_lambda, e.args[2].args...)]
```

</details>

### Secondary Effects

#### Macrocall names now carry the '@' prefix as identifiers throughout the SyntaxTree, which changes match patterns for utilities that search for specific macros (e.g., @SyntaxTree, @ast_).

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
_green_to_ast() converts K"macro_name"/K"StrMacroName"/K"CmdMacroName" into K"Identifier" with @-prefixed name_val  [syntax_graph.jl:889-906]
-> expand_forms_1() operates on the identifier directly during macro expansion  [macro_expansion.jl:155-183]
-> _find_SyntaxTree_macro() now matches name.name_val == "@SyntaxTree" instead of "SyntaxTree"  [syntax_graph.jl:576-593]
-> format_ir_for_test() special-cases @ast_ by checking for Identifier "@ast_"  [test/utils.jl:167-175]
```
</details>

**Downstream Surfaces:**
- JuliaLowering SyntaxTree utilities (macro search and test harnesses)
- Tools pattern-matching SyntaxTree kinds for macro names

#### Expr compatibility lowering emits macrocall nodes that contain escaped @-prefixed identifiers (instead of K"macro_name" nodes), changing legacy macrocall shape accepted by expr_to_syntaxtree.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
_insert_convert_expr() handles Expr(:macrocall, ...) by directly rewriting @__dot__ and leaving macro name as an identifier  [compat.jl:262-274]
-> tests assert escaped macro names appear as K"Identifier" "@mac" in the SyntaxTree  [test/compat.jl:494-608]
```
</details>

**Downstream Surfaces:**
- Legacy macro producers emitting Expr(:macrocall, ...)
- Downstream AST transforms that expect K"macro_name" wrappers

### Compatibility

#### Internal API Changes
- **SyntaxTree node kinds for macro names**: K"macro_name"/K"StrMacroName"/K"CmdMacroName" are normalized to K"Identifier" with @-prefixed name_val during SyntaxGraph lowering.

#### Behavioral Changes
- Expr-to-SyntaxTree compatibility now expects escaped macro names to appear as @-prefixed identifiers (e.g., "@mac") rather than K"macro_name" wrappers.

### Performance

### Risk Assessment

**Level**: medium

**Rationale:**
- Macro name nodes are normalized earlier, which can break downstream SyntaxTree pattern matching in tooling that relied on K"macro_name"/StrMacroName/CmdMacroName nodes.
- Changes affect macro expansion hygiene and compat lowering paths that are widely exercised (macrocalls, @__dot__, @cmd).

### Recommendations

- Update downstream SyntaxTree visitors to treat macro names as K"Identifier" with '@' prefix, including dotted macro paths.
- Audit macro-related utilities for string comparisons to ensure they match '@macro' names (e.g., @SyntaxTree, @ast_).
- When converting Expr(:macrocall, ...) in tooling, avoid reintroducing K"macro_name" nodes; use identifiers to align with the new lowering pipeline.
