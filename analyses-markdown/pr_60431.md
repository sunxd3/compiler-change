# PR #60431: Document and further clean up node creation functions

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60431
- **Merged**: 2025-12-26 17:19 UTC
- **Labels**: `JuliaLowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60431.diff

## Scope

### Files Touched
- `JuliaLowering/src/JuliaLowering.jl`
- `JuliaLowering/src/ast.jl`
- `JuliaLowering/src/bindings.jl`
- `JuliaLowering/src/closure_conversion.jl`
- `JuliaLowering/src/compat.jl`
- `JuliaLowering/src/desugaring.jl`
- `JuliaLowering/src/runtime.jl`
- `JuliaLowering/src/scope_analysis.jl`
- `JuliaLowering/test/compat.jl`
- `JuliaLowering/test/macros.jl`
- `JuliaLowering/test/scopes.jl`
- `JuliaLowering/test/utils.jl`
- `JuliaSyntax/src/porcelain/syntax_graph.jl`

### Components
- JuliaSyntax
- JuliaLowering

### Pipeline Stages
- Parsing
- MacroExpansion
- Lowering

## Analysis

### Intent

Split AST node creation into explicit new-vs-copy operations, document provenance semantics, and tighten JuliaLowering node-construction APIs.

### Direct Changes

#### 1. Introduce explicit node constructors in JuliaSyntax: newnode/newleaf for fresh provenance and mknode/mkleaf for immutable updates that copy attributes and set :source to the original node id.

**Component**: JuliaSyntax

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/porcelain/syntax_graph.jl:577-616**
[View on GitHub](https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaSyntax/src/porcelain/syntax_graph.jl#L577-L616)
```julia
"""
    newnode(graph::SyntaxGraph, prov::SourceAttrType, k::Kind, children)

Add a new node to `graph` with reference to parsed source text `prov`.
"""
function newnode(graph::SyntaxGraph, prov::SourceAttrType, k::Kind, children)
    st = newleaf(graph, prov, k)
    setchildren!(graph, st._id, children)
    return st
end
function newleaf(graph::SyntaxGraph, prov::SourceAttrType, k::Kind)
    st = SyntaxTree(graph, new_id!(graph))
    setattr!(st, :kind, k)
    setattr!(st, :source, prov)
end

newnode(graph::SyntaxGraph, prov::SyntaxTree, k::Kind, children) =
    newnode(graph, prov._id, k, children)

newleaf(graph::SyntaxGraph, prov::SyntaxTree, k::Kind) =
    newleaf(graph, prov._id, k)

"""
    mknode(old::SyntaxTree, children)

Create a node in `old`'s graph that is an immutable update of `old`, but setting
`old` as its provenance.  This is the main operation used by syntax
transformations such as lowering.
"""
function mknode(old::SyntaxTree, children)
    st = mkleaf(old)
    setchildren!(st._graph, st._id, children)
    return st
end
function mkleaf(old::SyntaxTree)
    graph = syntax_graph(old)
    st = SyntaxTree(graph, new_id!(graph))
    copy_attrs!(st, old, true)
    setattr!(st, :source, old._id)
end
```

</details>

#### 2. JuliaLowering now re-exports the new node APIs and uses them in helpers like newleaf/newnode wrappers and SSA assignment generation (tree_ids helper).

**Component**: JuliaLowering

<details>
<summary>Evidence</summary>

**JuliaLowering/src/JuliaLowering.jl:15-24**
[View on GitHub](https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering/src/JuliaLowering.jl#L15-L24)
```julia
using .JuliaSyntax: highlight, Kind, @KSet_str, is_leaf, children, numchildren,
    head, kind, flags, has_flags, filename, first_byte, last_byte, byte_range,
    sourcefile, source_location, span, sourcetext, is_literal, is_infix_op_call,
    is_postfix_op_call, @isexpr, SyntaxHead, is_syntactic_operator,
    SyntaxGraph, SyntaxTree, SyntaxList, NodeId, SourceRef, SourceAttrType,
    ensure_attributes, ensure_attributes!, delete_attributes, new_id!, hasattr,
    setattr, setattr!, syntax_graph, is_compatible_graph,
    check_compatible_graph, copy_node, copy_ast, provenance, sourceref,
    reparent, mapchildren, flattened_provenance, mkleaf, mknode, newleaf,
    newnode, tree_ids
```

**JuliaLowering/src/ast.jl:93-151**
[View on GitHub](https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering/src/ast.jl#L93-L151)
```julia
function JuliaSyntax.newleaf(ctx::AbstractLoweringContext,
                    prov::Union{SyntaxTree, SourceAttrType},
                    k::Kind)
    newleaf(syntax_graph(ctx), prov, k)
end

function JuliaSyntax.newleaf(ctx, prov, k, @nospecialize(value))
    leaf = newleaf(ctx, prov, k)
    if k == K"Identifier" || k == K"core" || k == K"top" || k == K"Symbol" ||
            k == K"globalref" || k == K"Placeholder"
        setattr!(leaf._graph, leaf._id, :name_val, value)
    elseif k == K"BindingId"
        setattr!(leaf._graph, leaf._id, :var_id, value)
    elseif k == K"label"
        setattr!(leaf._graph, leaf._id, :id, value)
    elseif k == K"symbolic_label"
        setattr!(leaf._graph, leaf._id, :name_val, value)
    elseif k in KSet"TOMBSTONE SourceLocation latestworld latestworld_if_toplevel
                     softscope"
        # no attributes
    else
        val = k == K"Integer" ? convert(Int,     value) :
              k == K"Float"   ? convert(Float64, value) :
              k == K"String"  ? convert(String,  value) :
              k == K"Char"    ? convert(Char,    value) :
              k == K"Value"   ? value                   :
              k == K"Bool"    ? value                   :
              k == K"VERSION" ? value                   :
              error("Unexpected leaf kind `$k`")
        setattr!(leaf._graph, leaf._id, :value, val)
    end
    leaf
end

JuliaSyntax.newnode(ctx::AbstractLoweringContext,
                    prov::Union{SyntaxTree, SourceAttrType},
                    k::Kind, cs) =
    newnode(syntax_graph(ctx), prov, k, cs)

function assign_tmp(ctx::AbstractLoweringContext, ex, name="tmp")
    var = ssavar(ctx, ex, name)
    assign_var = newnode(ctx, ex, K"=", tree_ids(var, ex))
    var, assign_var
end

function emit_assign_tmp(stmts::SyntaxList, ctx, ex, name="tmp")
    if is_ssa(ctx, ex)
        return ex
    end
    var = ssavar(ctx, ex, name)
    push!(stmts, newnode(ctx, ex, K"=", tree_ids(var, ex)))
    var
end
```

</details>

#### 3. Macro expansion and generated-function support now use mknode/copy_node plus explicit :source updates, and GeneratedFunctionStub srcref is constrained to LineNumberNode/SourceRef while non-Expr output is wrapped with newleaf.

**Component**: JuliaLowering

<details>
<summary>Evidence</summary>

**JuliaLowering/src/macro_expansion.jl:363-376**
[View on GitHub](https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering/src/macro_expansion.jl#L363-L376)
```julia
# Add a secondary source of provenance to each expression in the tree `ex`.
function append_sourceref(ctx, ex, secondary_prov)
    srcref = (ex, secondary_prov)
    out = if !is_leaf(ex)
        if kind(ex) == K"macrocall"
            copy_node(ex)
        else
            cs = map(e->append_sourceref(ctx, e, secondary_prov)._id, children(ex))
            mknode(ex, cs)
        end
    else
        copy_node(ex)
    end
    setattr!(out, :source, _unpack_srcref(syntax_graph(ctx), srcref))
end
```

**JuliaLowering/src/runtime.jl:292-346**
[View on GitHub](https://github.com/JuliaLang/julia/blob/7b92a2aa070bb4a15f9ec71292770737718206da/JuliaLowering/src/runtime.jl#L292-L346)
```julia
struct GeneratedFunctionStub
    expr_compat_mode::Bool
    gen::Function
    srcref::Union{LineNumberNode,SourceRef}
    argnames::Core.SimpleVector
    spnames::Core.SimpleVector
end

function (g::GeneratedFunctionStub)(world::UInt, source::Method, @nospecialize args...)
    graph = ensure_attributes(SyntaxGraph(), kind=Kind, syntax_flags=UInt16, source=SourceAttrType,
                              value=Any, name_val=String)
    graph = ensure_attributes(ensure_macro_attributes(graph),
                              is_toplevel_thunk=Bool,
                              toplevel_pure=Bool,
                              )

    __module__ = source.module

    macro_world = Base.tls_world_age()
    ctx1 = MacroExpansionContext(graph, __module__, g.expr_compat_mode, macro_world)

    layer = only(ctx1.scope_layers)

    mctx = MacroContext(syntax_graph(ctx1), g.srcref, layer, g.expr_compat_mode)
    ex0 = g.gen(mctx, args...)
    if ex0 isa Expr
        ex0 = expr_to_syntaxtree(ctx1, ex0, source_location(LineNumberNode, g.srcref))
    end
    if ex0 isa SyntaxTree
        if !is_compatible_graph(ctx1, ex0)
            ex0 = copy_ast(ctx1, ex0)
        end
    else
        ex0 = newleaf(syntax_graph(ctx1), g.srcref, K"Value", ex0)
    end
```

</details>

### Secondary Effects

#### AST provenance for macro-expanded trees is now explicitly rebuilt via copy_node/mknode and then re-stamped with a tuple source, which can change how downstream tools interpret :source as either a parsed span or a transformed-node reference.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
append_sourceref(ctx, ex, secondary_prov)  [JuliaLowering/src/macro_expansion.jl:363-376]
  -> mknode(ex, cs) for non-macrocall nodes
  -> mkleaf(old) copies attrs and sets :source = old._id  [JuliaSyntax/src/porcelain/syntax_graph.jl:606-616]
  -> append_sourceref then overwrites :source with _unpack_srcref((ex, secondary_prov))
```
</details>

**Downstream Surfaces:**
- Macro-expansion provenance for tooling that inspects :source / provenance
- SyntaxTree copying during macro interpolation

#### Generated-function macro context now guarantees srcref is LineNumberNode/SourceRef and wraps non-Expr generator outputs as K"Value" leaves, which could affect custom generators that expected a SyntaxTree srcref.

**Likelihood**: low | **Impact**: low

<details>
<summary>Mechanism</summary>

```
GeneratedFunctionStub.srcref is narrowed to Union{LineNumberNode,SourceRef}  [JuliaLowering/src/runtime.jl:292-298]
-> MacroContext(syntax_graph(ctx1), g.srcref, layer, g.expr_compat_mode)
-> non-Expr generator output is wrapped via newleaf(..., K"Value", ex0)  [JuliaLowering/src/runtime.jl:335-346]
```
</details>

**Downstream Surfaces:**
- @generated function expansion
- MacroContext consumers in generated-function paths

### Compatibility

#### Internal API Changes
- **Field**: Node-id allocator renamed and re-exported from JuliaLowering for node construction utilities.
- **Field**: Node construction split between fresh-provenance creation and immutable updates that copy attributes.
- **Field**: srcref is now Union{LineNumberNode,SourceRef} instead of allowing SyntaxTree.

#### Behavioral Changes
- Tests now pass a concrete graph and SyntaxTree srcref into @ast, reflecting the stricter srcref typing and new constructors.

### Performance

**Compile Time:**
- ESTIMATED: neutral; node creation now uses new_id! and explicit constructors, but no new passes or extra traversals are introduced.

**Runtime:**
- ESTIMATED: neutral; changes are structural API refactors without new runtime logic in hot paths.

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are primarily API refactors and provenance bookkeeping updates with targeted test adjustments.

### Recommendations

- Audit downstream compiler tooling for direct uses of makeleaf/makenode/newnode! and migrate to newnode/newleaf/mknode/mkleaf/new_id!.
- If custom macro or generated-function code passes srcref values, ensure they are SourceRef/LineNumberNode or SyntaxTree as required by @ast and MacroContext.
