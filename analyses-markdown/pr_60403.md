# PR #60403: JuliaSyntax:force specialize on function in `parse_brackets`

## Metadata

- **Author**: KristofferC
- **URL**: https://github.com/JuliaLang/julia/pull/60403
- **Merged**: 2025-12-17 17:56 UTC
- **Labels**: `backport 1.12`, `backport 1.13`
- **Diff**: https://github.com/JuliaLang/julia/pull/60403.diff

## Scope

### Files Touched
- `JuliaSyntax/src/julia/parser.jl`

### Components
- JuliaSyntax

### Pipeline Stages
- Parsing

## Analysis

### Intent

Force specialization on the `after_parse` callable passed to `parse_brackets` so bracket parsing avoids heuristic despecialization (notably when default-argument wrappers call into the parser), reducing REPL lag after heavy package loads.

### Direct Changes

#### 1. `parse_brackets` now uses a parametric callable type for `after_parse`, enabling specialization on the specific closure passed by each caller.

**Component**: JuliaSyntax parser

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/julia/parser.jl:3192-3199**
[View on GitHub](https://github.com/JuliaLang/julia/blob/b34261b5d099153c7d454588332f822ddcb12ea9/JuliaSyntax/src/julia/parser.jl#L3192-L3199)
```julia
function parse_brackets(after_parse::F,
                        ps::ParseState, closing_kind, generator_is_last=true) where {F}
    ps = ParseState(ps, range_colon_enabled=true,
                    space_sensitive=false,
                    where_enabled=true,
                    whitespace_newline=true)
    params_positions = acquire_positions(ps.stream)
    last_eq_before_semi = 0
```

</details>

#### 2. Callers pass in distinct `do`-block closures that now specialize independently, covering parse-unary, paren, and other bracketed forms.

**Component**: JuliaSyntax parser

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/julia/parser.jl:1275-3315**
[View on GitHub](https://github.com/JuliaLang/julia/blob/b34261b5d099153c7d454588332f822ddcb12ea9/JuliaSyntax/src/julia/parser.jl#L1275-L3315)
```julia
1275:        opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
2218:            opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
2764:    parse_brackets(ps, closer, false) do _, _, _, _
2780:    opts = parse_brackets(ps, closer) do _, _, _, num_subexprs
3133:        opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
3315:                opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
```

</details>

#### 3. Behavioral expectations for bracket parsing remain validated by existing parser tests (no syntax changes expected).

**Component**: JuliaSyntax tests

<details>
<summary>Evidence</summary>

**JuliaSyntax/test/parser.jl:388-399**
[View on GitHub](https://github.com/JuliaLang/julia/blob/b34261b5d099153c7d454588332f822ddcb12ea9/JuliaSyntax/test/parser.jl#L388-L399)
```julia
# calls with brackets
"f(a,b)"  => "(call f a b)"
"f(a,)"   => "(call-, f a)"
"f(a=1; b=2)" => "(call f (= a 1) (parameters (= b 2)))"
"f(a; b; c)" => "(call f a (parameters b) (parameters c))"
"(a=1)()" =>  "(call (parens (= a 1)))"
"f (a)" => "(call f (error-t) a)"
"@x(a, b)"   =>  "(macrocall-p (macro_name x) a b)"
"@x(a, b,)"  =>  "(macrocall-p-, (macro_name x) a b)"
"A.@x(y)"    =>  "(macrocall-p (. A (macro_name x)) y)"
"A.@x(y).z"  =>  "(. (macrocall-p (. A (macro_name x)) y) z)"
"f(y for x = xs; a)" => "(call f (generator y (iteration (in x xs))) (parameters a))"
```

</details>

### Secondary Effects

#### Parser call-sites now get specialized `parse_brackets` instantiations per closure, reducing dynamic dispatch in bracket parsing hot paths (notably `parse_unary`).

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
parse_unary(ps::ParseState)  [parser.jl:1191]
  -> parse_brackets(ps, K")") do ... end  [parser.jl:1275]
  -> after_parse closure specializes via parse_brackets(after_parse::F)  [parser.jl:3192]
  -> opts influences call-vs-block parsing and operator precedence  [parser.jl:1276-1283]
```
</details>

**Downstream Surfaces:**
- REPL parsing latency during heavy package loads
- JuliaSyntax-based tooling that repeatedly parses bracketed call forms

### Compatibility

#### Internal API Changes
- **parse_brackets(after_parse::F) where {F}**: Callable argument now specialized by concrete closure type instead of `Function`, increasing method specialization for JuliaSyntax internals.

### Performance

**Compile Time:**
- ESTIMATED: Slight increase in method specialization count for parser entry points because each distinct closure gets a dedicated `parse_brackets` instantiation.

**Runtime:**
- ESTIMATED: Reduced dynamic dispatch in bracket parsing hot paths, improving REPL responsiveness after loading large packages (as described in PR motivation).

### Risk Assessment

**Level**: low

**Rationale:**
- Change is signature-level specialization only; parse logic and tests for bracket syntax remain unchanged.
- Affected surface is JuliaSyntax internal parsing; no user-facing syntax semantics are altered.

### Recommendations

- Monitor parser-related precompile and REPL latency to confirm the expected responsiveness improvement without significant code size growth.
