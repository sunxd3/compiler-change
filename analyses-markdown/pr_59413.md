# PR #59413: inference: reinfer and track missing code for inlining

## Metadata

- **Author**: vtjnash
- **URL**: https://github.com/JuliaLang/julia/pull/59413
- **Merged**: 2025-11-10 18:56 UTC
- **Labels**: `compiler:inference`
- **Diff**: https://github.com/JuliaLang/julia/pull/59413.diff

## Scope

### Files Touched
- `Compiler/src/abstractinterpretation.jl`
- `Compiler/src/stmtinfo.jl`
- `Compiler/src/typeinfer.jl`
- `Compiler/test/inline.jl`
- `Compiler/test/newinterp.jl`
- `contrib/generate_precompile.jl`
- `src/jltypes.c`
- `src/staticdata.c`
- `stdlib/REPL/src/REPLCompletions.jl`
- `test/cmdlineargs.jl`
- `test/core.jl`

### Components
- Compiler.AbstractInterpretation
- Compiler.TypeInference
- Compiler.StmtInfo
- Compiler.Inlining
- Runtime
- Serialization
- REPL
- Tests

### Pipeline Stages
- TypeInference
- Inlining
- Optimization
- Sysimg/Serialization
- REPL

## Analysis

### Intent

Ensure inference regenerates inlineable IR when missing so that the optimizer can inline correctly, and track inference results per match to guide const-prop and inlining decisions.

**Related Issues:**
- https://github.com/JuliaLang/julia/issues/59846

### Direct Changes

#### 1. Method match metadata now stores per-match inferred call results, and generic-call inference records them for later compilation-signature inference.

**Component**: Compiler.AbstractInterpretation / Compiler.StmtInfo

<details>
<summary>Evidence</summary>

**Compiler/src/stmtinfo.jl:52-64**
[View on GitHub](https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/stmtinfo.jl#L52-L64)
```julia
struct MethodMatchInfo <: CallInfo
    results::MethodLookupResult
    mt::MethodTable
    atype
    fullmatch::Bool
    edges::Vector{Union{Nothing,CodeInstance}}
    call_results::Vector{Union{Nothing,InferredCallResult}}
    function MethodMatchInfo(
        results::MethodLookupResult, mt::MethodTable, @nospecialize(atype), fullmatch::Bool)
        edges = fill!(Vector{Union{Nothing,CodeInstance}}(undef, length(results)), nothing)
        call_results = fill!(Vector{Union{Nothing,InferredCallResult}}(undef, length(results)), nothing)
        return new(results, mt, atype, fullmatch, edges, call_results)
    end
end
```

**Compiler/src/abstractinterpretation.jl:125-242**
[View on GitHub](https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/abstractinterpretation.jl#L125-L242)
```julia
(; valid_worlds, applicable) = matches
update_valid_age!(sv, get_inference_world(interp), valid_worlds) # need to record the negative world now, since even if we don't generate any useful information, inlining might want to add an invoke edge and it won't have this information anymore
if bail_out_toplevel_call(interp, sv)
    local napplicable = length(applicable)
    for i = 1:napplicable
        local sig = applicable[i].match.spec_types
        if !isdispatchtuple(sig)
            # only infer fully concrete call sites in top-level expressions (ignoring even isa_compileable_sig matches)
            add_remark!(interp, sv, "Refusing to infer non-concrete call site in top-level expression")
            return Future(CallMeta(Any, Any, Effects(), NoCallInfo()))
        end
    end
end
mresult = abstract_call_method(interp, method, sig, match.sparams, multiple_matches, si, sv)::Future
function handle1(interp, sv)
    local (; rt, exct, effects, edge, call_result) = mresult[]
    this_conditional = ignorelimited(rt)
    this_rt = widenwrappedconditional(rt)
    this_exct = exct
    const_call_result = abstract_call_method_with_const_args(interp,
        mresult[], state.func, this_arginfo, si, match, sv)
    if const_call_result !== nothing
        this_const_conditional = ignorelimited(const_call_result.rt)
        this_const_rt = widenwrappedconditional(const_call_result.rt)
        const_result = const_edge = nothing
        if this_const_rt ⊑ₚ this_rt
            this_conditional = this_const_conditional
            this_rt = this_const_rt
            (; effects, const_result, const_edge) = const_call_result
        elseif is_better_effects(const_call_result.effects, effects)
            (; effects, const_result, const_edge) = const_call_result
        else
            add_remark!(interp, sv, "[constprop] Discarded because the result was wider than inference")
        end
        if const_call_result.exct ⋤ this_exct
            this_exct = const_call_result.exct
            (; const_result, const_edge) = const_call_result
        else
            add_remark!(interp, sv, "[constprop] Discarded exception type because result was wider than inference")
        end
        if const_edge !== nothing
            edge = const_edge
            update_valid_age!(sv, get_inference_world(interp), world_range(const_edge))
        end
        if const_result !== nothing
            call_result = const_result
        end
    end
    state.all_effects = merge_effects(state.all_effects, effects)
    @assert !(this_conditional isa Conditional || this_rt isa MustAlias) "invalid lattice element returned from inter-procedural context"
    if can_propagate_conditional(this_conditional, argtypes)
        this_rt = this_conditional
    end
    edges[edge_idx] = edge
    call_results[edge_idx] = call_result
```

</details>

#### 2. Edge inference now returns an InferenceResult in MethodCallResult.call_result when available, enabling later inlineability checks against the actual inferred source.

**Component**: Compiler.TypeInference

<details>
<summary>Evidence</summary>

**Compiler/src/typeinfer.jl:1208-1231**
[View on GitHub](https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/typeinfer.jl#L1208-L1231)
```julia
push!(caller.tasks, function get_infer_result(interp, caller)
    update_valid_age!(caller, get_inference_world(interp), frame.valid_worlds)
    local isinferred = is_inferred(frame)
    local effects
    local edge = nothing
    local call_result = nothing
    if isinferred
        edge = result.ci
        if edge_ci isa CodeInstance && codeinst_edges_sub(edge_ci, edge.min_world, edge.max_world, edge.edges)
            edge = edge_ci # override the edge for tracking invalidation
        end
        result.ci_as_edge = edge # override the edge for tracking purposes
        effects = result.ipo_effects # effects are adjusted already within `finish` for ipo_effects
        call_result = result
    else
        effects = adjust_effects(effects_for_cycle(frame.ipo_effects), method)
        add_cycle_backedge!(caller, frame)
    end
    local bestguess = frame.bestguess
    local exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)
    mresult[] = MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects,
        edge, edgecycle, edgelimited, call_result)
    return true
end)
```

</details>

#### 3. Const-prop heuristics and semi-concrete evaluation now consult the inferred source carried in call_result for inlineability decisions and irinterp setup.

**Component**: Compiler.AbstractInterpretation

<details>
<summary>Evidence</summary>

**Compiler/src/abstractinterpretation.jl:1208-1278**
[View on GitHub](https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/src/abstractinterpretation.jl#L1208-L1278)
```julia
if inf_result isa InferenceResult
    inferred = inf_result.src
    # TODO propagate a specific `CallInfo` that conveys information about this call
    if src_inlining_policy(interp, mi, inferred, NoCallInfo(), IR_FLAG_NULL)
        return true
    end
end
return false # the cache isn't inlineable, so this constant-prop' will most likely be unfruitful
end

function semi_concrete_eval_call(interp::AbstractInterpreter,
    mi::MethodInstance, result::MethodCallResult, arginfo::ArgInfo, sv::AbsIntState)
    call_result = result.call_result
    call_result isa InferenceResult || return nothing
    codeinst = call_result.ci
    codeinst isa CodeInstance || return nothing
    inferred = call_result.src
    src_inlining_policy(interp, mi, inferred, NoCallInfo(), IR_FLAG_NULL) || return nothing # hack to work-around test failures caused by #58183 until both it and #48913 are fixed
    irsv = IRInterpretationState(interp, codeinst, mi, arginfo.argtypes, inferred)
    irsv === nothing && return nothing
    assign_parentchild!(irsv, sv)
    rt, (nothrow, noub) = ir_abstract_constant_propagation(interp, irsv)
    @assert !(rt isa Conditional || rt isa MustAlias) "invalid lattice element returned from irinterp"
    if !(isa(rt, Type) && hasintersect(rt, Bool))
        ir = irsv.ir
        effects = result.effects
        if nothrow
            effects = Effects(effects; nothrow=true)
        end
        if noub
            effects = Effects(effects; noub=ALWAYS_TRUE)
        end
        exct = refine_exception_type(result.exct, effects)
        semi_concrete_result = SemiConcreteResult(codeinst, ir, effects, spec_info(irsv))
        const_edge = nothing # TODO use the edges from irsv?
        return ConstCallResult(rt, exct, semi_concrete_result, effects, const_edge)
    end
    nothing
end
```

</details>

#### 4. Inlining tests now assert that a second inlining pass does not inline a call when inference recorded a noinline decision, even if the callsite flag is manually cleared.

**Component**: Compiler.Inlining Tests

<details>
<summary>Evidence</summary>

**Compiler/test/inline.jl:1876-1889**
[View on GitHub](https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/Compiler/test/inline.jl#L1876-L1889)
```julia
call_func_mul_int(a::Int, b::Int) = @noinline func_mul_int(a, b)
multi_inlining2(a::Int, b::Int) = call_func_mul_int(a, b)
let i::Int, continue_::Bool
    interp = Compiler.NativeInterpreter()
    # check if callsite `@noinline` annotation works
    ir, = only(Base.code_ircode(multi_inlining2, (Int,Int); optimize_until="CC: INLINING", interp))
    i = findfirst(isinvoke(:func_mul_int), ir.stmts.stmt)
    @test i !== nothing
    # now delete the callsite flag, and see the second inlining pass does not inline the call, since inference recorded it should not
    ir.stmts[i][:flag] &= ~Compiler.IR_FLAG_NOINLINE
    inlining = Compiler.InliningState(interp)
    ir = Compiler.ssa_inlining_pass!(ir, inlining, false)
    @test findfirst(isinvoke(:func_mul_int), ir.stmts.stmt) !== nothing
    @test findfirst(iscall((ir, Core.Intrinsics.mul_int)), ir.stmts.stmt) === nothing
end
```

</details>

#### 5. CodeInstance const-field metadata no longer marks analysis_results as const, and tests reflect the updated const list.

**Component**: Runtime

<details>
<summary>Evidence</summary>

**src/jltypes.c:3719-3724**
[View on GitHub](https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/src/jltypes.c#L3719-L3724)
```julia
jl_svecset(jl_code_instance_type->types, 2, jl_code_instance_type);
const static uint32_t code_instance_constfields[1]  = { 0b000001110000011100011 }; // Set fields 1, 2, 6-8, 14-16 as const
const static uint32_t code_instance_atomicfields[1] = { 0b111110001011100011100 }; // Set fields 3-5, 9-12, 13, 17-21 as atomic
// Fields 4-5 are only operated on by construction and deserialization, so are effectively const at runtime
// Fields ipo_purity_bits and analysis_results are not currently threadsafe or reliable, as they get mutated after optimization, but are not declared atomic
```

**test/core.jl:16-21**
[View on GitHub](https://github.com/JuliaLang/julia/blob/998cb27e4c83364a38378841c88c954ac1e7eb59/test/core.jl#L16-L21)
```julia
# sanity tests that our built-in types are marked correctly for const fields
for (T, c) in (
        (Core.CodeInfo, []),
        (Core.CodeInstance, [:def, :owner, :rettype, :exctype, :rettype_const, :time_infer_total, :time_infer_cache_saved, :time_infer_self]),
        (Core.Method, [#=:name, :module, :file, :line, :primary_world, :sig, :slot_syms, :external_mt, :nargs, :called, :nospecialize, :nkw, :isva, :is_for_opaque_closure, :constprop=#]),
```

</details>

### Secondary Effects

#### Inlining decisions become more stable because const-prop heuristics now consult the actual inferred source of callees, preventing a later inlining pass from undoing a noinline choice that inference already recorded.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
abstract_call_gf_by_type() stores call_results per MethodMatchTarget [abstractinterpretation.jl:148-242]
  -> infercalls2() passes call_results to const_prop_methodinstance_heuristic() [abstractinterpretation.jl:301-308]
  -> const_prop_methodinstance_heuristic() checks src_inlining_policy on inf_result.src [abstractinterpretation.jl:1233-1241]
  -> inlining tests verify no inlining on second pass when inference recorded noinline [Compiler/test/inline.jl:1876-1889]
```
</details>

**Downstream Surfaces:**
- Core.Compiler inlining and constant-propagation heuristics
- SSA inlining pass stability

#### Semi-concrete evaluation (irinterp) now requires an InferenceResult-backed CodeInstance and inlineable source, which can reduce irinterp attempts on cached but non-inlineable code.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
typeinf_edge() populates MethodCallResult.call_result with InferenceResult when available [typeinfer.jl:1208-1231]
  -> semi_concrete_eval_call() uses result.call_result.ci and result.call_result.src [abstractinterpretation.jl:1248-1276]
  -> src_inlining_policy gate can block irinterp when source is not inlineable [abstractinterpretation.jl:1255-1256]
```
</details>

**Downstream Surfaces:**
- IRInterpreter-based const-prop
- Inlining preparation for cached CodeInstances

### Compatibility

#### Internal API Changes
- **Core.Compiler.MethodMatchInfo.call_results**: New per-match storage for InferredCallResult; downstream CallInfo consumers should tolerate or use the extra field.
- **Core.Compiler.MethodCallResult.call_result**: Replaces the previous volatile_inf_result slot and now carries InferredCallResult for use in const-prop and irinterp.

#### Behavioral Changes
- Second inlining pass respects inference-recorded noinline decisions even if callsite flag is cleared, as enforced by updated tests.

### Performance

**Compile Time:**
- ESTIMATED: additional storage and bookkeeping for call_results per method match; minor overhead proportional to number of applicable methods.

**Runtime:**
- ESTIMATED: improved runtime in cases where previously-missing inlineable IR prevented inlining, by ensuring inference regenerates inlineable sources when needed.

### Risk Assessment

**Level**: medium

**Rationale:**
- Touches inference/inlining heuristics and adds a new call_result dataflow; incorrect propagation could change inlining or const-prop behavior.
- Modifies CodeInstance const-field metadata, which affects assumptions about mutability during optimization.

### Recommendations

- Downstream compiler tooling that wraps or constructs MethodCallResult should forward call_result to preserve inference metadata.
- Consider adding a small note in developer docs about MethodMatchInfo.call_results and MethodCallResult.call_result to avoid silent tooling breakage.
