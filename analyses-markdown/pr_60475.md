# PR #60475: Add `@stm` "SyntaxTree match" macro

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60475
- **Merged**: 2026-01-11 00:09 UTC
- **Labels**: `JuliaLowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60475.diff

## Scope

### Files Touched
- `JuliaSyntax/src/porcelain/syntax_graph.jl`
- `JuliaSyntax/test/syntax_graph.jl`

### Components
- JuliaSyntax

### Pipeline Stages
- Parsing

## Analysis

### Intent

Introduce a SyntaxTree pattern-matching macro (@stm) with optional debug tracing and usage checking, plus comprehensive tests.

### Direct Changes

#### 1. Add @stm/@stm_debug macros plus a matcher/validator pipeline that builds nested conditionals, validates patterns, matches tree kinds/child counts, and binds pattern variables.

**Component**: JuliaSyntax porcelain utilities

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/porcelain/syntax_graph.jl:811-1002**
[View on GitHub](https://github.com/JuliaLang/julia/blob/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax/src/porcelain/syntax_graph.jl#L811-L1002)
```julia
macro stm(st, pats)
    _stm(__source__, st, pats; debug=false)
end

"Like `@stm`, but prints a trace during matching."
macro stm_debug(st, pats)
    _stm(__source__, st, pats; debug=true)
end

function _stm(line::LineNumberNode, st, pats; debug=false)
    _stm_check_usage(pats)
    st_gs, result_gs, k_gs, nc_gs = gensym.("st", "result", "k", "nc")
    out_blk = Expr(:let, Expr(:block, :($st_gs = $st::SyntaxTree),
                              :($result_gs = nothing),
                              :($k_gs = $kind($st_gs)),
                              :($nc_gs = $numchildren($st_gs))),
                   Expr(:if, false, nothing))
    case_list_tail = out_blk.args[2].args
    for pcr in pats.args
        pcr isa LineNumberNode && (line = pcr; continue)
        p, cond, result = _stm_destruct_pat(pcr)
        pat_ok = p isa Symbol ? true : _stm_matches(p, st_gs, k_gs, nc_gs, debug)
        case = Expr(:elseif,
                    Expr(:&&, pat_ok,
                         Expr(:let, _stm_assigns(p, st_gs),
                              Expr(:&&, cond,
                                   Expr(:block, line,
                                        :($result_gs = $result), true)))),
                    result_gs)
        push!(case_list_tail, case)
        case_list_tail = case_list_tail[3].args
    end
    push!(case_list_tail,
          :(throw(ErrorException(string(
              "No match found for `", $st_gs, "` at ", $(string(line)))))))
    return esc(out_blk)
end

function _stm_matches(p::Expr, st_gs::Symbol, k_gs::Symbol, nc_gs::Symbol, debug)
    pat_k = Kind(p.args[1].args[3])
    out = Expr(:&&, :($pat_k === $k_gs))
    debug && push!(out.args, Expr(:block, :(printstyled(
        string("[kind]: ", $k_gs, "\n"); color=:yellow)), true))
    p_args = p.args[2:end]
    dots_i = findfirst(x->Meta.isexpr(x, :(...)), p_args)
    dots_start = something(dots_i, length(p_args) + 1)
    n_after_dots = length(p_args) - dots_start # -1 if no dots
    push!(out.args, isnothing(dots_i) ?
        :($nc_gs === $(length(p_args))) :
        :($nc_gs >= $(length(p_args) - 1)))
    debug && push!(out.args, Expr(:block, :(printstyled(
        string("[numc]: ", $nc_gs, "\n"); color=:yellow)), true))
    for i in 1:dots_start-1
        p_args[i] isa Symbol && continue
        push!(out.args,
              _stm_matches_wrapper(p_args[i], :($st_gs[$i]), debug))
    end
    for i in n_after_dots-1:-1:0
        p_args[end-i] isa Symbol && continue
        push!(out.args,
              _stm_matches_wrapper(p_args[end-i], :($st_gs[end-$i]), debug))
    end
    debug && push!(out.args, Expr(:block, :(printstyled(
        string("matched: ", $st_gs, " with ", $(QuoteNode(p)), "\n");
        color=:green)), true))
    return out
end

function _stm_check_usage(pats::Expr)
    function _stm_check_pattern(p; syms=Set{Symbol}())
        if Meta.isexpr(p, :(...), 1)
            p = p.args[1]
            @assert(p isa Symbol, "Expected symbol before `...` in $p")
        end
        if p isa Symbol
            dup = p in syms && p !== :_
            push!(syms, p)
            @assert(!dup, "invalid duplicate non-underscore identifier $p")
            return nothing
        elseif Meta.isexpr(p, :vect)
            @assert(length(p.args) === 1,
                    "use spaces, not commas, in @stm []-patterns")
        elseif Meta.isexpr(p, :hcat)
            @assert(length(p.args) >= 2)
        elseif Meta.isexpr(p, :vcat)
            p = _stm_vcat_to_hcat(p)
            @assert(length(p.args) >= 2)
        else
            @assert(false, "malformed pattern $p")
        end
        @assert(count(x->Meta.isexpr(x, :(...)), p.args[2:end]) <= 1,
                "Multiple `...` in a pattern is ambiguous")
        @assert(Meta.isexpr(p.args[1], :macrocall, 3) &&
            p.args[1].args[1] === Symbol("@K_str") &&
            p.args[1].args[3] isa String, "first pattern elt must be K\"\"")
        for subp in p.args[2:end]
            _stm_check_pattern(subp; syms)
        end
    end

    @assert Meta.isexpr(pats, :block) "Usage: @stm st begin; ...; end"
    for pcr in filter(e->!isa(e, LineNumberNode), pats.args)
        @assert(Meta.isexpr(pcr, :(->), 2), "Expected pat -> res, got malformed case: $pcr")
        if Meta.isexpr(pcr.args[1], :tuple)
            @assert(length(pcr.args[1].args) === 2,
                    "Expected `pat` or `(pat, when=cond)`")
            p = pcr.args[1].args[1]
            c = pcr.args[1].args[2]
            @assert(Meta.isexpr(c, :(=), 2) && c.args[1] === :when,
                    "Expected `(when=cond)` in tuple pattern, got $(c)")
        else
            p = pcr.args[1]
        end
        _stm_check_pattern(p)
    end
end
```

</details>

#### 2. Add tests covering matching success/failure, nested patterns, splat binding, `when=` guards, and side effects in the guard clause.

**Component**: JuliaSyntax tests

<details>
<summary>Evidence</summary>

**JuliaSyntax/test/syntax_graph.jl:104-313**
[View on GitHub](https://github.com/JuliaLang/julia/blob/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax/test/syntax_graph.jl#L104-L313)
```julia
@testset "@stm SyntaxTree pattern-matching" begin
    st = parsestmt(SyntaxTree, "foo(a,b=1,c(d=2))")
    # (call foo a (kw b 1) (call c (kw d 2)))

    @testset "basic functionality" begin
        @test @stm st begin
            _ -> true
        end

        @test @stm st begin
            x -> x isa SyntaxTree
        end

        @test @stm st begin
            [K"function" f a b c] -> false
            [K"call" f a b c] -> true
        end
    end

    @testset "errors" begin
        @test_throws ErrorException @stm st begin
            [K"Identifier"] -> false
        end
    end

    @testset "SyntaxList splat matching" begin
        @test @stm st begin
            [K"call" f args...] -> args isa SyntaxList && length(args) === 3
        end
    end

    @testset "`when` clauses affect matching" begin
        @test @stm st begin
            (_, when=false) -> false
            (_, when=true) -> true
        end
    end

    @testset "effects of when=cond" begin
        let x = Int[]
            @test @stm st begin
                (_, when=(push!(x, 1); true)) -> x == [1]
            end
        end
    end
end
```

</details>

#### 3. Call-site search indicates @stm is only referenced in JuliaSyntax tests in this PR.

**Component**: JuliaSyntax usage survey

<details>
<summary>Evidence</summary>

**rg:@stm:1-4**
[View on GitHub](https://github.com/JuliaLang/julia/blob/a4ee3825664fcd4cb5dbca3a3f7eeb8e3bb0e54a/JuliaSyntax/test/syntax_graph.jl#L1-L4)
```julia
JuliaSyntax/test/syntax_graph.jl
1:using .JuliaSyntax: SyntaxGraph, SyntaxTree, SyntaxList, freeze_attrs, unfreeze_attrs, ensure_attributes, ensure_attributes!, delete_attributes, copy_ast, attrdefs, @stm
104:@testset "@stm SyntaxTree pattern-matching" begin
JuliaSyntax/src/porcelain/syntax_graph.jl
```

</details>

### Secondary Effects

#### Pattern matching emits runtime `kind`/`numchildren` checks and recursive descent, so using @stm in lowering or analysis code adds a per-branch walk over the SyntaxTree and (optionally) debug printing.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
_stm(line, st, pats) [syntax_graph.jl:823]
  builds :if/:elseif chain with pattern guard
  -> _stm_matches(p, st_gs, k_gs, nc_gs, debug) [syntax_graph.jl:889]
     checks kind/child count and recurses into child SyntaxTree access
  -> debug=true inserts printstyled("[kind]") and printstyled("[numc]") blocks
```
</details>

**Downstream Surfaces:**
- JuliaLowering pattern-matching helpers
- AST tooling that processes JuliaSyntax.SyntaxTree

#### Macro expansion time includes a full syntactic validation of patterns and variable uniqueness, which can surface assertion errors during macroexpand for invalid patterns.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
_stm(line, st, pats) calls _stm_check_usage(pats) [syntax_graph.jl:823-1002]
  -> _stm_check_pattern enforces K"kind" forms, single `...`, and no duplicate symbols
  -> @assert failures throw AssertionError at macro expansion
```
</details>

**Downstream Surfaces:**
- Packages that use @stm in generated code or macros

### Compatibility

#### Internal API Changes
- **JuliaSyntax.@stm (new macro)**: Adds a new public macro for SyntaxTree matching; no existing API removed.

#### Behavioral Changes
- @stm throws ErrorException when no pattern matches; malformed patterns throw AssertionError during macro expansion.

### Performance

**Compile Time:**
- ESTIMATED: O(p) pattern validation and expansion per @stm, where p = number of pattern nodes; dominates macro expansion for large pattern blocks.

**Runtime:**
- ESTIMATED: O(n) checks per pattern branch with recursion into child SyntaxTrees; debug mode adds I/O from printstyled.

### Risk Assessment

**Level**: low

**Rationale:**
- Purely additive API in JuliaSyntax with no changes to existing parsing or lowering paths.
- Behavior only changes for code that opts into @stm; tests cover success/failure and guard semantics.

### Recommendations

- Downstream tooling that currently hand-matches SyntaxTree nodes could adopt @stm for clearer matching, but should be aware of its guard evaluation order and ErrorException behavior when no match is found.
