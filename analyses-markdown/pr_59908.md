# PR #59908: absint: allow ad-hoc cancellation of concrete evaluation

## Metadata

- **Author**: aviatesk
- **URL**: https://github.com/JuliaLang/julia/pull/59908
- **Merged**: 2025-10-20 17:57 UTC
- **Diff**: https://github.com/JuliaLang/julia/pull/59908.diff

## Scope

### Files Touched
- `Compiler/src/abstractinterpretation.jl`

### Components
- Compiler.AbstractInterpretation

### Pipeline Stages
- TypeInference
- ConstProp
- AbstractInterpretation

## Analysis

### Intent

Allow external AbstractInterpreter implementations (notably JETAnalyzer) to cancel concrete evaluation ad-hoc and fall back to regular abstract interpretation when concrete evaluation throws, reducing false positives while keeping precision when concrete eval succeeds.

**Related Issues:**
- https://github.com/JuliaLang/julia/issues/59884

### Direct Changes

#### 1. Guard the concrete-eval fast path so that a `nothing` result from `concrete_eval_call` is treated as an explicit cancellation instead of being returned, enabling fallback to const-prop / abstract interpretation.

**Component**: Compiler/src/abstractinterpretation.jl

<details>
<summary>Evidence</summary>

**Compiler/src/abstractinterpretation.jl:865-881**
[View on GitHub](https://github.com/JuliaLang/julia/blob/c6091de0942ab75c9da18bbf1b49db1fb760e353/Compiler/src/abstractinterpretation.jl#L865-L881)
```julia
function abstract_call_method_with_const_args(interp::AbstractInterpreter,
    result::MethodCallResult, @nospecialize(f), arginfo::ArgInfo, si::StmtInfo,
    match::MethodMatch, sv::AbsIntState, invokecall::Union{Nothing,InvokeCall}=nothing)
    if bail_out_const_call(interp, result, si, match, sv)
        return nothing
    end
    eligibility = concrete_eval_eligible(interp, f, result, arginfo, sv)
    concrete_eval_result = nothing
    if eligibility === :concrete_eval
        concrete_eval_result = concrete_eval_call(interp, f, result, arginfo, sv, invokecall)
        if (concrete_eval_result !== nothing &&  # allow external abstract interpreters to disable concrete evaluation ad-hoc
            # if we don't inline the result of this concrete evaluation,
            # give const-prop' a chance to inline a better method body
            (!may_optimize(interp) ||
             may_inline_concrete_result(concrete_eval_result.const_result::ConcreteResult) ||
             concrete_eval_result.rt === Bottom)) # unless this call deterministically throws and thus is non-inlineable
            return concrete_eval_result
        end
        # TODO allow semi-concrete interp for this call?
    end
```

</details>

#### 2. Existing regression tests show how custom AbstractInterpreter implementations override abstract-eval hooks, providing the baseline extension point that this PR expands (concrete-eval cancellation).

**Component**: Compiler/test/AbstractInterpreter.jl

<details>
<summary>Evidence</summary>

**Compiler/test/AbstractInterpreter.jl:171-190**
[View on GitHub](https://github.com/JuliaLang/julia/blob/c6091de0942ab75c9da18bbf1b49db1fb760e353/Compiler/test/AbstractInterpreter.jl#L171-L190)
```julia
# GPUCompiler needs accurate inference through kwfunc with the overlay of `Core.throw_inexacterror`
# https://github.com/JuliaLang/julia/issues/48097
@newinterp Issue48097Interp
@MethodTable ISSUE_48097_MT
Compiler.method_table(interp::Issue48097Interp) = Compiler.OverlayMethodTable(Compiler.get_inference_world(interp), ISSUE_48097_MT)
function Compiler.concrete_eval_eligible(interp::Issue48097Interp,
    @nospecialize(f), result::Compiler.MethodCallResult, arginfo::Compiler.ArgInfo, sv::Compiler.AbsIntState)
    ret = @invoke Compiler.concrete_eval_eligible(interp::Compiler.AbstractInterpreter,
        f::Any, result::Compiler.MethodCallResult, arginfo::Compiler.ArgInfo, sv::Compiler.AbsIntState)
    if ret === :semi_concrete_eval
        # disable semi-concrete interpretation
        return :none
    end
    return ret
end
@overlay ISSUE_48097_MT @noinline Core.throw_inexacterror(f::Symbol, ::Type{T}, val) where {T} = return
issue48097(; kwargs...) = return 42
@test fully_eliminated(; interp=Issue48097Interp(), retval=42) do
    issue48097(; a=1f0, b=1.0)
end
```

</details>

### Secondary Effects

#### External interpreters can now cancel concrete evaluation per-call, forcing fallback to const-prop/abstract interpretation when concrete evaluation throws or is otherwise undesirable (e.g., JETAnalyzer error reporting).

**Likelihood**: medium | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
abstract_call_method_with_const_args(...)  [abstractinterpretation.jl:865-899]
  -> concrete_eval_call(...)  [abstractinterpretation.jl:997-1018]
  -> if concrete_eval_result !== nothing then return it
  -> else proceed to maybe_get_const_prop_profitable(...) and const_prop_call(...)
The new `concrete_eval_result !== nothing` guard makes `nothing` a cancellation signal.
```
</details>

**Downstream Surfaces:**
- AbstractInterpreter implementors that override concrete_eval_call (e.g., JETAnalyzer)
- Tools relying on const-prop fallback for diagnostics (JET, custom analyzers)
- Overlay-based inference stacks (GPUCompiler/CUDA-style overlays)

### Compatibility

#### Internal API Changes
- **Compiler.concrete_eval_call(::AbstractInterpreter, ...) return contract**: Return value may now be `nothing` to signal cancellation; callers treat `nothing` as a request to skip concrete evaluation and continue with const-prop.

#### Behavioral Changes
- Inference paths may skip concrete evaluation when external interpreters opt out, potentially widening return types or changing diagnostic output compared to always returning the concrete-eval result.

### Performance

**Compile Time:**
- ESTIMATED: negligible (<1%); one extra branch and null-check in a hot abstract interpretation path when concrete eval is eligible.

**Runtime:**
- No direct runtime codegen changes; behavior is limited to inference/analysis time.

### Risk Assessment

**Level**: low

**Rationale:**
- Change is narrowly scoped to a guard around concrete evaluation results.
- Default interpreter behavior unchanged because Base concrete_eval_call never returns nothing.

### Recommendations

- Add a small AbstractInterpreter test that overrides concrete_eval_call to return nothing on specific errors and asserts fallback to const-prop.
