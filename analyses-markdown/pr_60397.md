# PR #60397: Backports for 1.12.4

## Metadata

- **Author**: KristofferC
- **URL**: https://github.com/JuliaLang/julia/pull/60397
- **Merged**: 2025-12-19 12:38 UTC
- **Labels**: `release`
- **Diff**: https://github.com/JuliaLang/julia/pull/60397.diff

## Scope

### Files Touched
- `Compiler/src/abstractinterpretation.jl`
- `src/julia-syntax.scm`
- `test/syntax.jl`
- `stdlib/Artifacts/src/Artifacts.jl`
- `src/jloptions.c`
- `base/logging/logging.jl`
- `stdlib/Logging/test/runtests.jl`
- `pkgimage.mk`
- `stdlib/stdlib.mk`
- `stdlib/Manifest.toml`
- `stdlib/Project.toml`
- `stdlib/LinearAlgebra.version`
- `stdlib/Pkg.version`
- `deps/libgit2.version`
- `stdlib/MozillaCACerts_jll/Project.toml`
- `NEWS.md`

### Components
- JuliaSyntax
- Compiler.AbstractInterpretation
- Base/Stdlib
- Runtime/CLI

### Pipeline Stages
- Parsing
- Lowering
- TypeInference
- Runtime

## Analysis

### Intent

Release-1.12 backport bundle for the 1.12.4 patch release, including parser/lowering fixes, artifact world-age handling, logging compatibility, and runtime/stdlib updates.

**Related Issues:**
- https://github.com/JuliaLang/julia/pull/60195
- https://github.com/JuliaLang/julia/pull/60383
- https://github.com/JuliaLang/julia/pull/60330
- https://github.com/JuliaLang/julia/pull/60299
- https://github.com/JuliaLang/julia/pull/60414

### Direct Changes

#### 1. Lowering now preserves keyword/parameters structure when removing argument side effects, so kwcall parameters are evaluated exactly once for broadcasted LHS expressions.

**Component**: JuliaSyntax

<details>
<summary>Evidence</summary>

**src/julia-syntax.scm:1788-1817**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/src/julia-syntax.scm#L1788-L1817)
```julia
(define (remove-argument-side-effects e)
  (if (not (pair? e))
      (cons e '())
      (let ((a '()))
        (define (arg-to-temp x)
          (cond ((effect-free? x) x)
                ((eq? (car x) '...)
                 `(... ,(arg-to-temp (cadr x))))
                ((eq? (car x) 'kw)
                 `(kw ,(cadr x) ,(arg-to-temp (caddr x))))
                ((eq? (car x) 'parameters)
                 `(parameters ,@(map arg-to-temp (cdr x))))
                (else
                 (let ((g (make-ssavalue)))
                   (begin (set! a (cons `(= ,g ,x) a))
                          g)))))
        (if (eq? (car e) 'let)
          (cons (arg-to-temp e) (reverse a))
          (cons (cons (car e) (map arg-to-temp (cdr e)))
                (reverse a))))))
```

**test/syntax.jl:3662-3687**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/test/syntax.jl#L3662-L3687)
```julia
@testset "removing argument side effects" begin
    # Allow let blocks in broadcasted LHSes, but only evaluate them once:
    execs = 0
    array = [1]
    let x = array; execs += 1; x; end .+= 2
    @test array == [3]
    @test execs == 1
    let; execs += 1; array; end .= 4
    @test array == [4]
    @test execs == 2
    let x = array; execs += 1; x; end::Vector{Int} .+= 2
    @test array == [6]
    @test execs == 3
    let; execs += 1; array; end::Vector{Int} .= 7
    @test array == [7]
    @test execs == 4

    # remove argument side effects on lhs kwcall
    pa_execs = 0
    kw_execs = 0
    f60152(v, pa; kw) = copy(v)
    @test (f60152([1, 2, 3], 0; kw=0) .*= 2) == [2,4,6]
    @test (f60152([1, 2, 3], (pa_execs+=1); kw=(kw_execs+=1)) .*= 2) == [2,4,6]
    @test pa_execs === 1
    @test kw_execs === 1
end
```

</details>

#### 2. Artifacts now freeze a local world-age at module init and use it for @artifact_str invocations to avoid depending on Base._require_world_age at call time.

**Component**: Base/Stdlib

<details>
<summary>Evidence</summary>

**stdlib/Artifacts/src/Artifacts.jl:19-24**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/stdlib/Artifacts/src/Artifacts.jl#L19-L24)
```julia
const _artifacts_world_age = Ref{UInt}(typemax(UInt))

function __init__()
    _artifacts_world_age[] = Base.get_world_counter()
    nothing
end
```

**stdlib/Artifacts/src/Artifacts.jl:552-558**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/stdlib/Artifacts/src/Artifacts.jl#L552-L558)
```julia
function _artifact_str(__module__, artifacts_toml, name, path_tail, artifact_dict, hash, platform, ::Val{LazyArtifacts}) where LazyArtifacts
    world = _artifacts_world_age[]
    if world == typemax(UInt)
        world = Base.get_world_counter()
    end
    return Base.invoke_in_world(world, __artifact_str, __module__, artifacts_toml, name, path_tail, artifact_dict, hash, platform, Val(LazyArtifacts))::String
end
```

**stdlib/Artifacts/src/Artifacts.jl:728-739**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/stdlib/Artifacts/src/Artifacts.jl#L728-L739)
```julia
if isa(name, AbstractString) && isa(platform, AbstractPlatform)
    # To support slash-indexing, we need to split the artifact name from the path tail:
    artifact_name, artifact_path_tail, hash = artifact_slash_lookup(name, artifact_dict, artifacts_toml, platform)
    return quote
        Base.invokelatest(_artifact_str, $(__module__), $(artifacts_toml), $(artifact_name), $(artifact_path_tail), $(artifact_dict), $(hash), $(platform), Val($(LazyArtifacts)))::String
    end
else
    return quote
        local platform = $(esc(platform))
        local artifact_name, artifact_path_tail, hash = artifact_slash_lookup($(esc(name)), $(artifact_dict), $(artifacts_toml), platform)
        Base.invokelatest(_artifact_str, $(__module__), $(artifacts_toml), artifact_name, artifact_path_tail, $(artifact_dict), hash, platform, Val($(LazyArtifacts)))::String
    end
end
```

</details>

#### 3. Logging now defines integer comparisons for LogLevel to make mixed comparisons well-defined.

**Component**: Base/Stdlib

<details>
<summary>Evidence</summary>

**base/logging/logging.jl:128-137**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/base/logging/logging.jl#L128-L137)
```julia
LogLevel(level::LogLevel) = level

isless(a::LogLevel, b::LogLevel) = isless(a.level, b.level)
isless(a::LogLevel, b::Integer) = isless(a.level, b)
isless(a::Integer, b::LogLevel) = isless(a, b.level)
+(level::LogLevel, inc::Integer) = LogLevel(level.level+inc)
-(level::LogLevel, inc::Integer) = LogLevel(level.level-inc)
convert(::Type{LogLevel}, level::Integer) = LogLevel(level)
```

**stdlib/Logging/test/runtests.jl:15-27**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/stdlib/Logging/test/runtests.jl#L15-L27)
```julia
@testset "LogLevel compatibility with integers" begin
    @test Logging.Debug + 1000 == Logging.Info
    @test Logging.Warn - 1000 == Logging.Info
    @test Logging.Info < 500
    @test 500 < Logging.Warn
end
```

</details>

#### 4. Thread option parsing now guards the thread-pool array allocation to avoid writing past the end when only one pool is configured.

**Component**: Runtime/CLI

<details>
<summary>Evidence</summary>

**src/jloptions.c:671-676**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/src/jloptions.c#L671-L676)
```julia
assert(jl_options.nthreadpools == 1 || jl_options.nthreadpools == 2);
int16_t *ntpp = (int16_t *)malloc_s(jl_options.nthreadpools * sizeof(int16_t));
ntpp[0] = (int16_t)nthreads;
if (jl_options.nthreadpools == 2)
    ntpp[1] = (int16_t)nthreadsi;
jl_options.nthreads_per_pool = ntpp;
```

</details>

#### 5. abstract_invoke retains ErrorException handling for Method-backed invocations with no owner, keeping the exception set conservative.

**Component**: Compiler.AbstractInterpretation

<details>
<summary>Evidence</summary>

**Compiler/src/abstractinterpretation.jl:2249-2253**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4c54cafbd6db26108b3432b7c1906aaa0ff46e31/Compiler/src/abstractinterpretation.jl#L2249-L2253)
```julia
# TODO: When we add curing, we may want to assume this is nothrow
if (method_or_ci.owner === Nothing && method_or_ci.def.def isa Method)
    exct = Union{exct, ErrorException}
end
update_valid_age!(sv, callee_valid_range)
```

</details>

### Secondary Effects

#### Keyword argument expressions on broadcasted LHS kwcalls are guaranteed to be evaluated once, reducing duplicated side effects in lowered code.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
lower-kw-call() builds a `(call ...)` form and invokes remove-argument-side-effects  [src/julia-syntax.scm:1809-1813]
  -> remove-argument-side-effects() walks arguments via arg-to-temp  [src/julia-syntax.scm:1788-1803]
  -> arg-to-temp now handles `parameters` nodes by mapping each child once  [src/julia-syntax.scm:1798-1799]
  -> lowered kwcall uses the transformed args in the emitted block  [src/julia-syntax.scm:1816-1818]
```
</details>

**Downstream Surfaces:**
- Broadcasted assignment lowering
- MacroTools/IRTools that inspect parser AST for kwcall/parameters

#### @artifact_str uses a stable world age captured at Artifacts.__init__, reducing accidental world-age shifts during precompile/invalidations.

**Likelihood**: medium | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
Artifacts.__init__() records Base.get_world_counter()  [stdlib/Artifacts/src/Artifacts.jl:21-23]
  -> _artifact_str reads _artifacts_world_age and calls Base.invoke_in_world  [stdlib/Artifacts/src/Artifacts.jl:552-557]
  -> @artifact_str expands to Base.invokelatest(_artifact_str, ...)  [stdlib/Artifacts/src/Artifacts.jl:728-738]
```
</details>

**Downstream Surfaces:**
- LazyArtifacts/Pkg artifact resolution
- Precompile & world-age sensitive tooling

### Compatibility

#### Internal API Changes
- **Artifacts._artifacts_world_age**: New module-level Ref storing a frozen world age used by _artifact_str instead of Base._require_world_age.

#### Behavioral Changes
- Broadcasted LHS kwcalls now evaluate keyword arguments once, matching positional-arg side-effect stripping semantics.

### Performance

**Compile Time:**
- ESTIMATED: negligible extra work from mapping `parameters` nodes in remove-argument-side-effects; still linear in argument count.

**Runtime:**
- ESTIMATED: no measurable overhead; prevents repeated evaluation of kw argument expressions in broadcasted assignments.

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are targeted backports with explicit tests for kwcall side effects and LogLevel comparisons.
- World-age freeze for artifacts is localized to @artifact_str invocation path.

### Recommendations

- Downstream tools that pattern-match kwcall AST nodes should tolerate `parameters` nodes passing through remove-argument-side-effects unchanged except for argument temping.
- Pkg/LazyArtifacts maintainers should validate artifact resolution behavior under world-age sensitive precompile scenarios.
