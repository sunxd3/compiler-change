# PR #60561: [JuliaLowering] Minor code quality improvements

## Metadata

- **Author**: aviatesk
- **URL**: https://github.com/JuliaLang/julia/pull/60561
- **Merged**: 2026-01-06 19:14 UTC
- **Labels**: `compiler:lowering`, `JuliaLowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60561.diff

## Scope

### Files Touched
- `JuliaLowering/src/desugaring.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering

## Analysis

### Intent

Tighten local-variable initialization paths in JuliaLowering desugaring routines (primarily for JET-friendly isdefined analysis) and remove unused loop bindings.

### Direct Changes

#### 1. Avoid creating an unused iterstate binding when destructuring has zero LHS children by initializing iterstate to nothing for the empty case.

**Component**: JuliaLowering/desugaring

<details>
<summary>Evidence</summary>

**JuliaLowering/src/desugaring.jl:280-312**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4f713be0b388a1f2bce33f4e96b77635a7393135/JuliaLowering/src/desugaring.jl#L280-L312)
```julia
function _destructure(ctx, assignment_srcref, stmts, lhs, rhs, is_const)
    n_lhs = numchildren(lhs)
    iterstate = n_lhs > 0 ? new_local_binding(ctx, rhs, "iterstate") : nothing

    end_stmts = SyntaxList(ctx)
    wrap(asgn) = is_const ? (@ast ctx assignment_srcref [K"const" asgn]) : asgn

    i = 0
    for lh in children(lhs)
        i += 1
        if kind(lh) == K"..."
            lh1 = if is_identifier_like(lh[1]) && !is_const
                lh[1]
            else
                lhs_tmp = ssavar(ctx, lh[1], "lhs_tmp")
                push!(end_stmts, expand_forms_2(ctx, wrap(@ast ctx lh[1] [K"=" lh[1] lhs_tmp])))
                lhs_tmp
            end
            if i == n_lhs
                # Slurping as last lhs, eg, for `zs` in
                #   (x, y, zs...) = rhs
                if kind(lh1) != K"Placeholder"
                    push!(stmts, expand_forms_2(ctx,
                        @ast ctx assignment_srcref [K"="
                            lh1
                            [K"call"
                                "rest"::K"top"
                                rhs
                                if i > 1
                                    iterstate
                                end
                            ]
                        ]
                    ))
                end
            else
                # Slurping before last lhs. Eg, for `xs` in
                #   (xs..., y, z) = rhs
                # For this we call
                #   (xs, tail) = Base.split_rest(...)
                # then continue iteration with `tail` as new rhs.
                tail = ssavar(ctx, lh, "tail")
                push!(stmts,
                    expand_forms_2(ctx,
                        lower_tuple_assignment(ctx,
                            assignment_srcref,
                            (lh1, tail),
                            @ast ctx assignment_srcref [K"call"
                                "split_rest"::K"top"
                                rhs
                                (n_lhs - i)::K"Integer"
                                if i > 1
                                    iterstate
                                end
                            ]
                        )
                    )
                )
                rhs = tail
                n_lhs = n_lhs - i
                i = 0
```

</details>

#### 2. Simplify named-tuple expansion loop by iterating directly over keyword entries (removing unused enumerate index).

**Component**: JuliaLowering/desugaring

<details>
<summary>Evidence</summary>

**JuliaLowering/src/desugaring.jl:1614-1689**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4f713be0b388a1f2bce33f4e96b77635a7393135/JuliaLowering/src/desugaring.jl#L1614-L1689)
```julia
function expand_named_tuple(ctx, ex, kws, eq_is_kw;
                            field_name="named tuple field",
                            element_name="named tuple element")
    name_strs = Set{String}()
    names = SyntaxList(ctx)
    values = SyntaxList(ctx)
    current_nt = nothing
    for kw in kws
        k = kind(kw)
        appended_nt = nothing
        name = nothing
        if kind(k) == K"Identifier"
            # x  ==>  x = x
            name = to_symbol(ctx, kw)
            value = kw
        elseif k == K"kw" || (eq_is_kw && k == K"=")
            # syntax TODO: This should parse to K"kw"
            # x = a
            if kind(kw[1]) != K"Identifier" && kind(kw[1]) != K"Placeholder"
                throw(LoweringError(kw[1], "invalid $field_name name"))
            end
            if kind(kw[2]) == K"..."
                throw(LoweringError(kw[2], "`...` cannot be used in a value for a $field_name"))
            end
            name = to_symbol(ctx, kw[1])
            value = kw[2]
        elseif k == K"."
            # a.x ==> x=a.x
            if kind(kw[2]) != K"Symbol"
                throw(LoweringError(kw, "invalid $element_name"))
            end
            name = to_symbol(ctx, kw[2])
            value = kw
        elseif k == K"call" && is_infix_op_call(kw) && numchildren(kw) == 3 &&
                is_same_identifier_like(kw[1], "=>")
            # a=>b   ==>  $a=b
            appended_nt = _named_tuple_expr(ctx, kw, (kw[2],), (kw[3],))
            nothing, nothing
        elseif k == K"..."
            # args...  ==> splat pairs
            appended_nt = kw[1]
            if isnothing(current_nt) && isempty(names)
                # Must call merge to create NT from an initial splat
                current_nt = _named_tuple_expr(ctx, ex, (), ())
            end
            nothing, nothing
        else
            throw(LoweringError(kw, "Invalid $element_name"))
        end
        if !isnothing(name)
            if kind(name) == K"Symbol"
                name_str = name.name_val
                if name_str in name_strs
                    throw(LoweringError(name, "Repeated $field_name name"))
                end
                push!(name_strs, name_str)
            end
            push!(names, name)
            push!(values, value)
        end
        if !isnothing(appended_nt)
            if !isempty(names)
                current_nt = _merge_named_tuple(ctx, ex, current_nt,
                                                _named_tuple_expr(ctx, ex, names, values))
                empty!(names)
                empty!(values)
            end
            current_nt = _merge_named_tuple(ctx, ex, current_nt, appended_nt)
        end
    end
    if !isempty(names) || isnothing(current_nt)
        current_nt = _merge_named_tuple(ctx, ex, current_nt,
                                        _named_tuple_expr(ctx, ex, names, values))
    end
    @assert !isnothing(current_nt)
    current_nt
end
```

</details>

#### 3. Ensure all locals in analyze_type_sig are defined before use by asserting name, type_params, and supertype are initialized, improving diagnostics for invalid type signatures.

**Component**: JuliaLowering/desugaring

<details>
<summary>Evidence</summary>

**JuliaLowering/src/desugaring.jl:3466-3493**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4f713be0b388a1f2bce33f4e96b77635a7393135/JuliaLowering/src/desugaring.jl#L3466-L3493)
```julia
function analyze_type_sig(ctx, ex)
    k = kind(ex)
    if k == K"Identifier"
        name = ex
        type_params = ()
        supertype = @ast ctx ex "Any"::K"core"
    elseif k == K"curly" && numchildren(ex) >= 1 && kind(ex[1]) == K"Identifier"
        # name{type_params}
        name = ex[1]
        type_params = ex[2:end]
        supertype = @ast ctx ex "Any"::K"core"
    elseif k == K"<:" && numchildren(ex) == 2
        if kind(ex[1]) == K"Identifier"
            name = ex[1]
            type_params = ()
            supertype = ex[2]
        elseif kind(ex[1]) == K"curly" && numchildren(ex[1]) >= 1 && kind(ex[1][1]) == K"Identifier"
            name = ex[1][1]
            type_params = ex[1][2:end]
            supertype = ex[2]
        end
    end
    @isdefined(name) || throw(LoweringError(ex, "invalid type signature"))
    @isdefined(type_params) || throw(LoweringError(ex, "invalid type signature"))
    @isdefined(supertype) || throw(LoweringError(ex, "invalid type signature"))

    return (name, type_params, supertype)
end
```

</details>

#### 4. Normalize nbits assignment in abstract/primitive type lowering by defining it for both paths (abstract types set it to nothing).

**Component**: JuliaLowering/desugaring

<details>
<summary>Evidence</summary>

**JuliaLowering/src/desugaring.jl:3520-3548**
[View on GitHub](https://github.com/JuliaLang/julia/blob/4f713be0b388a1f2bce33f4e96b77635a7393135/JuliaLowering/src/desugaring.jl#L3520-L3548)
```julia
function expand_abstract_or_primitive_type(ctx, ex)
    is_abstract = kind(ex) == K"abstract"
    if is_abstract
        @chk numchildren(ex) == 1
    else
        @assert kind(ex) == K"primitive"
        @chk numchildren(ex) == 2
    end
    nbits = is_abstract ? nothing : ex[2]
    name, type_params, supertype = analyze_type_sig(ctx, ex[1])
    typevar_names, typevar_stmts = expand_typevars(ctx, type_params)
    newtype_var = ssavar(ctx, ex, "new_type")
    @ast ctx ex [K"block"
        [K"scope_block"(scope_type=:hard)
            [K"block"
                [K"local" name]
                [K"always_defined" name]
                typevar_stmts...
                [K"="
                    newtype_var
                    [K"call"
                        (is_abstract ? "_abstracttype" : "_primitivetype")::K"core"
                        ctx.mod::K"Value"
                        name=>K"Symbol"
                        [K"call" "svec"::K"core" typevar_names...]
                        if !is_abstract
                            nbits
                        end
                    ]
                ]
                [K"=" name newtype_var]
                [K"call" "_setsuper!"::K"core" newtype_var supertype]
                [K"call" "_typebody!"::K"core" false::K"Bool" name]
            ]
        ]
        [K"assert" "toplevel_only"::K"Symbol" [K"inert" ex] ]
        [K"global" name]
        [K"if"
            [K"&&"
                [K"call"
                   "isdefinedglobal"::K"core"
                   ctx.mod::K"Value"
                   name=>K"Symbol"
                   false::K"Bool"]
                [K"call" "_equiv_typedef"::K"core" name newtype_var]
            ]
```

</details>

### Secondary Effects

#### Invalid type signatures now trigger LoweringError before any later use of uninitialized locals, improving static analyses that track variable definedness.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
analyze_type_sig(ctx, ex)  [desugaring.jl:3466-3492]
  -> @isdefined(type_params) / @isdefined(supertype) checks for invalid type signatures
  -> expand_abstract_or_primitive_type(ctx, ex)  [desugaring.jl:3520-3548]
     consumes (name, type_params, supertype) for abstract/primitive definitions
  -> expand_struct_def(ctx, ex, docs)  [desugaring.jl:4011]
     consumes (struct_name, type_params, supertype) for struct definitions
```
</details>

**Downstream Surfaces:**
- JET lowering analysis (tracks isdefined on locals in JuliaLowering IR)
- Custom lowering diagnostics that rely on consistent LoweringError paths

### Compatibility

#### Internal API Changes
- **JuliaLowering.analyze_type_sig return tuple (name, type_params, supertype)**: Now guaranteed to throw LoweringError when type_params or supertype is not initialized, rather than leaving locals undefined.

#### Behavioral Changes
- Error reporting for malformed type signatures consistently raises LoweringError without risking uninitialized locals. *(Impact: Invalid type signature diagnostics match existing tests and remain `invalid type signature` but are now guarded for all locals.)*

### Performance

**Compile Time:**
- ESTIMATED: negligible. Additional @isdefined checks in analyze_type_sig are constant-time and only in type definition lowering.

**Runtime:**
- ESTIMATED: none. Changes are in lowering-time only.

### Risk Assessment

**Level**: low

**Rationale:**
- Edits are localized to JuliaLowering desugaring and do not change runtime code generation paths.
- Behavioral changes are mostly tighter diagnostics and removal of unused bindings.

### Recommendations

- No downstream action required; tooling that introspects lowering errors should see more consistently-defined locals.
