# PR #60411: [JuliaLowering] Miscellaneous fixes for `SparseArrays` precompilation

## Metadata

- **Author**: topolarity
- **URL**: https://github.com/JuliaLang/julia/pull/60411
- **Merged**: 2025-12-18 18:53 UTC
- **Labels**: `bugfix`, `JuliaLowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60411.diff

## Scope

### Files Touched
- `JuliaLowering/src/compat.jl`
- `JuliaLowering/src/desugaring.jl`
- `JuliaLowering/src/eval.jl`
- `JuliaLowering/test/compat.jl`
- `JuliaLowering/test/macros.jl`
- `JuliaLowering/test/typedefs.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering

## Analysis

### Intent

Fix JuliaLowering regressions encountered during SparseArrays precompilation, including Unicode operator handling, type-alias where expansion, and boundscheck lowering in expr compatibility mode.

**Related Issues:**
- https://github.com/JuliaLang/JuliaLowering.jl/issues/123

### Direct Changes

#### 1. Fix Unicode updating-assignment operators in expr->SyntaxTree conversion by slicing operator strings with `nextind`/`prevind`, avoiding invalid string indexing for multi-byte operators.

**Component**: JuliaLowering/src/compat.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/compat.jl:240-252**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/compat.jl#L240-L252)
```julia
if Base.isoperator(e.head) && st_k === K"None"
    # e.head is an updating assignment operator (+=, .-=, etc).  Non-=
    # dotted ops are wrapped in a call, so we don't reach this.
    s = string(e.head)
    @assert s[end] === '=' && nargs === 2
    if s[1] === '.'
        st_k = K".op="
        op = s[nextind(s,1):prevind(s,end)]
    else
        st_k = K"op="
        op = s[1:prevind(s,end)]
    end
    child_exprs = Any[e.args[1], Symbol(op), e.args[2]]
```

**JuliaLowering/test/compat.jl:638-642**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/test/compat.jl#L638-L642)
```julia
@testset "non-ASCII operator handling" begin
    # regression test for invalid string index
    @test JuliaLowering.include_string(test_mod, raw"""
    @noinline (x = 0xF; x ⊻= 1; x)
    """; expr_compat_mode=true) == 0xE
end
```

</details>

#### 2. Ensure `where` expansion for type-alias definitions with multiple type variables always wraps parameters in `braces`, preserving correct `UnionAll` structure.

**Component**: JuliaLowering/src/desugaring.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/desugaring.jl:1246-1258**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/desugaring.jl#L1246-L1258)
```julia
function expand_unionall_def(ctx, srcref, lhs, rhs, is_const=true)
    if numchildren(lhs) <= 1
        throw(LoweringError(lhs, "empty type parameter list in type alias"))
    end
    name = lhs[1]
    expand_forms_2(
        ctx,
        @ast ctx srcref [K"block"
            rr := [K"where" rhs [K"braces" lhs[2:end]...]]
            [is_const ? K"constdecl" : K"assign_or_constdecl_if_global" name rr]
            [K"removable" rr]
        ]
    )
end
```

**JuliaLowering/test/typedefs.jl:316-322**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/test/typedefs.jl#L316-L322)
```julia
# Definition of type-alias with 2+ type-variables
# See https://github.com/JuliaLang/JuliaLowering.jl/issues/123
JuliaLowering.include_string(test_mod, """
struct Foo{T,V,N}; end
const Bar{T,V} = Foo{T,V,1}
""")
@test test_mod.Bar == (test_mod.Foo{T,V,1} where {T,V})
```

</details>

#### 3. Add explicit boundscheck handling in lowered Expr conversion so `@boundscheck` forms survive expr compatibility mode.

**Component**: JuliaLowering/src/eval.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/eval.jl:426-452**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/eval.jl#L426-L452)
```julia
# Allowed forms according to https://docs.julialang.org/en/v1/devdocs/ast/
#
# call invoke static_parameter `=` method struct_type abstract_type
# primitive_type global const new splatnew isdefined
# enter leave pop_exception inbounds boundscheck loopinfo copyast meta
# lambda
head = k == K"call"      ? :call       :
       k == K"new"       ? :new        :
       k == K"splatnew"  ? :splatnew   :
       k == K"="         ? :(=)        :
       k == K"leave"     ? :leave      :
       k == K"isdefined" ? :isdefined  :
       k == K"loopinfo"  ? :loopinfo   :
       k == K"boundscheck"       ? :boundscheck       :
       k == K"latestworld"       ? :latestworld       :
       k == K"pop_exception"     ? :pop_exception     :
       k == K"captured_local"    ? :captured_local    :
       k == K"gc_preserve_begin" ? :gc_preserve_begin :
       k == K"gc_preserve_end"   ? :gc_preserve_end   :
       k == K"foreigncall"       ? :foreigncall       :
       k == K"cfunction"         ? :cfunction         :
       k == K"new_opaque_closure" ? :new_opaque_closure :
       nothing
```

**JuliaLowering/test/macros.jl:616-635**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/test/macros.jl#L616-L635)
```julia
@testset "@boundscheck / @inbounds" begin
    JuliaLowering.include_string(test_mod, """
    function sum_inbounds(A::AbstractArray)
        r = zero(eltype(A))
        for i in eachindex(A)
            @inbounds r += A[i]
        end
        return r
    end
    """; expr_compat_mode=true)
    @test test_mod.sum_inbounds([1,2,3]) == 6

    JuliaLowering.include_string(test_mod, """
    @inline function g_boundscheck(A, i)
        @boundscheck checkbounds(A, i)
        return A[i]
    end
    """; expr_compat_mode=true)
    @test test_mod.g_boundscheck(1:2, 2) == 2
end
```

</details>

#### 4. Assert that `where` expressions always have two children in `expand_wheres`, tightening invariants for desugaring.

**Component**: JuliaLowering/src/desugaring.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/desugaring.jl:4178-4206**
[View on GitHub](https://github.com/JuliaLang/julia/blob/3b1a5b6c52955394ac98772d0de36ffd66401fbc/JuliaLowering/src/desugaring.jl#L4178-L4206)
```julia
function expand_where(ctx, srcref, lhs, rhs)
    bounds = analyze_typevar(ctx, rhs)
    v = bounds[1]
    @ast ctx srcref [K"let"
        [K"block" [K"=" v bounds_to_TypeVar(ctx, srcref, bounds)]]
        [K"call" "UnionAll"::K"core" v lhs]
    ]
end

function expand_wheres(ctx, ex)
    @chk numchildren(ex) == 2
    body = ex[1]
    rhs = ex[2]
    if kind(rhs) == K"braces"
        # S{X,Y} where {X,Y}
        for r in reverse(children(rhs))
            body = expand_where(ctx, ex, body, r)
        end
    elseif kind(rhs) == K"_typevars"
        # Eg, `S{X,Y} where {X, Y}` but with X and Y
        # already allocated `TypeVar`s
        for r in reverse(children(rhs[1]))
            body = @ast ctx ex [K"call" "UnionAll"::K"core" r body]
        end
    else
        # S{X} where X
        body = expand_where(ctx, ex, body, rhs)
    end
    body
end
```

</details>

### Secondary Effects

#### Expr compatibility mode now correctly lowers non-ASCII updating assignment operators like `⊻=` without raising string indexing errors.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
expr_to_syntaxtree(e, lnn)  [compat.jl:25-47]
  -> _insert_convert_expr(e, graph, src)  [compat.jl:186-252]
    -> operator slicing uses nextind/prevind for Unicode-safe indexing  [compat.jl:244-250]
```
</details>

**Downstream Surfaces:**
- Expr-producing macros relying on expr_to_syntaxtree (e.g., legacy macro expansion paths)
- Precompilation paths in packages that emit updating operators (SparseArrays)

#### Type-alias definitions with multiple type variables expand to `UnionAll` chains using braces, restoring expected `Foo{T,V,1} where {T,V}` structure.

**Likelihood**: medium | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
expand_assignment(ctx, ex, is_const)  [desugaring.jl:1268-1279]
  -> expand_unionall_def(ctx, srcref, lhs, rhs)  [desugaring.jl:1246-1258]
    -> emits rr := [K"where" rhs [K"braces" lhs[2:end]...]]
  -> expand_wheres(ctx, ex) validates numchildren == 2  [desugaring.jl:4187-4206]
```
</details>

**Downstream Surfaces:**
- Macro-generated type aliases with multiple parameters
- Tools inspecting lowered type-alias `UnionAll` structure

#### `@boundscheck` forms survive expr compatibility lowering, enabling precompile-time evaluation of boundscheck wrappers.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
_to_lowered_expr(ex::SyntaxTree, stmt_offset)  [eval.jl:420-456]
  maps K"boundscheck" -> :boundscheck Expr head
  used by eval(mod, ex::SyntaxTree)  [eval.jl:462-467]
```
</details>

**Downstream Surfaces:**
- Generated code that uses @boundscheck/@inbounds in expr_compat_mode
- SparseArrays precompilation that relies on boundscheck wrappers

### Compatibility

#### Behavioral Changes
- Behavioral fix: expr->SyntaxTree conversion no longer throws on Unicode updating operators in expr_compat_mode.
- Behavioral fix: type-alias `where` expansion now preserves multiple type-variable structure.
- Behavioral fix: boundscheck AST nodes are accepted in lowered Expr conversion.

### Performance

**Compile Time:**
- ESTIMATED: negligible; changes are simple indexing/validation and do not add extra passes.

**Runtime:**
- ESTIMATED: none; modifications affect lowering/compatibility paths only.

### Risk Assessment

**Level**: low

**Rationale:**
- Changes are localized to JuliaLowering compatibility/desugaring logic with targeted regression tests.
- No changes to inference, codegen, or runtime execution semantics beyond bug fixes.

### Recommendations

- Downstream tooling relying on expr_compat_mode should add coverage for Unicode updating operators and boundscheck forms similar to the new tests.
