# PR #60198: JuliaSyntax tokenize.jl:  don‘t hardcode unicode ops range

## Metadata

- **Author**: pthariensflame
- **URL**: https://github.com/JuliaLang/julia/pull/60198
- **Merged**: 2025-11-22 04:18 UTC
- **Labels**: `parser`
- **Diff**: https://github.com/JuliaLang/julia/pull/60198.diff

## Scope

### Files Touched
- `JuliaSyntax/src/julia/tokenize.jl`

### Components
- JuliaSyntax

### Pipeline Stages
- Parsing

## Analysis

### Intent

Use the JuliaSyntax BEGIN_UNICODE_OPS/END_UNICODE_OPS token range instead of a hardcoded Unicode operator span when deciding which operators can take suffixes.

**Related Issues:**
- https://github.com/JuliaLang/JuliaSyntax.jl/pull/404

### Direct Changes

#### 1. optakessuffix now checks the BEGIN_UNICODE_OPS/END_UNICODE_OPS token range rather than a literal Unicode codepoint span, keeping suffix eligibility aligned with the operator kind table.

**Component**: JuliaSyntax tokenization

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/julia/tokenize.jl:153-177**
[View on GitHub](https://github.com/JuliaLang/julia/blob/9b7f64d6d0b73560d253745dd218a557aa901727/JuliaSyntax/src/julia/tokenize.jl#L153-L177)
```julia
function optakessuffix(k)
    (K"BEGIN_OPS" <= k <= K"END_OPS") &&
    !(
        k == K"..." ||
        K"BEGIN_ASSIGNMENTS" <= k <= K"END_ASSIGNMENTS" ||
        k == K"?"   ||
        k == K"<:"  ||
        k == K">:"  ||
        k == K"&&"  ||
        k == K"||"  ||
        k == K"in"  ||
        k == K"isa" ||
        k == K"≔"   ||
        k == K"⩴"   ||
        k == K":"   ||
        k == K".."  ||
        k == K"$"   ||
        k == K"::"  ||
        k == K"where" ||
        k == K"."   ||
        k == K"!"   ||
        k == K".'"  ||
        k == K"->"  ||
        K"BEGIN_UNICODE_OPS" <= k <= K"END_UNICODE_OPS"
    )
end
```

**JuliaSyntax/src/julia/tokenize.jl:153-177**
[View on GitHub](https://github.com/JuliaLang/julia/blob/9af9b15844705c0d82fcf3ba4878e5e0e2983982/JuliaSyntax/src/julia/tokenize.jl#L153-L177)
```julia
function optakessuffix(k)
    (K"BEGIN_OPS" <= k <= K"END_OPS") &&
    !(
        k == K"..." ||
        K"BEGIN_ASSIGNMENTS" <= k <= K"END_ASSIGNMENTS" ||
        k == K"?"   ||
        k == K"<:"  ||
        k == K">:"  ||
        k == K"&&"  ||
        k == K"||"  ||
        k == K"in"  ||
        k == K"isa" ||
        k == K"≔"   ||
        k == K"⩴"   ||
        k == K":"   ||
        k == K".."  ||
        k == K"$"   ||
        k == K"::"  ||
        k == K"where" ||
        k == K"."   ||
        k == K"!"   ||
        k == K".'"  ||
        k == K"->"  ||
        K"¬" <= k <= K"∜"
    )
end
```

</details>

#### 2. Tokenizer tests already assert that suffixed operators round-trip through tokenization, providing a concrete behavior baseline for this change.

**Component**: JuliaSyntax tests

<details>
<summary>Evidence</summary>

**JuliaSyntax/test/tokenize.jl:883-892**
[View on GitHub](https://github.com/JuliaLang/julia/blob/9b7f64d6d0b73560d253745dd218a557aa901727/JuliaSyntax/test/tokenize.jl#L883-L892)
```julia
@testset "suffixed op" begin
    s = "+¹"
    @test is_operator(tok(s, 1).kind)
    @test untokenize(collect(tokenize(s))[1], s) == s
end
```

</details>

### Secondary Effects

#### When the BEGIN_UNICODE_OPS/END_UNICODE_OPS list is extended in kinds.jl, optakessuffix will automatically treat new Unicode operator kinds as suffix-capable without needing another hardcoded span update.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
optakessuffix(k) uses BEGIN_UNICODE_OPS/END_UNICODE_OPS [tokenize.jl:153-176]
  -> emit(l, kind) sets RawToken suffix when optakessuffix(kind) is true [tokenize.jl:430-439]
  -> parser predicates like is_plain_equals() branch on is_suffixed(token) [parser.jl:225-231]
```
</details>

**Downstream Surfaces:**
- JuliaSyntax tokenization / parse flags

### Compatibility

### Performance

### Risk Assessment

**Level**: low

**Rationale:**
- The change replaces a hardcoded Unicode operator range with existing token kind sentinels, so it is unlikely to affect current operator classification.

### Recommendations

- If the BEGIN_UNICODE_OPS list changes in the future, consider adding or updating tokenizer tests that exercise suffixed operators in the new range.
