# PR #60199: Reject decimal points after hex float literals

## Metadata

- **Author**: Keno
- **URL**: https://github.com/JuliaLang/julia/pull/60199
- **Merged**: 2025-11-22 04:19 UTC
- **Labels**: `parser`, `bugfix`
- **Diff**: https://github.com/JuliaLang/julia/pull/60199.diff

## Scope

### Files Touched
- `JuliaSyntax/src/julia/tokenize.jl`
- `JuliaSyntax/test/tokenize.jl`
- `test/syntax.jl`

### Components
- JuliaSyntax

### Pipeline Stages
- Parsing

## Analysis

### Intent

Reject hex float literals followed by a decimal point or decimal digits to avoid implicit multiplication ambiguities (issue #60189).

**Related Issues:**
- https://github.com/JuliaLang/julia/issues/60189

### Direct Changes

#### 1. Lexer now rejects hex float literals that have a trailing decimal point or decimal digits after the exponent.

**Component**: JuliaSyntax tokenization

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/julia/tokenize.jl:1045-1067**
[View on GitHub](https://github.com/JuliaLang/julia/blob/59ff9f957b9bff31d34986d55521966a5452791d/JuliaSyntax/src/julia/tokenize.jl#L1045-L1067)
```julia
if accept(l, "pP")
    kind = K"Float"
    accept(l, "+-âˆ’")
    if !accept_number(l, isdigit) || !had_digits
        return emit(l, K"ErrorInvalidNumericConstant") # `0x1p` `0x.p0`
    end
    # Check for invalid trailing decimal point
    # https://github.com/JuliaLang/julia/issues/60189
    pc = peekchar(l)
    if pc == '.'
        accept_batch(l, c->(c == '.' || isdigit(c)))
        # `0x1p3.` `0x1p3.2` `0x1.5p2.3`
        return emit(l, K"ErrorInvalidNumericConstant")
    end
elseif isfloat
    return emit(l, K"ErrorHexFloatMustContainP") # `0x.` `0x1.0`
end
```

</details>

#### 2. Tokenizer tests lock in the new rejection of trailing decimal points/digits after hex float exponents.

**Component**: JuliaSyntax tests

<details>
<summary>Evidence</summary>

**JuliaSyntax/test/tokenize.jl:626-638**
[View on GitHub](https://github.com/JuliaLang/julia/blob/59ff9f957b9bff31d34986d55521966a5452791d/JuliaSyntax/test/tokenize.jl#L626-L638)
```julia
# errors
@test onlytok("0x") == K"ErrorInvalidNumericConstant"
@test onlytok("0x2__2") == K"ErrorInvalidNumericConstant"
@test onlytok("0x1p") == K"ErrorInvalidNumericConstant"
@test onlytok("0x.p0") == K"ErrorInvalidNumericConstant"
@test onlytok("0x.")   == K"ErrorHexFloatMustContainP"
@test onlytok("0x1.0") == K"ErrorHexFloatMustContainP"
# https://github.com/JuliaLang/julia/issues/60189
@test onlytok("0x1p3.") == K"ErrorInvalidNumericConstant"
@test onlytok("0x1p3.2") == K"ErrorInvalidNumericConstant"
@test onlytok("0x1.5p2.3") == K"ErrorInvalidNumericConstant"
```

</details>

#### 3. Parser-level test asserts the new parse error for a hex float followed by decimal digits.

**Component**: parser tests

<details>
<summary>Evidence</summary>

**test/syntax.jl:1684-1689**
[View on GitHub](https://github.com/JuliaLang/julia/blob/59ff9f957b9bff31d34986d55521966a5452791d/test/syntax.jl#L1684-L1689)
```julia
# #16356
@test_parseerror "0xapi"

# #60189
@test_parseerror "0x1p3.2"
```

</details>

### Secondary Effects

#### Expressions like 0x1p3.2 now emit ErrorInvalidNumericConstant instead of tokenizing as a hex float followed by a dot/decimal sequence, which prevents implicit multiplication parsing downstream.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
lex_token(l) dispatch on digit  [JuliaSyntax/src/julia/tokenize.jl:520-535]
  -> lex_digit(l, K"Integer")
lex_digit(l, kind)  [JuliaSyntax/src/julia/tokenize.jl:1045-1067]
  -> peekchar(l) after hex float exponent
  -> emit(l, K"ErrorInvalidNumericConstant") on trailing '.' or digits
-> parser sees ErrorInvalidNumericConstant token and raises parse error
```
</details>

**Downstream Surfaces:**
- JuliaSyntax token stream consumers
- Base parser error handling

### Compatibility

#### Behavioral Changes
- Source text like 0x1p3.2 (previously lexed into tokens allowing implicit multiplication) now raises a parse error; affected code must insert explicit operators or whitespace.

### Performance

**Compile Time:**
- ESTIMATED: Adds a peek and potential accept_batch after parsing hex float exponents; O(k) scan over trailing digits/dots in the invalid-case only. Expected negligible impact in valid code.

### Risk Assessment

**Level**: low

**Rationale:**
- Change is limited to JuliaSyntax lexing of hex float literals and guarded by tests for the exact new error cases.

### Recommendations

- Downstream tooling that tokenizes Julia source (e.g., formatters or syntax highlighters built on JuliaSyntax) should expect ErrorInvalidNumericConstant for 0x1p3.2-style inputs and handle it as a hard error rather than implicit multiplication.
