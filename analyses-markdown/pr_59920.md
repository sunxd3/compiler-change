# PR #59920: Backports for 1.12.2

## Metadata

- **Author**: KristofferC
- **URL**: https://github.com/JuliaLang/julia/pull/59920
- **Merged**: 2025-11-13 10:43 UTC
- **Labels**: `release`, `don't squash`
- **Diff**: https://github.com/JuliaLang/julia/pull/59920.diff

## Scope

### Files Touched
- `Compiler/src/abstractinterpretation.jl`
- `Compiler/src/tfuncs.jl`
- `Compiler/src/typeinfer.jl`
- `Compiler/test/effects.jl`

### Components
- Compiler.AbstractInterpretation
- Compiler.TypeInference
- Compiler.Tfuncs
- Compiler.Tests

### Pipeline Stages
- TypeInference
- ConstProp
- Effects

## Analysis

### Intent

Backport inference and effects fixes for the 1.12.2 release, including concrete-eval guardrails, cycle backedge handling, and pointer arithmetic tfunc behavior.

**Related Issues:**
- https://github.com/JuliaLang/julia/issues/60009

### Direct Changes

#### 1. Guard concrete-evaluation results so external abstract interpreters can disable concrete-eval ad hoc without breaking const-prop fallback.

**Component**: Compiler.AbstractInterpretation

<details>
<summary>Evidence</summary>

**Compiler/src/abstractinterpretation.jl:865-899**
[View on GitHub](https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/abstractinterpretation.jl#L865-L899)
```julia
function abstract_call_method_with_const_args(interp::AbstractInterpreter,
    result::MethodCallResult, @nospecialize(f), arginfo::ArgInfo, si::StmtInfo,
    match::MethodMatch, sv::AbsIntState, invokecall::Union{Nothing,InvokeCall}=nothing)
    if bail_out_const_call(interp, result, si, match, sv)
        return nothing
    end
    eligibility = concrete_eval_eligible(interp, f, result, arginfo, sv)
    concrete_eval_result = nothing
    if eligibility === :concrete_eval
        concrete_eval_result = concrete_eval_call(interp, f, result, arginfo, sv, invokecall)
        if (concrete_eval_result !== nothing &&  # allow external abstract interpreters to disable concrete evaluation ad-hoc
            # if we don't inline the result of this concrete evaluation,
            # give const-prop' a chance to inline a better method body
            (!may_optimize(interp) ||
             may_inline_concrete_result(concrete_eval_result.const_result::ConcreteResult) ||
             concrete_eval_result.rt === Bottom)) # unless this call deterministically throws and thus is non-inlineable
            return concrete_eval_result
        end
        # TODO allow semi-concrete interp for this call?
    end
    mi = maybe_get_const_prop_profitable(interp, result, f, arginfo, si, match, sv)
    mi === nothing && return concrete_eval_result
    if is_constprop_recursed(result, mi, sv)
        add_remark!(interp, sv, "[constprop] Edge cycle encountered")
        return nothing
    end
    # try semi-concrete evaluation
    if eligibility === :semi_concrete_eval
        irinterp_result = semi_concrete_eval_call(interp, mi, result, arginfo, sv)
        if irinterp_result !== nothing
            return irinterp_result
        end
    end
    # try constant prop'
    return const_prop_call(interp, mi, result, arginfo, sv, concrete_eval_result)
end
```

</details>

#### 2. Type-assert futures inside nonlinearized foreigncall evaluation to avoid ambiguous local variable types.

**Component**: Compiler.AbstractInterpretation

<details>
<summary>Evidence</summary>

**Compiler/src/abstractinterpretation.jl:3452-3488**
[View on GitHub](https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/abstractinterpretation.jl#L3452-L3488)
```julia
function abstract_eval_nonlinearized_foreigncall_name(
        interp::AbstractInterpreter, @nospecialize(e), sstate::StatementState, sv::InferenceState
    )
    if isexpr(e, :call)
        n = length(e.args)
        argtypes = Vector{Any}(undef, n)
        callresult = Future{CallMeta}()
        i::Int = 1
        nextstate::UInt8 = 0x0
        local ai::Future, res::Future
        function evalargs(interp, sv)
            if nextstate === 0x1
                @goto state1
            elseif nextstate === 0x2
                @goto state2
            end
            while i <= n
                ai = abstract_eval_nonlinearized_foreigncall_name(interp, e.args[i], sstate, sv)
                if !isready(ai)
                    nextstate = 0x1
                    return false
                    @label state1
                end
                argtypes[i] = ai[].rt
                i += 1
            end
            res = abstract_call(interp, ArgInfo(e.args, argtypes), sstate, sv)
            if !isready(res)
                nextstate = 0x2
                return false
                @label state2
            end
            callresult[] = res[]
            return true
        end
        evalargs(interp, sv) || push!(sv.tasks, evalargs)
        return callresult
    else
        return Future(abstract_eval_basic_statement(interp, e, sstate, sv))
    end
end
```

</details>

#### 3. Pointer arithmetic tfunc now widens const pointers, and the pointer add/sub tfunc hooks remain the call sites.

**Component**: Compiler.Tfuncs

<details>
<summary>Evidence</summary>

**Compiler/src/tfuncs.jl:715-717**
[View on GitHub](https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/tfuncs.jl#L715-L717)
```julia
@nospecs function pointerarith_tfunc(ùïÉ::AbstractLattice, ptr, offset)
    return widenconst(ptr)
end
```

**Compiler/src/tfuncs.jl:761-762**
[View on GitHub](https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/tfuncs.jl#L761-L762)
```julia
add_tfunc(add_ptr, 2, 2, pointerarith_tfunc, 1)
add_tfunc(sub_ptr, 2, 2, pointerarith_tfunc, 1)
```

**Compiler/test/effects.jl:1483-1487**
[View on GitHub](https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/test/effects.jl#L1483-L1487)
```julia
# https://github.com/JuliaLang/julia/issues/60009
function null_offset(offset)
    Ptr{UInt8}(C_NULL) + offset
end
@test null_offset(Int(100)) == Ptr{UInt8}(UInt(100))
```

</details>

#### 4. Cycle resolution no longer injects backedges during merge; backedges are now added explicitly when returning inferred/cycle results.

**Component**: Compiler.TypeInference

<details>
<summary>Evidence</summary>

**Compiler/src/typeinfer.jl:763-780**
[View on GitHub](https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/typeinfer.jl#L763-L780)
```julia
function merge_call_chain!(::AbstractInterpreter, parent::InferenceState, child::InferenceState)
    # update all cycleid to be in the same group
    frames = parent.callstack::Vector{AbsIntState}
    @assert child.callstack === frames
    ancestorid = child.cycleid
    # ensure that walking the callstack has the same cycleid (DAG)
    for frameid = reverse(ancestorid:length(frames))
        frame = frames[frameid]::InferenceState
        frame.cycleid == ancestorid && break
        @assert frame.cycleid > ancestorid
        frame.cycleid = ancestorid
    end
end

function add_cycle_backedge!(caller::InferenceState, frame::InferenceState)
    backedge = (caller, caller.currpc)
    contains_is(frame.cycle_backedges, backedge) || push!(frame.cycle_backedges, backedge)
    return frame
end
```

**Compiler/src/typeinfer.jl:966-1006**
[View on GitHub](https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/typeinfer.jl#L966-L1006)
```julia
let mresult = Future{MethodCallResult}()
    push!(caller.tasks, function get_infer_result(interp, caller)
        update_valid_age!(caller, frame.world.valid_worlds)
        local isinferred = is_inferred(frame)
        local edge = isinferred ? edge_ci : nothing
        local effects, valid_worlds
        if isinferred
            effects = frame.result.ipo_effects # effects are adjusted already within `finish` for ipo_effects
        else
            (effects, valid_worlds) = adjust_effects(effects_for_cycle(frame.ipo_effects), method, frame.world.this)
            update_valid_age!(caller, valid_worlds)
        end
        local bestguess = frame.bestguess
        local exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)
        # propagate newly inferred source to the inliner, allowing efficient inlining w/o deserialization:
        # note that this result is cached globally exclusively, so we can use this local result destructively
        local volatile_inf_result = if isinferred && edge_ci isa CodeInstance
            result.ci_as_edge = edge_ci # set the edge for the inliner usage
            VolatileInferenceResult(result)
        end
        isinferred || add_cycle_backedge!(caller, frame)
        mresult[] = MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects,
            edge, edgecycle, edgelimited, volatile_inf_result)
        return true
    end)
    return mresult
end
# return the current knowledge about this cycle
frame = frame::InferenceState
update_valid_age!(caller, frame.world.valid_worlds)
(effects, valid_worlds) = adjust_effects(effects_for_cycle(frame.ipo_effects), method, frame.world.this)
update_valid_age!(caller, valid_worlds)
bestguess = frame.bestguess
exc_bestguess = refine_exception_type(frame.exc_bestguess, effects)
add_cycle_backedge!(caller, frame)
return Future(MethodCallResult(interp, caller, method, bestguess, exc_bestguess, effects, nothing, edgecycle, edgelimited))
```

</details>

### Secondary Effects

#### External AbstractInterpreter implementations can return `nothing` from concrete evaluation without tripping const-prop access, letting const-prop or semi-concrete evaluation proceed.

**Likelihood**: medium | **Impact**: low

<details>
<summary>Mechanism</summary>

```
abstract_call_method_with_const_args(...) [Compiler/src/abstractinterpretation.jl:865-899]
  calls concrete_eval_call(...)
  -> skips the const-prop eligibility check unless concrete_eval_result !== nothing
  -> falls through to maybe_get_const_prop_profitable(...) and const_prop_call(...)
```
</details>

**Downstream Surfaces:**
- External AbstractInterpreter implementations
- Const-prop/inlining decisions when concrete eval is disabled

#### Pointer arithmetic on Const Ptr values now widens to non-Const pointer types, preventing overly precise const propagation around null-pointer arithmetic.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
pointerarith_tfunc(...) [Compiler/src/tfuncs.jl:715-717]
  returns widenconst(ptr)
add_tfunc(add_ptr/sub_ptr, pointerarith_tfunc, ...) [Compiler/src/tfuncs.jl:761-762]
  ensures Ptr +/- Int uses widened pointer inference
null_offset test covers C_NULL + offset -> Ptr{UInt8}(UInt(100)) [Compiler/test/effects.jl:1483-1487]
```
</details>

**Downstream Surfaces:**
- Inference of pointer arithmetic in Base/ccall code
- Effects inference relying on pointer arithmetic stability

#### Cycle backedge recording is deferred to edge resolution sites, improving consistency of cycle backedges for in-flight inference frames.

**Likelihood**: medium | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
resolve_call_cycle!(...) -> merge_call_chain!(...) updates cycleid only [Compiler/src/typeinfer.jl:763-818]
typeinf_edge(...) adds backedges when returning inferred or cycle results [Compiler/src/typeinfer.jl:966-1006]
```
</details>

**Downstream Surfaces:**
- Inference cycle resolution and invalidation tracking
- AbstractInterpreter consumers relying on cycle_backedges

### Compatibility

#### Behavioral Changes
- {'summary': 'Inference for pointer arithmetic on Const Ptr values now widens to the underlying pointer type rather than preserving Const, which can change inferred types for C_NULL + offset patterns.', 'evidence': [{'source': 'code', 'path': 'Compiler/src/tfuncs.jl', 'loc': '715-717', 'url': 'https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/src/tfuncs.jl#L715-L717', 'snippet': '@nospecs function pointerarith_tfunc(ùïÉ::AbstractLattice, ptr, offset)\n    return widenconst(ptr)\nend\n'}, {'source': 'test', 'path': 'Compiler/test/effects.jl', 'loc': '1483-1487', 'url': 'https://github.com/JuliaLang/julia/blob/d9323c0906ff3e30835a8d1b5cae37e78667b6ea/Compiler/test/effects.jl#L1483-L1487', 'snippet': '# https://github.com/JuliaLang/julia/issues/60009\nfunction null_offset(offset)\n    Ptr{UInt8}(C_NULL) + offset\nend\n@test null_offset(Int(100)) == Ptr{UInt8}(UInt(100))\n'}]}

### Performance

### Risk Assessment

**Level**: medium

**Rationale:**
- Type inference cycle handling changed backedge insertion timing, which can affect invalidation behavior in edge cases.
- Pointer arithmetic inference now widens Const pointers; downstream tooling depending on exact Const propagation may see different inferred types.

### Recommendations

- Downstream tools implementing AbstractInterpreter should confirm their concrete_eval_call hooks tolerate returning `nothing` without assuming a ConcreteResult.
- Packages that depend on Const pointer inference (e.g., C_NULL arithmetic in generated code) should add regression tests similar to null_offset.
