# PR #60169: [JuliaLowering] only hygienic-scope-wrap `toplevel` if unescaped

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60169
- **Merged**: 2025-11-19 17:56 UTC
- **Labels**: `compiler:lowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60169.diff

## Scope

### Files Touched
- `JuliaLowering/src/macro_expansion.jl`
- `JuliaLowering/test/macros.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering
- MacroExpansion

## Analysis

### Intent

Limit hygienic-scope wrapping for macro-expanded :toplevel forms to cases where the expansion occurs under a non-default scope layer, preserving escaped toplevel behavior while avoiding extra wrapping at the outer layer.

### Direct Changes

#### 1. Move :toplevel hygienic-scope wrapping to the general lowering pass, gating it on nested scope layers so only macro expansions in non-default layers are wrapped.

**Component**: JuliaLowering/src/macro_expansion.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/macro_expansion.jl:247-255**
[View on GitHub](https://github.com/JuliaLang/julia/blob/2315530f71b358b06c646d4f4124393da33719e8/JuliaLowering/src/macro_expansion.jl#L247-L255)
```julia
function fix_toplevel_expansion(ctx, ex::SyntaxTree, mod::Module, lnn::LineNumberNode)
    if kind(ex) === K"toplevel"
        mapchildren(ctx, ex) do e
            @ast ctx ex [K"hygienic_scope" e mod::K"Value" lnn::K"Value"]
        end
    else
        mapchildren(e->fix_toplevel_expansion(ctx, e, mod, lnn), ctx, ex)
    end
end
```

**JuliaLowering/src/macro_expansion.jl:454-459**
[View on GitHub](https://github.com/JuliaLang/julia/blob/2315530f71b358b06c646d4f4124393da33719e8/JuliaLowering/src/macro_expansion.jl#L454-L459)
```julia
elseif k == K"macrocall"
    expand_macro(ctx, ex)
elseif k == K"toplevel" && length(ctx.scope_layer_stack) > 1
    fix_toplevel_expansion(ctx, ex, current_layer(ctx).mod,
                           source_location(LineNumberNode, ex))
elseif k == K"module" || k == K"toplevel" || k == K"inert"
    # Remove scope layer information from any inert syntax which survives
    # macro expansion so that it doesn't contaminate lowering passes which
    # are later run against the quoted code. TODO: This works as a first
    # approximation but is incorrect in general. We need to revisit such
    # "deferred hygiene" situations (see https://github.com/c42f/JuliaLowering.jl/issues/111)
    remove_scope_layer(ctx, ex)
```

</details>

#### 2. Add tests covering escaped vs unescaped :toplevel macro expansions to assert module resolution behavior.

**Component**: JuliaLowering/test/macros.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/test/macros.jl:486-502**
[View on GitHub](https://github.com/JuliaLang/julia/blob/2315530f71b358b06c646d4f4124393da33719e8/JuliaLowering/test/macros.jl#L486-L502)
```julia
@testset "toplevel macro hygiene" begin
    @eval test_mod global mod = $test_mod
    @eval test_mod module MacroMod
    global mod = MacroMod
    macro escaped_toplevel()
        esc(Expr(:toplevel, :(mod)))
    end
    macro inner_escaped_toplevel()
        Expr(:toplevel, esc(:(mod)))
    end
    macro unescaped_toplevel()
        Expr(:toplevel, :(mod))
    end
    end
    @test JuliaLowering.include_string(test_mod, "MacroMod.@escaped_toplevel") === test_mod
    @test JuliaLowering.include_string(test_mod, "MacroMod.@inner_escaped_toplevel") === test_mod
    @test JuliaLowering.include_string(test_mod, "MacroMod.@unescaped_toplevel") === test_mod.MacroMod
end
```

</details>

### Secondary Effects

#### Escaped :toplevel macro expansions continue to resolve identifiers in the caller's module, while unescaped :toplevel forms now resolve to the macro's module only when a non-default scope layer is active.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
expand_forms_1(ctx, ex)  [macro_expansion.jl:389]
  -> for k == K"toplevel" and length(ctx.scope_layer_stack) > 1  [macro_expansion.jl:456-458]
     calls fix_toplevel_expansion(ctx, ex, current_layer(ctx).mod, source_location(...))
  -> fix_toplevel_expansion(...)  [macro_expansion.jl:247-255]
     wraps each toplevel child in K"hygienic_scope" with mod, lnn
```
</details>

**Downstream Surfaces:**
- Macro expansion hygiene for Expr(:toplevel)
- Module resolution of names emitted from macros

### Compatibility

#### Behavioral Changes
- Macro expansions returning Expr(:toplevel) are only wrapped in hygienic_scope when expansion happens under nested scope layers, which can change module resolution for unescaped toplevel content compared with prior always-wrap behavior.

### Performance

**Compile Time:**
- ESTIMATED: negligible; adds a conditional check on scope layer depth before wrapping toplevel forms in macro expansion.

### Risk Assessment

**Level**: low

**Rationale:**
- Change is localized to macro expansion hygiene for Expr(:toplevel) and guarded by scope-layer depth, with explicit tests covering escaped vs unescaped behavior.

### Recommendations

- Downstream macro authors emitting Expr(:toplevel) should verify whether they rely on implicit hygienic_scope wrapping at the outermost scope and adjust escaping if needed.
