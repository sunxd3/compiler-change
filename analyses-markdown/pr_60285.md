# PR #60285: Include missing sub- and superscripts in operator suffix list

## Metadata

- **Author**: moble
- **URL**: https://github.com/JuliaLang/julia/pull/60285
- **Merged**: 2025-12-10 21:45 UTC
- **Labels**: `parser`
- **Diff**: https://github.com/JuliaLang/julia/pull/60285.diff

## Scope

### Files Touched
- `JuliaSyntax/src/julia/tokenize.jl`
- `src/flisp/julia_opsuffs.h`
- `NEWS.md`

### Components
- JuliaSyntax
- Interpreter

### Pipeline Stages
- Parsing

## Analysis

### Intent

Extend the operator suffix allowlist so additional Unicode sub/superscripts that already
exist in REPL tab completion are accepted as part of operator tokens in both JuliaSyntax
and the flisp parser. This aligns tokenization with the existing LaTeX symbol mappings
and documents the change in NEWS.


**Related Issues:**
- https://github.com/JuliaLang/julia/pull/60285#issuecomment-305479765

### Direct Changes

#### 1. JuliaSyntax operator-suffix predicate now recognizes additional sub/superscripts.

**Component**: JuliaSyntax

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/julia/tokenize.jl:135-150**
[View on GitHub](https://github.com/JuliaLang/julia/blob/aa465d5c401587e6bb4ede92f95f8361c187ef09/JuliaSyntax/src/julia/tokenize.jl#L135-L150)
```julia
@eval function isopsuffix(c::Char)
    c == EOF_CHAR && return false
    isvalid(c) || return false
    u = UInt32(c)
    if (u < 0xa1 || u > 0x10ffff)
        return false
    end
    cat = Base.Unicode.category_code(u)
    if (cat == Base.Unicode.UTF8PROC_CATEGORY_MN ||
        cat == Base.Unicode.UTF8PROC_CATEGORY_MC ||
        cat == Base.Unicode.UTF8PROC_CATEGORY_ME)
        return true
    end
    # Additional allowed cases
    return $(_char_in_set_expr(:u,
        collect("²³¹ʰʲʳʷʸˡˢˣ˱˲ᴬᴮᴰᴱᴳᴴᴵᴶᴷᴸᴹᴺᴼᴾᴿᵀᵁᵂᵃᵅᵇᵈᵉᵋᵍᵏᵐᵒᵖᵗᵘᵛᵝᵞᵟᵠᵡᵢᵣᵤᵥᵦᵧᵨᵩᵪᶜᶠᶥᶦᶫᶰᶲᶸᶻᶿ′″‴‵‶‷⁗⁰ⁱ⁴⁵⁶⁷⁸⁹⁺⁻⁼⁽⁾ⁿ₀₁₂₃₄₅₆₇₈₉₊₋₌₍₎ₐₑₒₓₔₕₖₗₘₙₚₛₜⱼⱽꜛꜜꜝ")))
```

</details>

#### 2. flisp opsuffs table expanded to include additional sub/superscript codepoints.

**Component**: Interpreter

<details>
<summary>Evidence</summary>

**src/flisp/julia_opsuffs.h:11-122**
[View on GitHub](https://github.com/JuliaLang/julia/blob/aa465d5c401587e6bb4ede92f95f8361c187ef09/src/flisp/julia_opsuffs.h#L11-L122)
```julia
static const uint32_t opsuffs[] = {
   0x000000b2, // ²
   0x000000b3, // ³
   0x000000b9, // ¹
   0x000002b0, // ʰ
   0x000002b2, // ʲ
   0x000002b3, // ʳ
   0x000002b7, // ʷ
   0x000002b8, // ʸ
   0x000002e1, // ˡ
   0x000002e2, // ˢ
   0x000002e3, // ˣ
   0x000002f1, // ˱
   0x000002f2, // ˲
   0x00001d2c, // ᴬ
   0x00001d2e, // ᴮ
   0x00001d30, // ᴰ
   0x00001d31, // ᴱ
   0x00001d33, // ᴳ
   0x00001d34, // ᴴ
   0x00001d35, // ᴵ
   0x00001d36, // ᴶ
   0x00001d37, // ᴷ
   0x00001d38, // ᴸ
   0x00001d39, // ᴹ
   0x00001d3a, // ᴺ
   0x00001d3c, // ᴼ
   0x00001d3e, // ᴾ
   0x00001d3f, // ᴿ
   0x00001d40, // ᵀ
   0x00001d41, // ᵁ
   0x00001d42, // ᵂ
   0x00001d43, // ᵃ
   0x00001d45, // ᵅ
   0x00001d47, // ᵇ
   0x00001d48, // ᵈ
   0x00001d49, // ᵉ
   0x00001d4b, // ᵋ
   0x00001d4d, // ᵍ
   0x00001d4f, // ᵏ
   0x00001d50, // ᵐ
   0x00001d52, // ᵒ
   0x00001d56, // ᵖ
   0x00001d57, // ᵗ
   0x00001d58, // ᵘ
   0x00001d5b, // ᵛ
   0x00001d5d, // ᵝ
   0x00001d5e, // ᵞ
   0x00001d5f, // ᵟ
   0x00001d60, // ᵠ
   0x00001d61, // ᵡ
   0x00001d62, // ᵢ
   0x00001d63, // ᵣ
   0x00001d64, // ᵤ
   0x00001d65, // ᵥ
   0x00001d66, // ᵦ
   0x00001d67, // ᵧ
   0x00001d68, // ᵨ
   0x00001d69, // ᵩ
   0x00001d6a, // ᵪ
   0x00001d9c, // ᶜ
   0x00001da0, // ᶠ
   0x00001da5, // ᶥ
   0x00001da6, // ᶦ
   0x00001dab, // ᶫ
   0x00001db0, // ᶰ
   0x00001db2, // ᶲ
   0x00001db8, // ᶸ
   0x00001dbb, // ᶻ
   0x00001dbf, // ᶿ
   0x00002032, // ′
   0x00002033, // ″
   0x00002034, // ‴
   0x00002035, // ‵
   0x00002036, // ‶
   0x00002037, // ‷
   0x00002057, // ⁗
   0x00002070, // ⁰
   0x00002071, // ⁱ
   0x00002074, // ⁴
   0x00002075, // ⁵
   0x00002076, // ⁶
   0x00002077, // ⁷
   0x00002078, // ⁸
   0x00002079, // ⁹
   0x0000207a, // ⁺
   0x0000207b, // ⁻
   0x0000207c, // ⁼
   0x0000207d, // ⁽
   0x0000207e, // ⁾
   0x0000207f, // ⁿ
   0x00002080, // ₀
   0x00002081, // ₁
   0x00002082, // ₂
   0x00002083, // ₃
   0x00002084, // ₄
   0x00002085, // ₅
   0x00002086, // ₆
   0x00002087, // ₇
   0x00002088, // ₈
   0x00002089, // ₉
   0x0000208a, // ₊
   0x0000208b, // ₋
   0x0000208c, // ₌
   0x0000208d, // ₍
   0x0000208e, // ₎
   0x00002090, // ₐ
   0x00002091, // ₑ
   0x00002092, // ₒ
   0x00002093, // ₓ
   0x00002094, // ₔ
```

</details>

#### 3. Release notes document new suffixes and their REPL LaTeX completions.

**Component**: Docs

<details>
<summary>Evidence</summary>

**NEWS.md:18-20**
[View on GitHub](https://github.com/JuliaLang/julia/blob/aa465d5c401587e6bb4ede92f95f8361c187ef09/NEWS.md#L18-L20)
```julia
- `ᵅ` (U+U+1D45), `ᵋ` (U+1D4B), `ᶲ` (U+1DB2), `˱` (U+02F1), `˲` (U+02F2), and `ₔ` (U+2094) can now also be used as
  operator suffixes, accessible as `\^alpha`, `\^epsilon`, `\^ltphi`, `\_<`, `\_>`, and `\_schwa` at the REPL
  ([#60285]).
```

</details>

#### 4. Existing parsing tests show how operator suffixes are parsed as part of operator tokens.

**Component**: Parsing tests

<details>
<summary>Evidence</summary>

**test/syntax.jl:1062-1070**
[View on GitHub](https://github.com/JuliaLang/julia/blob/aa465d5c401587e6bb4ede92f95f8361c187ef09/test/syntax.jl#L1062-L1070)
```julia
# operator suffixes
@test Meta.parse("3 +̂ 4") == Expr(:call, :+̂, 3, 4)
@test Meta.parse("3 +̂′ 4") == Expr(:call, :+̂′, 3, 4)
@test Meta.parse("3 +⁽¹⁾ 4") == Expr(:call, :+⁽¹⁾, 3, 4)
@test Meta.parse("3 +₍₀₎ 4") == Expr(:call, :+₍₀₎, 3, 4)
for bad in ('=', '$', ':', "||", "&&", "->", "<:")
    @test_parseerror "3 $(bad)⁽¹⁾ 4"
end
```

</details>

### Secondary Effects

#### Operators with the newly-allowed suffix characters now tokenize as single operator symbols instead of splitting or erroring.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
emit(l, kind, maybe_op=true)  [JuliaSyntax/src/julia/tokenize.jl:430-439]
  -> while isopsuffix(peekchar(l))  [JuliaSyntax/src/julia/tokenize.jl:433]
     consumes suffix chars added to the isopsuffix allowlist
  -> RawToken(kind, ..., suffix=true) recorded for the operator
```
</details>

**Downstream Surfaces:**
- Parser tokenization
- Macro expansion that depends on operator symbols

#### C/Flisp parser helpers and Base.Meta.is_op_suffix_char now recognize the new suffix characters.

**Likelihood**: high | **Impact**: low

<details>
<summary>Mechanism</summary>

```
jl_op_suffix_char(wc)  [src/flisp/julia_extensions.c:163-179]
  -> lookup in opsuffs[] table  [src/flisp/julia_opsuffs.h:11-122]
  -> exposed to flisp via fl_julia_op_suffix_char  [src/flisp/julia_extensions.c:236-242]
  -> exposed to Julia via Meta.is_op_suffix_char  [base/meta.jl:58]
```
</details>

**Downstream Surfaces:**
- Meta.is_op_suffix_char
- flisp strip-op-suffix
- legacy parser op tokenization

### Compatibility

#### Internal API Changes
- **jl_op_suffix_char / Meta.is_op_suffix_char**: Behavior-only change: returns true for six additional Unicode suffix codepoints.

#### Behavioral Changes
- Operators using \\^alpha, \\^epsilon, \\^ltphi, \\_<, \\_>, \\_schwa now parse as single operator symbols.

### Performance

**Compile Time:**
- {'change': 'ESTIMATED: negligible. The isopsuffix character-set grows by six codepoints; lookup remains a set-membership check.'}

**Runtime:**
- {'change': 'ESTIMATED: no measurable runtime impact; affects parsing only.'}

### Risk Assessment

**Level**: low

**Rationale:**
- Change is limited to parsing/lexing allowlists for operator suffix characters.
- No existing syntax is removed; new suffixes are additive and documented in NEWS.

### Recommendations

- Callers confirmed via ripgrep:
JuliaSyntax/src/julia/tokenize.jl:135:@eval function isopsuffix(c::Char)
JuliaSyntax/src/julia/tokenize.jl:433:        while isopsuffix(peekchar(l))
src/flisp/julia_extensions.c:163:JL_DLLEXPORT int jl_op_suffix_char(uint32_t wc)
src/flisp/julia_extensions.c:236:value_t fl_julia_op_suffix_char(fl_context_t *fl_ctx, value_t *args, uint32_t nargs)
src/flisp/julia_extensions.c:254:        if (jl_op_suffix_char(u8_nextchar(op, &j)))
base/meta.jl:58:is_op_suffix_char(c::AbstractChar) = ccall(:jl_op_suffix_char, Cint, (UInt32,), c) != 0

