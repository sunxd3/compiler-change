# PR #60316: [JuliaLowering] Refactor scope resolution pass

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60316
- **Merged**: 2025-12-11 18:05 UTC
- **Labels**: `compiler:lowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60316.diff

## Scope

### Files Touched
- `JuliaLowering/src/bindings.jl`
- `JuliaLowering/src/scope_analysis.jl`
- `JuliaLowering/test/decls_ir.jl`
- `JuliaLowering/test/scopes.jl`

### Components
- JuliaLowering

### Pipeline Stages
- Lowering
- ScopeResolution
- VariableAnalysis

## Analysis

### Intent

Refactor scope resolution to better model soft scope toggling and binding metadata, while consolidating variable usage flags into BindingInfo for later lowering stages.

**Related Issues:**
- https://github.com/JuliaLang/JuliaLowering.jl/issues/101

### Direct Changes

#### 1. BindingInfo is now mutable and expanded to carry vinfo-style usage flags (read/called/assigned, capture state, always-defined, etc.), and binding creation routes through the new _new_binding helper.

**Component**: JuliaLowering/src/bindings.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/bindings.jl:4-45**
[View on GitHub](https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering/src/bindings.jl#L4-L45)
```julia
mutable struct BindingInfo
    const id::IdTag                 # Unique integer identifying this binding
    const name::String
    const kind::Symbol              # :local :global :argument :static_parameter
    const node_id::Int              # ID of some K"BindingId" node in the syntax graph
    const mod::Union{Nothing,Module} # Set when `kind === :global`
    type::Union{Nothing,SyntaxTree} # Type, for bindings declared like x::T = 10
    is_const::Bool            # Constant, cannot be reassigned
    is_ssa::Bool              # Single assignment, defined before use
    is_internal::Bool         # True for internal bindings generated by the compiler
    is_ambiguous_local::Bool  # Local, but would be global in soft scope (ie, the REPL)

    # flisp: vinfo
    is_nospecialize::Bool # @nospecialize on this argument (only valid for kind == :argument)
    is_read::Bool
    is_called::Bool
    is_assigned::Bool # the implicit assignment to arguments doesn't count
    is_assigned_once::Bool
    is_captured::Bool
    is_always_defined::Bool
    is_used_undef::Bool
end
```

**JuliaLowering/src/bindings.jl:112-121**
[View on GitHub](https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering/src/bindings.jl#L112-L121)
```julia
function _new_binding(ctx::AbstractLoweringContext, srcref::SyntaxTree,
                      name::AbstractString, kind::Symbol; kws...)
    binding_id = next_binding_id(ctx.bindings)
    # A binding is only useful when it shows up in the tree, so create its tree
    # node eagerly and share it among uses (see `binding_ex`)
    ex = @ast ctx srcref binding_id::K"BindingId"
    b = BindingInfo(binding_id, name, kind, ex._id; kws...)
    add_binding(ctx.bindings, b)
    return b
end
```

</details>

#### 2. Scope resolution now tracks permeable scopes and softscope markers to decide when assignments in neutral scopes should target existing globals versus introduce locals.

**Component**: JuliaLowering/src/scope_analysis.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/scope_analysis.jl:83-90**
[View on GitHub](https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering/src/scope_analysis.jl#L83-L90)
```julia
ScopeResolutionContext(
    graph,
    ctx.bindings,
    ctx.mod,
    Vector{ScopeInfo}(),
    Vector{ScopeId}(),
    ctx.scope_layers,
    Set{NameKey}(),
    contains_softscope_marker(ex),
    ctx.expr_compat_mode)

function contains_softscope_marker(ex)
    kind(ex) == K"softscope" ||
        needs_resolution(ex) && any(contains_softscope_marker, children(ex))
end
```

**JuliaLowering/src/scope_analysis.jl:229-306**
[View on GitHub](https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering/src/scope_analysis.jl#L229-L306)
```julia
function enter_scope!(ctx, ex)
    @assert kind(ex) in KSet"lambda scope_block"
    # Note that generated functions produce lambdas with this false
    is_toplevel_thunk = kind(ex) === K"lambda" && ex.is_toplevel_thunk
    parent_id = (is_toplevel_thunk || isempty(ctx.scope_stack)) ?
        0 : ctx.scopes[ctx.scope_stack[end]].id
    is_permeable = is_toplevel_thunk ||
        kind(ex) === K"scope_block" && ex.scope_type === :neutral
    scope = ScopeInfo(ctx, parent_id, ex._id, kind(ex) === K"lambda", is_permeable)
    lambda_scope = ctx.scopes[scope.lambda_id]
    push!(ctx.scope_stack, scope.id)

    #---------------------------------------------------------------------------
    # Find assignment targets, possibly introducing implicit locals and globals
    for (vk, node_id) in sort!(collect(scope.assignments))
        local ex = SyntaxTree(ctx.graph, node_id)
        b = resolve_name(ctx, ex)
        if b === nothing
            if is_toplevel_thunk && !ctx.scope_layers[vk.layer].is_macro_expansion
                push!(ctx.soft_assignable_globals, vk)
                declare_in_scope!(ctx, top_scope(ctx), ex, :global)
            elseif scope.is_permeable && is_defined_and_owned_global(
                ctx.scope_layers[vk.layer].mod, Symbol(vk.name))
                # special soft scope rules: existing global variables are assigned to
                if ctx.enable_soft_scopes
                    push!(ctx.soft_assignable_globals, vk)
                    declare_in_scope!(ctx, top_scope(ctx), ex, :global)
                else
                    declare_in_scope!(ctx, scope, ex, :local; is_ambiguous_local=true)
                end
            else
                declare_in_scope!(ctx, scope, ex, :local)
            end
        elseif b.kind === :global
            if is_toplevel_thunk
                # assign-existing and make visible to soft scope
                push!(ctx.soft_assignable_globals, vk)
            elseif !isnothing(resolve_name(ctx, ex; exclude_toplevel_globals=true)) ||
                (ctx.enable_soft_scopes && scope.is_permeable &&
                vk in ctx.soft_assignable_globals)
                # assign-existing-global if this is an explicit global that
                # isn't at top level, or if the soft scope exception applies
            else
                declare_in_scope!(ctx, scope, ex, :local)
            end
        elseif b.kind === :static_parameter
            throw(LoweringError(ex, "cannot overwrite a static parameter"))
        elseif b.kind === :local || b.kind === :argument
            # unambiguous assignment to existing variable
            record_lambda_var!(ctx, scope, b, capt=true)
        end
    end

    return scope
end
```

**JuliaLowering/test/scopes.jl:147-171**
[View on GitHub](https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering/test/scopes.jl#L147-L171)
```julia
@testset "basic softscope (uses internal lowering nodes, not surface syntax)" begin
    # wrap expression in scope block of `scope_type` (:neutral or :hard)
    function wrapscope(ex, scope_type)
        g = JuliaLowering.ensure_attributes(ex._graph, scope_type=Symbol)
        ex = JuliaLowering.reparent(g, ex)
        makenode(g, ex, K"scope_block", [ex._id], [:scope_type=>scope_type])
    end
    function use_soft(ex::SyntaxTree)
        @ast ex._graph ex [K"block" (::K"softscope") ex]
    end

    assign_z_2 = parsestmt(SyntaxTree, "begin z = 2 end", filename="foo.jl")
    Base.eval(test_mod, :(z=1))
    @test test_mod.z == 1
    # hard scopes will always create a new binding; softscope mode is ignored
    JuliaLowering.eval(test_mod, wrapscope(assign_z_2, :hard))
    @test test_mod.z == 1
    JuliaLowering.eval(test_mod, use_soft(wrapscope(assign_z_2, :hard)))
    @test test_mod.z == 1
    # neutral (eg, for loops) and hard (eg, let) scopes create a new binding for z
    JuliaLowering.eval(test_mod, wrapscope(assign_z_2, :neutral))
    @test test_mod.z == 1
    # but soft scope mode makes assignment in neutral scope assign to global `z`
    JuliaLowering.eval(test_mod, use_soft(wrapscope(assign_z_2, :neutral)))
    @test test_mod.z == 2
end
```

</details>

#### 3. Variable analysis now writes read/assigned/called flags into BindingInfo and records capture metadata used by closure conversion and linear IR slot flags.

**Component**: JuliaLowering/src/scope_analysis.jl

<details>
<summary>Evidence</summary>

**JuliaLowering/src/scope_analysis.jl:584-648**
[View on GitHub](https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering/src/scope_analysis.jl#L584-L648)
```julia
function add_assign!(b::BindingInfo)
    b.is_assigned_once = !b.is_assigned
    b.is_assigned = true
end

# Update ctx.bindings metadata based on binding usage
function analyze_variables!(ctx, ex)
    k = kind(ex)
    if k == K"BindingId"
        b = get_binding(ctx, ex.var_id)
        b.is_read = true
        # The type of typed locals is invisible in the previous pass,
        # but is filled in here.
        scope = ctx.scopes[ctx.lambda_bindings.scope_id]
        record_lambda_var!(ctx, scope, b, capt=true)
        @assert b.kind === :global || b.is_ssa || haskey(ctx.lambda_bindings.locals_capt, b.id)
    elseif k == K"="
        lhs = ex[1]
        if kind(lhs) != K"Placeholder"
            b = get_binding(ctx, lhs)
            add_assign!(b)
            scope = ctx.scopes[ctx.lambda_bindings.scope_id]
            record_lambda_var!(ctx, scope, b, capt=true)
            if !isnothing(b.type)
                # Assignments introduce a variable's type later during closure
                # conversion, but we must model that explicitly here.
                analyze_variables!(ctx, b.type)
            end
        end
        analyze_variables!(ctx, ex[2])
    elseif k == K"call"
        name = ex[1]
        if kind(name) == K"BindingId"
            get_binding(ctx, name.var_id).is_called = true
        end
        foreach(e->analyze_variables!(ctx, e), children(ex))
    end
```

**JuliaLowering/src/linear_ir.jl:1045-1088**
[View on GitHub](https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering/src/linear_ir.jl#L1045-L1088)
```julia
struct Slot
    name::String
    kind::Symbol
    is_nospecialize::Bool
    is_read::Bool
    is_single_assign::Bool
    is_maybe_undef::Bool
    is_called::Bool
end

function compile_lambda(outer_ctx, ex)
    lambda_args = ex[1]
    static_parameters = ex[2]
    ret_var = numchildren(ex) == 4 ? ex[4] : nothing
    # TODO: Add assignments for reassigned arguments to body
    lambda_bindings = ex.lambda_bindings
    ctx = LinearIRContext(outer_ctx, ex.is_toplevel_thunk, lambda_bindings, ret_var)
    compile_body(ctx, ex[3])
    slots = Vector{Slot}()
    slot_rewrites = Dict{IdTag,Int}()
    for arg in children(lambda_args)
        if kind(arg) == K"Placeholder"
            # Unused functions arguments like: `_` or `::T`
            push!(slots, Slot(arg.name_val, :argument, false, false, false, false, false))
        else
            @assert kind(arg) == K"BindingId"
            id = arg.var_id
            binfo = get_binding(ctx, id)
            @assert binfo.kind == :local || binfo.kind == :argument
            push!(slots, Slot(binfo.name, :argument, binfo.is_nospecialize,
                              binfo.is_read, binfo.is_assigned_once,
                              binfo.is_used_undef, binfo.is_called))
            slot_rewrites[id] = length(slots)
        end
    end
```

</details>

### Secondary Effects

#### Capture boxing decisions can change because capture/read/assignment flags are now updated directly on BindingInfo during scope/variable analysis.

**Likelihood**: medium | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
record_lambda_var!(ctx, scope, b, capt=true)  [scope_analysis.jl:161-171]
  sets b.is_captured = capt
analyze_variables!(ctx, ex)  [scope_analysis.jl:584-648]
  sets b.is_assigned/b.is_assigned_once and b.is_read
is_boxed(binfo)  [closure_conversion.jl:303-310]
  uses binfo.is_captured and binfo.is_always_defined/is_assigned
```
</details>

**Downstream Surfaces:**
- Closure conversion capture layout (boxed vs unboxed captures)
- Opaque closure capture decisions

#### Soft scope toggling affects whether neutral scopes assign to existing globals or introduce ambiguous locals, changing name resolution in REPL-like contexts.

**Likelihood**: high | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
contains_softscope_marker(ex)  [scope_analysis.jl:87-90]
  toggles ctx.enable_soft_scopes
enter_scope!(ctx, ex)  [scope_analysis.jl:229-306]
  uses scope.is_permeable + enable_soft_scopes to choose global vs local binding
```
</details>

**Downstream Surfaces:**
- REPL top-level assignment behavior
- Macro expansions that inject scope_block nodes

### Compatibility

#### Internal API Changes
- **Field**: 

#### Behavioral Changes
- {'item': 'Assignments in neutral scopes can now target existing globals when a softscope marker is present, instead of always creating a new local binding.', 'evidence': [{'source': 'test', 'path': 'JuliaLowering/test/scopes.jl', 'loc': '147-171', 'url': 'https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering/test/scopes.jl#L147-L171', 'snippet': '@testset "basic softscope (uses internal lowering nodes, not surface syntax)" begin\n    # wrap expression in scope block of `scope_type` (:neutral or :hard)\n    function wrapscope(ex, scope_type)\n        g = JuliaLowering.ensure_attributes(ex._graph, scope_type=Symbol)\n        ex = JuliaLowering.reparent(g, ex)\n        makenode(g, ex, K"scope_block", [ex._id], [:scope_type=>scope_type])\n    end\n    function use_soft(ex::SyntaxTree)\n        @ast ex._graph ex [K"block" (::K"softscope") ex]\n    end\n\n    assign_z_2 = parsestmt(SyntaxTree, "begin z = 2 end", filename="foo.jl")\n    Base.eval(test_mod, :(z=1))\n    @test test_mod.z == 1\n    # hard scopes will always create a new binding; softscope mode is ignored\n    JuliaLowering.eval(test_mod, wrapscope(assign_z_2, :hard))\n    @test test_mod.z == 1\n    JuliaLowering.eval(test_mod, use_soft(wrapscope(assign_z_2, :hard)))\n    @test test_mod.z == 1\n    # neutral (eg, for loops) and hard (eg, let) scopes create a new binding for z\n    JuliaLowering.eval(test_mod, wrapscope(assign_z_2, :neutral))\n    @test test_mod.z == 1\n    # but soft scope mode makes assignment in neutral scope assign to global `z`\n    JuliaLowering.eval(test_mod, use_soft(wrapscope(assign_z_2, :neutral)))\n    @test test_mod.z == 2\nend\n'}]}

### Performance

**Compile Time:**
- {'summary': 'ESTIMATED: an additional AST walk to detect softscope markers via contains_softscope_marker, plus extra bookkeeping for assignment resolution, adds O(n) work per lowering pass where n is the AST size.', 'evidence': [{'source': 'code', 'path': 'JuliaLowering/src/scope_analysis.jl', 'loc': '83-90', 'url': 'https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering/src/scope_analysis.jl#L83-L90', 'snippet': 'ScopeResolutionContext(\n    graph,\n    ctx.bindings,\n    ctx.mod,\n    Vector{ScopeInfo}(),\n    Vector{ScopeId}(),\n    ctx.scope_layers,\n    Set{NameKey}(),\n    contains_softscope_marker(ex),\n    ctx.expr_compat_mode)\n\nfunction contains_softscope_marker(ex)\n    kind(ex) == K"softscope" ||\n        needs_resolution(ex) && any(contains_softscope_marker, children(ex))\nend\n'}]}

**Runtime:**
- {'summary': 'No direct runtime codegen changes; effects are limited to lowering-time binding classification and metadata for closure conversion.', 'evidence': [{'source': 'code', 'path': 'JuliaLowering/src/scope_analysis.jl', 'loc': '590-648', 'url': 'https://github.com/JuliaLang/julia/blob/903568acd680da424c4513332a8914a436471ceb/JuliaLowering/src/scope_analysis.jl#L590-L648', 'snippet': '# Update ctx.bindings metadata based on binding usage\nfunction analyze_variables!(ctx, ex)\n    k = kind(ex)\n    if k == K"BindingId"\n        b = get_binding(ctx, ex.var_id)\n        b.is_read = true\n        # The type of typed locals is invisible in the previous pass,\n        # but is filled in here.\n        scope = ctx.scopes[ctx.lambda_bindings.scope_id]\n        record_lambda_var!(ctx, scope, b, capt=true)\n        @assert b.kind === :global || b.is_ssa || haskey(ctx.lambda_bindings.locals_capt, b.id)\n    elseif k == K"="\n        lhs = ex[1]\n        if kind(lhs) != K"Placeholder"\n            b = get_binding(ctx, lhs)\n            add_assign!(b)\n            scope = ctx.scopes[ctx.lambda_bindings.scope_id]\n            record_lambda_var!(ctx, scope, b, capt=true)\n            if !isnothing(b.type)\n                # Assignments introduce a variable\'s type later during closure\n                # conversion, but we must model that explicitly here.\n                analyze_variables!(ctx, b.type)\n            end\n        end\n        analyze_variables!(ctx, ex[2])\n    elseif k == K"call"\n        name = ex[1]\n        if kind(name) == K"BindingId"\n            get_binding(ctx, name.var_id).is_called = true\n        end\n        foreach(e->analyze_variables!(ctx, e), children(ex))\n    end\n'}]}

### Risk Assessment

**Level**: medium

**Rationale:**
- Scope resolution semantics (soft scope vs local shadowing) are user-visible in REPL-like contexts and can affect name binding outcomes.
- BindingInfo flag propagation feeds closure conversion boxing decisions, which can affect capture layout and IR expectations.

### Recommendations

- Audit downstream uses of BindingInfo/LambdaBindings in JuliaLowering to ensure any external tooling reads flags from BindingInfo and respects updated capture semantics.
- Consider adding targeted regression tests that exercise softscope markers in nested macro expansions to lock in permeable-scope behavior.
