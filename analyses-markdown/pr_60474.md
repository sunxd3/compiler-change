# PR #60474: Allow parsing to `Expr`-structured `SyntaxTree`

## Metadata

- **Author**: mlechu
- **URL**: https://github.com/JuliaLang/julia/pull/60474
- **Merged**: 2025-12-29 16:53 UTC
- **Labels**: `JuliaLowering`
- **Diff**: https://github.com/JuliaLang/julia/pull/60474.diff

## Scope

### Files Touched
- `JuliaLowering/src/compat.jl`
- `JuliaLowering/src/kinds.jl`
- `JuliaLowering/test/compat.jl`
- `JuliaSyntax/src/integration/expr.jl`
- `JuliaSyntax/src/porcelain/syntax_graph.jl`

### Components
- JuliaSyntax
- JuliaLowering

### Pipeline Stages
- Parsing
- Lowering

## Analysis

### Intent

Introduce a RawGreenNode -> Expr-structured SyntaxTree (EST) conversion path and validate it against the existing Expr conversion, enabling Expr-compatible SyntaxTree parsing for macros and tooling.

**Related Issues:**
- https://github.com/JuliaLang/julia/pull/60373
- https://github.com/JuliaLang/julia/pull/60431

### Direct Changes

#### 1. Add an expr_structure parsing mode that converts parser output to Expr-shaped SyntaxTree via _green_to_est instead of the existing AST conversion.

**Component**: JuliaSyntax/porcelain

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/porcelain/syntax_graph.jl:747-783**
[View on GitHub](https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaSyntax/src/porcelain/syntax_graph.jl#L747-L783)
```julia
function build_tree(::Type{SyntaxTree}, stream::ParseStream;
                    filename=nothing, first_line=1,
                    expr_structure=false)
    cursor = RedTreeCursor(stream)
    graph = SyntaxGraph()
    sf = SourceFile(stream; filename, first_line)
    source = SourceRef(sf, first_byte(stream), last_byte(stream))
    cs = SyntaxList(graph)
    for c in reverse_toplevel_siblings(cursor)
        is_trivia(c) && !is_error(c) && continue
        push!(cs, SyntaxTree(graph, sf, c; expr_structure))
    end
    # There may be multiple non-trivia toplevel nodes (e.g. parse error)
    length(cs) === 1 && return only(cs)
    id = new_id!(graph)
    setchildren!(graph, id, reverse(cs).ids)
    setattr!(graph, id, :source, source)
    setattr!(graph, id, :kind, K"wrapper")
    return SyntaxTree(graph, id)
end

function SyntaxTree(graph::SyntaxGraph, sf::SourceFile, cursor::RedTreeCursor; expr_structure)
    ensure_attributes!(graph, kind=Kind, syntax_flags=UInt16,
                       source=SourceAttrType, value=Any, name_val=String)
    green_id = GC.@preserve sf begin
        raw_offset, txtbuf = _unsafe_wrap_substring(sf.code)
        offset = raw_offset - sf.byte_offset
        _insert_green(graph, sf, txtbuf, offset, cursor)
    end
    gst = SyntaxTree(graph, green_id)
    if expr_structure
        out = _green_to_est(gst, 0, gst)
    else
        out = _green_to_ast(K"None", gst)
    end
    @assert !isnothing(out) "SyntaxTree requires >0 nontrivia nodes"
    return out
end
```

</details>

#### 2. Implement RawGreenNode -> EST conversion rules (including macrocall and literal handling) to match Expr semantics, with pre-recursion child preprocessing and parameter reordering.

**Component**: JuliaSyntax/porcelain

<details>
<summary>Evidence</summary>

**JuliaSyntax/src/porcelain/syntax_graph.jl:906-1037**
[View on GitHub](https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaSyntax/src/porcelain/syntax_graph.jl#L906-L1037)
```julia
function _green_to_est(parent::SyntaxTree, parent_i::Int,
                       st::SyntaxTree; kw_in_params=false)
    if !should_include_node(st)
        @assert kind(parent) === K"None" && parent_i === 0
        return nothing
    end

    graph = syntax_graph(st)
    k = kind(st)
    coreref(s::String) = setattr!(newleaf(graph, st, K"core"), :name_val, s)
    symleaf(s::String) = setattr!(newleaf(graph, st, K"Identifier"), :name_val, s)
    valleaf(@nospecialize(v)) = setattr!(newleaf(graph, st, K"Value"), :value, v)

    if is_leaf(st)
        return if k === K"CmdMacroName" || k === K"StrMacroName"
            name = lower_identifier_name(st.name_val, k)
            symleaf(name)
        elseif k === K"VERSION"
            valleaf(version_to_expr(st))
        elseif (v = get(st, :value, nothing); v isa Union{Int128,UInt128,BigInt})
            # syntax TODO: likely unnecessary; this is just to match RGN->Expr,
            # which added this to match flisp parsing text->Expr.
            macname = v isa Int128 ? "@int128_str" :
                v isa UInt128 ? "@uint128_str" : "@big_str"
            mac = valleaf(GlobalRef(Core, Symbol(macname)))
            arg = valleaf(replace(sourcetext(st), '_'=>""))
            ret_cids = tree_ids(mac, coreref("nothing"), arg)
            newnode(graph, st, K"macrocall", ret_cids)
        else
            st
        end
    end

    # Non-leaf cases: each branch should either set `ret_k` and `cs` or recurse
    # manually and return a finished SyntaxTree
    ret_k::Kind = k
    cs = preprocessed_green_children(st)
    n_cs = length(cs)

    if k === K"string" && n_cs > 0
        return _string_to_est(st, cs; unwrap_literal=true)
    elseif k === K"cmdstring" && n_cs > 0
        # (cmdstring _...) => (macrocall Core.@cmd lno joined_str)
        cmd_arg = _string_to_est(st, cs; unwrap_literal=true)
        loc_st = valleaf(source_location(LineNumberNode, st))
        return newnode(graph, st, K"macrocall", tree_ids(
            valleaf(GlobalRef(Core, Symbol("@cmd"))), loc_st, cmd_arg))
    elseif k === K"macro_name" && n_cs === 1
        # "M.@x" => (. M (macro_name x)) => (. M @x)
        # "@M.x" => (macro_name (. M x)) => (. M @x)
        #           (macro_name else) => else
        if kind(cs[1]) === K"Identifier"
            return symleaf(lower_identifier_name(cs[1].name_val, K"macro_name"))
        else
            inner_st = cs[1]
            inner_cs = preprocessed_green_children(inner_st)
            if (length(inner_cs) === 2 && kind(inner_st) === K"." &&
                kind(inner_cs[2]) === K"Identifier")
                (lhs, raw_m) = _green_to_est(cs[1], 1, inner_cs[1]), inner_cs[2]
                mname_s = lower_identifier_name(raw_m.name_val, K"macro_name")
                mname = setattr!(mkleaf(raw_m), :name_val, mname_s)
                mname_inert = newnode(graph, raw_m, K"inert", tree_ids(mname))
                return mknode(inner_st, tree_ids(lhs, mname_inert))
            else
                return _green_to_est(parent, 1, inner_st)
            end
        end
    elseif k === K"?"
        ret_k = K"if"
    elseif k === K"op=" && n_cs === 3
        # (op= a + b) => (+= a b)
        # (.op= a + b) => (.+= a b) below
        op_s = string(cs[2]) * '='
        lhs = _green_to_est(st, 0, cs[1])
        rhs = _green_to_est(st, 0, cs[3])
        out = newnode(graph, st, K"unknown_head", tree_ids(lhs, rhs))
        return setattr!(out, :name_val, op_s)
    elseif k === K".op=" && n_cs === 3
        op_s = '.' * string(cs[2]) * '='
        lhs = _green_to_est(st, 0, cs[1])
        rhs = _green_to_est(st, 0, cs[3])
        out = newnode(graph, st, K"unknown_head", tree_ids(lhs, rhs))
        return setattr!(out, :name_val, op_s)
    elseif k === K"macrocall" && n_cs > 0
        # LineNumberNodes are not usually added to the tree as they are in Expr,
        # but this specifically inserts the macrocall child for compatibility
        loc_st = let loc = source_location(LineNumberNode, st)
            if n_cs >= 2 && kind(cs[2]) === K"VERSION"
                v = version_to_expr(popat!(cs, 2))
                loc = Core.MacroSource(loc, v)
            end
            valleaf(loc)
        end
        insert!(cs, 2, loc_st)
        # foo`x` parses to (macrocall foo::CmdMacroName (cmdstring ::CmdString))
        # so we need to unwrap the CmdString or else we get two macrocalls
        if n_cs >= 2 && kind(cs[1]) === K"CmdMacroName"
            ret_cs = _map_green_to_est(st, cs)
            ret_cs[3] = ret_cs[3][3] # node leak
            return mknode(st, ret_cs)
        end
        do_ex = kind(cs[end]) === K"do" ? pop!(cs) : nothing
        _reorder_parameters!(cs, 3)
        !isnothing(do_ex) && return _make_do_expression(st, cs, do_ex)
    elseif k === K"doc"
        # (doc str obj) => (macrocall Core.@doc lno str obj)
        ret_k = K"macrocall"
        pushfirst!(cs, valleaf(source_location(LineNumberNode, st)))
        pushfirst!(cs, valleaf(GlobalRef(Core, Symbol("@doc"))))
    elseif k === K"dotcall" || k === K"call" && n_cs > 0
        if is_infix_op_call(st) || is_postfix_op_call(st)
            cs[2], cs[1] = cs[1], cs[2]
        end
        if is_postfix_op_call(st) && kind(cs[1]) == K"Identifier" &&
            cs[1].name_val === "'"
            popfirst!(cs)
            ret_k = K"'"
        end
        do_ex = kind(cs[end]) === K"do" ? pop!(cs) : nothing
        _reorder_parameters!(cs, 2)
        if k === K"dotcall"
            if is_prefix_call(st)
                # (dotcall f args...) => (. f (tuple args...))
                ret_cs = _map_green_to_est(st, cs)
                tuple = newnode(graph, st, K"tuple", ret_cs[2:end])
                return newnode(graph, st, K".", tree_ids(ret_cs[1], tuple))
            else
                # (dotcall + args...) => (call .+ args...)
                ret_k = K"call"
                if kind(cs[1]) === K"Identifier"
                    cs[1] = symleaf('.' * cs[1].name_val)
                end
            end
        end
        !isnothing(do_ex) && return _make_do_expression(st, cs, do_ex)
```

</details>

#### 3. Adjust Expr<->EST conversion to recognize literal/value nodes and the core/nothing encoding when roundtripping SyntaxTree back to Expr.

**Component**: JuliaLowering/compat

<details>
<summary>Evidence</summary>

**JuliaLowering/src/compat.jl:659-731**
[View on GitHub](https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaLowering/src/compat.jl#L659-L731)
```julia
function is_expr_value(st::SyntaxTree)
    k = kind(st)
    return JuliaSyntax.is_literal(k) || k === K"Value" ||
        k === K"core" && st.name_val === "nothing"
end

function _expr_to_est(graph::SyntaxGraph, @nospecialize(e), src::LineNumberNode)
    st = if e === Core.nothing
        # e.value can't be nothing in `K"Value"`, so represent with K"core"
        setattr!(newleaf(graph, src, K"core"), :name_val, "nothing")
    elseif e isa Symbol
        setattr!(newleaf(graph, src, K"Identifier"), :name_val, String(e))
    elseif e isa QuoteNode
        cid, _ = _expr_to_est(graph, e.value, src)
        newnode(graph, src, K"inert", NodeId[cid])
    elseif e isa Expr && e.head === :scope_layer
        @assert length(e.args) === 2 && e.args[1] isa Symbol
        ident = newleaf(graph, src, K"Identifier")
        setattr!(ident, :name_val, String(e.args[1]))
        setattr!(ident, :scope_layer, e.args[2])
    elseif e isa Expr
        head_s = string(e.head)
        st_k = find_kind(head_s)
        old_src = _get_inner_lnn(e, src)
        cs = NodeId[]
        rm_linenodes = e.head in (:block, :toplevel)
        for arg in e.args
            if rm_linenodes && arg isa LineNumberNode
                src = arg
            else
                cid, src = _expr_to_est(graph, arg, src)
                push!(cs, cid)
            end
        end
        if isnothing(st_k)
            setattr!(newnode(graph, src, K"unknown_head", cs), :name_val, head_s)
        else
            newnode(graph, old_src, st_k, cs)
        end
    # elseif e isa GlobalRef
        # TODO: Better-behaved as K"globalref", but lowering doesn't know this
    else
        # We may want additional special cases for other types where
        # `Base.isa_ast_node(e)`, but `K"Value"` should be fine for most, since
        # most are produced in or after lowering
        if e isa LineNumberNode
            # linenode oustside of block or toplevel
            src = e
        end
        setattr!(newleaf(graph, src, K"Value"), :value, e)
    end
    @assert isa_lowering_ast_node(e) || is_expr_value(st)

    return st._id, src
end

function est_to_expr(st::SyntaxTree)
    k = kind(st)
    return if k === K"core" && numchildren(st) === 0 && st.name_val === "nothing"
        nothing
    elseif is_leaf(st) && hasattr(st, :name_val)
        n = Symbol(st.name_val)
        hasattr(st, :scope_layer) ? Expr(:scope_layer, n, st.scope_layer) : n
    elseif is_leaf(st) && is_expr_value(st)
        v = st.value
        # Let `st.value isa Symbol` (or other AST node).  Since we enforce that
        # this is never produced by the reverse Expr->SyntaxTree transformation,
        # there is no lonely Expr for which `st` is the only SyntaxTree
        # representation.  This means we can pick some other expr this
        # represents, namely Expr(`(inert ,st.value)) rather than
        # Expr(st.value).
        isa_lowering_ast_node(v) ? QuoteNode(v) : v
```

</details>

#### 4. Add bulk parsing tests that compare RawGreenNode->EST->Expr against RawGreenNode->Expr across Julia codebases and stdlibs.

**Component**: JuliaLowering/tests

<details>
<summary>Evidence</summary>

**JuliaLowering/test/compat.jl:801-836**
[View on GitHub](https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaLowering/test/compat.jl#L801-L836)
```julia
@testset "Test RawGreenNode->EST->Expr against RawGreenNode->Expr" begin
    function make_est(str)
        e_ref = try
            JS.parseall(Expr, str)
        catch _
            nothing
        end
        isnothing(e_ref) && return 0
        est_test = JS.parseall(SyntaxTree, str; expr_structure=true)
        e_test = JL.est_to_expr(est_test)
        pass = expr_equal_forgiving(e_test, e_ref)
        @test pass
        if !pass
            ((e_ref_min, e_test_min), indices) = find_diff(e_ref, e_test)
            @info "diff:" e_ref_min e_test_min indices # e_ref e_test
        end
        return 1
    end

    @testset "bulk parsed code, no linenodes" begin
        test_each_in_path(make_est, JL_DIR)

        basedir = joinpath(Sys.BINDIR, Base.DATAROOTDIR, "julia", "base")
        test_each_in_path(make_est, basedir)

        base_testdir = joinpath(Sys.BINDIR, Base.DATAROOTDIR, "julia", "test")
        test_each_in_path(make_est, base_testdir)

        @testset "Parse Julia stdlib at $(Sys.STDLIB)" begin
            for stdlib in readdir(Sys.STDLIB)
                fulldir = joinpath(Sys.STDLIB, stdlib)
                if isdir(fulldir)
                    test_each_in_path(make_est, joinpath(Sys.STDLIB, fulldir))
                end
            end
        end

    end
end
```

</details>

### Secondary Effects

#### Expr-structured SyntaxTree parsing now performs pre-recursion child filtering and parameter reordering, which can change child ordering and insertion of synthetic nodes compared with raw-syntax trees when expr_structure=true.

**Likelihood**: medium | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
build_tree(::Type{SyntaxTree}; expr_structure=true)  [syntax_graph.jl:747-779]
  -> SyntaxTree(graph, sf, cursor; expr_structure)   [syntax_graph.jl:768-783]
    -> _green_to_est(parent, parent_i, st)           [syntax_graph.jl:906-1040]
      -> preprocessed_green_children(st)            [syntax_graph.jl:1275-1287]
      -> _reorder_parameters!(cs, params_pos)       [syntax_graph.jl:1290-1303]
      -> _map_green_to_est(parent, cs)              [syntax_graph.jl:1264-1271]
```
</details>

**Downstream Surfaces:**
- JuliaSyntax.parseall(SyntaxTree; expr_structure=true) consumers
- Macro tooling that inspects SyntaxTree children order

#### Macrocall nodes gain an inserted LineNumberNode/MetaSource child and version-aware MacroSource, affecting macro argument positions in Expr-structured trees.

**Likelihood**: low | **Impact**: medium

<details>
<summary>Mechanism</summary>

```
_green_to_est(...) handles K"macrocall" by inserting loc child and
wrapping VERSION into Core.MacroSource before parameters reordering.  [syntax_graph.jl:989-1009]
```
</details>

**Downstream Surfaces:**
- Macros that inspect Expr-structured SyntaxTree via est_to_expr
- Tools expecting macrocall child positions to match Expr

#### EST<->Expr roundtripping now treats K"core"/nothing and literal leaves to avoid producing raw Expr nodes from value leaves, changing how QuoteNode vs raw Expr values are emitted.

**Likelihood**: low | **Impact**: low

<details>
<summary>Mechanism</summary>

```
is_expr_value() and est_to_expr() accept literal/Value/core-nothing leaves
and map AST nodes to QuoteNode to avoid ambiguous Expr values.  [compat.jl:659-731]
```
</details>

**Downstream Surfaces:**
- JuliaLowering.est_to_expr callers
- SyntaxTree constructors that use K"Value"/literal leaves

### Compatibility

#### Internal API Changes
- **build_tree(::Type{SyntaxTree}; expr_structure)**: Adds expr_structure keyword to request Expr-structured SyntaxTree conversion via _green_to_est.
- **JuliaLowering.est_to_expr literal handling**: Accepts K"core"/nothing and literal K"Value" nodes as Expr values with QuoteNode protection.

#### Behavioral Changes
- Parsing with expr_structure=true yields SyntaxTree nodes reordered and normalized to match Expr forms (e.g., macrocall inserting loc child, parameter reordering, operator note).

### Performance

**Compile Time:**
- ESTIMATED: O(n) additional tree-walk when expr_structure=true to preprocess children and reorder parameters before recursion.

### Risk Assessment

**Level**: low

**Rationale:**
- expr_structure is opt-in and defaults to the existing RawGreenNode->AST conversion path.
- Bulk parsing tests compare RawGreenNode->EST->Expr to RawGreenNode->Expr across base, tests, and stdlib, reducing semantic drift risk.

### Recommendations

- Downstream tools that switch to expr_structure=true should add golden tests around macrocall argument positions and parameter block ordering to catch subtle Expr-compat differences.
- Consider documenting the new expr_structure flag in JuliaSyntax user-facing docs once the WIP note is removed.
