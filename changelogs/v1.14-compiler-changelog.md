# Julia 1.14 Compiler Changes

*Summary of compiler changes from Julia 1.13 to 1.14 (development branch)*

---

## Frontend and Lowering

### JuliaSyntax and JuliaLowering Integration (PR #59870)

JuliaSyntax and JuliaLowering are now vendored into the main Julia tree as top-level packages. Both can optionally replace the flisp-based parser and lowering pipeline.

- `JuliaSyntax.enable_in_core!()` replaces the runtime parser for `include()`, REPL, and `Meta.parse()`
- `JuliaLowering.activate!()` replaces the entire lowering pipeline (macro expansion, desugaring, scope analysis, closure conversion, IR linearization)
- Default behavior unchanged; both require explicit opt-in
- JuliaSyntax sources compile into the sysimage

### Syntax Evolution Mechanism (PR #60018)

New mechanism for versioned parsing behavior. Future syntax changes can be gated behind version checks.

### Box Optimization in JuliaLowering (PR #60567)

JuliaLowering now implements flisp-compatible Box optimization via a def-use analysis pass (`analyze_def_and_use!`). Captured variables that are single-assigned and always-defined before capture no longer require `Core.Box` allocations:

```julia
function f(cond)
    if cond
        println("hello")
    end
    y = 1
    () -> y  # y is captured WITHOUT Box
end
```

This reduces closure allocation overhead and eliminates false-positive boxed-variable diagnostics in tools like JET.

### Lowering Fixes

- **PR #59784**: Make `=` and `const` toplevel-preserving, fixing closure conversion
- **PR #60140**: Fix placeholders in parameters and declarations
- **PR #60257**: Fix ccall and cfunction handling in JuliaLowering
- **PR #60316**: Refactor scope resolution pass
- **PR #60410**: Add `Expr(:loopinfo)` support
- **PR #60416**: Improve `@nospecialize` handling for unnamed arguments
- **PR #60551**: Fix remapping of reassigned arguments
- **PR #60577**: Leave static parameter captures unboxed
- **PR #60597**: Additional flisp closure box optimization fixes
- **PR #60619**: Fix `K"enter"` stmt_offset for try/catch lowering
- **PR #60646**: Skip analysis of variables owned by outer closures

### ccall Syntax Distinction (PR #59165)

The distinction between pointer and name in `ccall` is now a syntactic distinction via tuple syntax, changing the lowering and IR shape for foreign function calls.

---

## Type Inference

### Reaching Definitions for Slots (PR #55601)

Inference now tracks reaching definitions (`ssadef`) for slots, implementing the SSA path-convergence criterion. `VarState`, `Conditional`, and `MustAlias` carry a new `ssadef` field:

```julia
struct VarState
    typ
    ssadef::Int   # reaching definition ID
    undef::Bool
end
```

Key improvements:
- Conditionals invalidate when their slot is reassigned, preventing stale type narrowings
- `is_same_conditionals(a, b)` compares both `slot` and `ssadef`
- Fixes #55548: inference no longer incorrectly narrows types after slot reassignment

### Cycle Handling Fix (PR #59974)

Inference properly revisits all methods in recursive cycles. Cycle backedges record at result consumption (in `typeinf_edge`) rather than during detection, preventing cached `Union{}` results from persisting incorrectly.

### Other Inference Fixes

- **PR #59413**: Reinfer and track missing code for inlining
- **PR #59888**: Type-assert `isfinite(::AbstractFloat)` to fix invalidation issues
- **PR #59908**: Fix concrete_eval cancellation semantics
- **PR #59921**: Set types of boxed variables in `abstract_eval_nonlinearized_foreigncall_name`
- **PR #60011**: Fix pointer arithmetic Const widening in tfuncs
- **PR #60214**: Fix ptrfree field check in `is_field_pointerfree`
- **PR #60079**: Skip typeinf world compile in incremental compilation
- **PR #60093**: AOT CodeInstance selection at build time

---

## Codegen and Backend

### JITLink Enabled Everywhere (PR #60576)

JITLink is now the default memory manager on all platforms, replacing RTDyld. The `JLJITLinkMemoryManager` introduced in PR #60105 was initially reverted due to ARM64 deadlock issues; those are now resolved.

Note: Code model selection is independent of JITLink/RTDyld choice. x86_64 continues to use Large code model.

### Union Codegen Cleanup (PR #60353)

Significant cleanup of load/store/union handling:

- New `StoreKind` enum replaces multiple boolean flags (`Set`, `Swap`, `Replace`, `Modify`, `SetOnce`)
- Shared helpers `emit_aliased_load`/`emit_aliased_store` centralize TBAA and alias scope metadata
- `typed_load`/`typed_store` now handle unions via `ptindex` for tag loading/storing
- Union phi nodes with inline roots now correctly create ptr phi and root phi nodes
- Fixes issues #60345 and #60355

### Other Codegen Changes

- **PR #60388**: Improve size layout for on-stack pointer-ful types

---

## Threading and Concurrency

### Asymmetric Atomic Fences (PR #60311)

New asymmetric fence APIs for performance-sensitive synchronization:

```julia
Threads.atomic_fence_light()   # Cheap compiler barrier (singlethread syncscope)
Threads.atomic_fence_heavy()   # Expensive OS-level barrier
```

- Light fences synchronize only with heavy fences, not regular fences
- Heavy fence uses OS-specific implementations:
  - Linux/FreeBSD: `membarrier()` syscall or mprotect/thread-suspend fallbacks
  - macOS: `thread_get_register_pointer_values()` Mach call
  - Windows: `FlushProcessWriteBuffers()`
- `Core.Intrinsics.atomic_fence` now requires a syncscope argument: `atomic_fence(order, :system)` or `atomic_fence(order, :singlethread)`

---

## Runtime and GC

### Missing GC Root Fix (PR #59785)

Fixed a missing GC root in `jl_type_error_global` (introduced by PR #59766). The function now protects `JL_MAYBE_UNROOTED` arguments with `JL_GC_PUSH2` before calling allocation functions. Also corrects `jl_module_globalref` annotation from `JL_GLOBALLY_ROOTED` to `JL_PROPAGATES_ROOT`.

### GC Extensions API Change (PR #60517)

**Breaking Change**: Removed `jl_gc_external_obj_hdr_size()` from the GC extensions API. This function returned `sizeof(bigval_t)` for external allocations. GAP.jl has been updated. Alternatives:
- Use `jl_gc_set_cb_notify_external_alloc()` callbacks
- Hard-code 64 bytes (current size due to cache line alignment)

### Other Runtime Changes

- **PR #59766**: Align interpreter and codegen error behavior for `setglobal!` and related functions
- **PR #59772**: Skip method instance normalization for opaque closure methods
- **PR #59858**: Apply Transparent Huge Pages for large allocations

---

## Sanitizer Support

### Address/Memory/Thread Sanitizer (PR #59035)

New `--target-sanitize=(memory|thread|address)` flag enables AOT compilation with sanitizer instrumentation.

---

## IR and Optimizer

- **PR #56201**: Use stmt instead of Instruction in `populate_def_use_map!` for IR def-use correctness

---

## Impact on Downstream Tools

### High Impact

1. **JuliaSyntax/JuliaLowering integration**: Tools consuming lowered IR should prepare for new closure field layouts and different IR patterns when JuliaLowering is activated.

2. **VarState/Conditional ssadef tracking**: Tools constructing `Conditional` or `MustAlias` must pass `ssadef` (use `vtypes[slot].ssadef`).

3. **JITLink everywhere**: Memory manager behavior changes on all platforms.

4. **Box optimization**: Closure field layouts change for single-assigned captured variables.

### Medium Impact

1. **atomic_fence arity change**: Direct calls to `Core.Intrinsics.atomic_fence` must add syncscope argument.

2. **StoreKind enum**: Internal codegen restructuring affects anyone patching `cgutils.cpp`.

3. **jl_gc_external_obj_hdr_size removal**: C extensions using this API need updates.

### Recommendations for Downstream Maintainers

- **Enzyme.jl, GPUCompiler**: Verify JITLink compatibility and union codegen changes
- **JET.jl**: Update for reduced Box allocations and new IR patterns from JuliaLowering
- **Mooncake.jl**: Review changes to Conditional/MustAlias construction and validate type inference behavior

---

*Generated from PR analyses in `/analyses/`. Core PRs filtered via `/analyses/core_prs_filter.md`.*
