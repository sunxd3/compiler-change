schema_version: "1.0"

pr:
  number: 60066
  title: "only show unique entries in history search when filtering"
  url: "https://github.com/JuliaLang/julia/pull/60066"
  author: "KristofferC"
  labels:
    - "REPL"
  merged_at: "2025-11-07T17:37:32Z"
  merge_commit_sha: "aff738eb9d10a6ca2991588f7301342863d72041"
  diff_url: "https://github.com/JuliaLang/julia/pull/60066.diff"

scope:
  files_touched:
    - "stdlib/REPL/src/History/resumablefiltering.jl"
    - "stdlib/REPL/src/History/search.jl"
    - "stdlib/REPL/test/history.jl"
  components:
    - "REPL.History"
  pipeline_stages:
    - "REPL"
    - "UserInterface"

analysis:
  intent:
    summary: |
      Deduplicate history search results when filtering. Before this PR, when users search
      through REPL history, they would often see many duplicate entries (the same command
      repeated multiple times), which reduces signal-to-noise ratio. After this PR, when
      filtering with a search query, only unique entries (by mode and content) are shown.
      When browsing without any filter (empty query), all history including duplicates is
      preserved to maintain the full chronological view.
    issue_links: []

  direct_changes:
    - summary: "Add 'seen' Set parameter to filterchunkrev! for deduplication tracking"
      component: "REPL.History.resumablefiltering"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/History/resumablefiltering.jl"
          loc: "269-280"
          url: "https://github.com/JuliaLang/julia/blob/aff738eb9d10a6ca2991588f7301342863d72041/stdlib/REPL/src/History/resumablefiltering.jl#L269-L280"
          snippet: |
            """
                filterchunkrev!(out, candidates, spec, seen, idx; maxtime, maxresults) -> Int

            Incrementally filter `candidates[1:idx]` in reverse order.

            Pushes matches onto `out` until either `maxtime` is exceeded or `maxresults`
            collected, then returns the new resume index. Only unique entries (by mode and content)
            are added to avoid showing duplicate history items.
            """
            function filterchunkrev!(out::Vector{HistEntry}, candidates::DenseVector{HistEntry},
                                     spec::FilterSpec, seen::Set{Tuple{Symbol,String}}, idx::Int = length(candidates);
                                     maxtime::Float64 = Inf, maxresults::Int = length(candidates))

    - summary: "Implement deduplication logic by checking and updating 'seen' set"
      component: "REPL.History.resumablefiltering"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/History/resumablefiltering.jl"
          loc: "284-314"
          url: "https://github.com/JuliaLang/julia/blob/aff738eb9d10a6ca2991588f7301342863d72041/stdlib/REPL/src/History/resumablefiltering.jl#L284-L314"
          snippet: |
            for outer idx in batch
                entry = candidates[idx]
                if (entry.mode, entry.content) ∈ seen
                    continue
                end
                if !isempty(spec.modes)
                    entry.mode ∈ spec.modes || continue
                end
                matchfail = false
                for text in spec.exacts
                    if !occursin(text, entry.content)
                        matchfail = true
                        break
                    end
                end
                matchfail && continue
                for text in spec.negatives
                    if occursin(text, entry.content)
                        matchfail = true
                        break
                    end
                end
                matchfail && continue
                for rx in spec.regexps
                    if !occursin(rx, entry.content)
                        matchfail = true
                        break
                    end
                end
                matchfail && continue
                push!(seen, (entry.mode, entry.content))
                pushfirst!(out, entry)
                length(out) == maxresults && break
            end

    - summary: "Add filter_seen state and conditional deduplication in run_display!"
      component: "REPL.History.search"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/History/search.jl"
          loc: "64-65"
          url: "https://github.com/JuliaLang/julia/blob/aff738eb9d10a6ca2991588f7301342863d72041/stdlib/REPL/src/History/search.jl#L64-L65"
          snippet: |
            # Filter state
            filter_idx = 0
            filter_seen = Set{Tuple{Symbol,String}}()

        - source: "code"
          path: "stdlib/REPL/src/History/search.jl"
          loc: "156-171"
          url: "https://github.com/JuliaLang/julia/blob/aff738eb9d10a6ca2991588f7301342863d72041/stdlib/REPL/src/History/search.jl#L156-L171"
          snippet: |
            # Start filtering candidates
            # Only deduplicate when user has entered a search query. When browsing
            # with no filter (empty query), show all history including duplicates.
            if isempty(filter_spec.exacts) && isempty(filter_spec.negatives) &&
               isempty(filter_spec.regexps) && isempty(filter_spec.modes)
                # No filtering needed, just copy all candidates
                append!(state.candidates, cands_current)
                filter_idx = 0
            else
                # Filtering needed, deduplicate results
                empty!(filter_seen)
                filter_idx = filterchunkrev!(
                    state, cands_current, filter_seen;
                    maxtime = time() + 0.01,
                    maxresults = outsize[1])
            end

    - summary: "Update wrapper filterchunkrev! to pass seen set parameter"
      component: "REPL.History.search"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/History/search.jl"
          loc: "218-224"
          url: "https://github.com/JuliaLang/julia/blob/aff738eb9d10a6ca2991588f7301342863d72041/stdlib/REPL/src/History/search.jl#L218-L224"
          snippet: |
            function filterchunkrev!(state::SelectorState, candidates::DenseVector{HistEntry},
                                     seen::Set{Tuple{Symbol,String}}, idx::Int = length(candidates);
                                     maxtime::Float64 = Inf, maxresults::Int = length(candidates))
                oldlen = length(state.candidates)
                idx = filterchunkrev!(state.candidates, candidates, state.filter, seen, idx;
                                      maxtime = maxtime, maxresults = maxresults)
                newlen = length(state.candidates)

  secondary_effects:
    - effect: "Deduplication is mode-aware - same content in different modes is NOT deduplicated"
      mechanism: |
        The deduplication key is a tuple of (mode, content):
          if (entry.mode, entry.content) ∈ seen
              continue
          end
          push!(seen, (entry.mode, entry.content))

        This means:
        - "ls" in :julia mode and "ls" in :shell mode are considered different entries
        - Only exact duplicates (same mode AND same content) are deduplicated
        - The most recent occurrence of each unique entry is shown (since iteration is reverse)

        Call chain for deduplication:
        run_display!() [search.jl:49]
          -> filterchunkrev!(state, cands_current, filter_seen; ...) [search.jl:167-170]
            -> filterchunkrev!(out, candidates, spec, seen, idx; ...) [resumablefiltering.jl:278-320]
              -> checks: (entry.mode, entry.content) ∈ seen [line 286-288]
              -> updates: push!(seen, (entry.mode, entry.content)) [line 314]
      downstream_surfaces:
        - "REPL history search UI"
        - "Interactive history browsing"
      likelihood: "high"
      impact: "low"

    - effect: "Empty query bypasses deduplication to preserve full chronological history"
      mechanism: |
        The deduplication is conditional based on whether a filter is active:

        if isempty(filter_spec.exacts) && isempty(filter_spec.negatives) &&
           isempty(filter_spec.regexps) && isempty(filter_spec.modes)
            # No filtering needed, just copy all candidates
            append!(state.candidates, cands_current)
            filter_idx = 0
        else
            # Filtering needed, deduplicate results
            empty!(filter_seen)
            filter_idx = filterchunkrev!(...)
        end

        This design choice means:
        - When just browsing (no search term), users see complete history
        - When actively searching, duplicates are filtered out
        - The filter_seen set is cleared before each new search query
      downstream_surfaces:
        - "REPL history browsing behavior"
      likelihood: "high"
      impact: "low"

    - effect: "Incremental filtering maintains deduplication across chunks"
      mechanism: |
        The seen set persists across incremental filter chunks:

        Initial filtering [search.jl:166-170]:
          empty!(filter_seen)  # Clear at start of new query
          filter_idx = filterchunkrev!(state, cands_current, filter_seen; ...)

        Incremental filtering [search.jl:200-202]:
          filter_idx = filterchunkrev!(
              state, cands_current, filter_seen, filter_idx;  # Same seen set
              maxtime = time() + 0.01)

        The seen set is NOT cleared during incremental updates, ensuring that
        entries already shown won't be duplicated when more results load.
      downstream_surfaces:
        - "Incremental history loading"
        - "Large history file handling"
      likelihood: "high"
      impact: "low"

  compatibility:
    internal_api:
      - field: "filterchunkrev! function signature"
        change: "Added required 'seen::Set{Tuple{Symbol,String}}' parameter"
        affected_tools:
          - tool: "REPL.History internal"
            usage: "All callers of filterchunkrev! must now provide a seen set; not a public API"

    behavioral:
      - description: "History search results now deduplicate when a filter query is active"
        before: |
          # Searching for "cos" might show:
          cos(2π)
          cos(2π)
          cos(2π)
          cos(x)
          cos(2π)
        after: |
          # Now shows only unique entries:
          cos(2π)
          cos(x)
        risk: "low"

      - description: "Browsing without filter still shows all history including duplicates"
        before: "All entries shown when browsing"
        after: "All entries shown when browsing (unchanged)"
        risk: "none"

  performance:
    compile_time:
      - description: "No compile-time impact"
        detail: "Changes are entirely in REPL stdlib, not in compiler pipeline"

    runtime:
      - description: "O(1) hash table lookup for deduplication check"
        detail: |
          Each candidate entry requires:
          - One Set membership check: (entry.mode, entry.content) ∈ seen
          - One Set insertion if unique: push!(seen, (entry.mode, entry.content))

          Set operations are O(1) average case for hash-based Set.
          Memory usage: O(u) where u = number of unique entries shown.

          ESTIMATED: Negligible overhead (<1ms for typical history searches)

  risk:
    level: "low"
    rationale:
      - "Changes limited to REPL stdlib, no compiler impact"
      - "Deduplication is opt-in (only when filtering)"
      - "Mode-aware design prevents false deduplication across modes"
      - "Comprehensive test coverage added for uniqueness behavior"
      - "Does not affect history file format or storage"

  open_questions:
    - "Should deduplication be configurable by user preference?"
    - "Should there be a way to see duplicate count for deduplicated entries?"

  recommendations:
    - "This is a UX improvement with no compiler impact - safe for downstream packages"
    - "Users can still see full history by browsing without entering a search query"

  test_coverage:
    status: "Comprehensive test coverage added"
    detail: |
      New test section "Uniqueness" added to stdlib/REPL/test/history.jl:358-399

      Tests verify:
      1. Duplicate content in same mode is deduplicated:
         dup_entries = [
             HistEntry(:julia, now(UTC), "println(\"hello\")", 1),
             HistEntry(:julia, now(UTC), "cos(2π)", 2),
             HistEntry(:julia, now(UTC), "println(\"hello\")", 3),  # duplicate
             ...
         ]
         @test length(results) == 1  # Only unique "cos(2π)"

      2. Browsing without filter keeps all entries:
         append!(results, dup_entries)
         @test length(results) == 7  # All entries including duplicates

      3. Same content in different modes is NOT deduplicated:
         mode_entries = [
             HistEntry(:julia, now(UTC), "ls", 1),
             HistEntry(:shell, now(UTC), "ls", 2),  # Different mode
             HistEntry(:julia, now(UTC), "ls", 3),  # Duplicate in :julia
             ...
         ]
         @test length(results) == 2  # "ls" from :julia and "ls" from :shell

  callers_of_filterchunkrev:
    description: "All callers of filterchunkrev! updated to pass seen parameter"
    callers:
      - location: "stdlib/REPL/src/History/search.jl:167-170"
        usage: "Initial filtering when search query changes"
        snippet: |
          filter_idx = filterchunkrev!(
              state, cands_current, filter_seen;
              maxtime = time() + 0.01,
              maxresults = outsize[1])

      - location: "stdlib/REPL/src/History/search.jl:200-202"
        usage: "Incremental filtering as more results load"
        snippet: |
          filter_idx = filterchunkrev!(
              state, cands_current, filter_seen, filter_idx;
              maxtime = time() + 0.01)

      - location: "stdlib/REPL/src/History/search.jl:218-224"
        usage: "Wrapper function for SelectorState"
        snippet: |
          function filterchunkrev!(state::SelectorState, candidates::DenseVector{HistEntry},
                                   seen::Set{Tuple{Symbol,String}}, idx::Int = length(candidates);
                                   maxtime::Float64 = Inf, maxresults::Int = length(candidates))

      - location: "stdlib/REPL/test/history.jl:283-395"
        usage: "Test cases for filtering functionality"
        snippet: |
          seen = Set{Tuple{Symbol,String}}()
          @test filterchunkrev!(results, entries, spec, seen) == 0

  code_references:
    - description: "HistEntry struct definition"
      path: "stdlib/REPL/src/History/history.jl"
      note: "HistEntry contains mode::Symbol, date::DateTime, content::String, index::Int"

    - description: "FilterSpec struct definition"
      path: "stdlib/REPL/src/History/resumablefiltering.jl"
      loc: "215-220"
      url: "https://github.com/JuliaLang/julia/blob/aff738eb9d10a6ca2991588f7301342863d72041/stdlib/REPL/src/History/resumablefiltering.jl#L215-L220"
      snippet: |
        struct FilterSpec
            exacts::Vector{String}
            negatives::Vector{String}
            regexps::Vector{Regex}
            modes::Vector{Symbol}
        end

    - description: "SelectorState for display state management"
      path: "stdlib/REPL/src/History/search.jl"
      note: "Contains candidates, filter, selection state for the history search UI"

reviewer_notes:
  reviewed_at: "2026-01-22"
  reviewer: "Initial analysis"
  methodology: |
    1. Read PR metadata from pr-archive/JuliaLang_julia/pr_60066.json
    2. Checked out PR commit aff738eb9d10a6ca2991588f7301342863d72041
    3. Read full source files: resumablefiltering.jl, search.jl, history.jl test
    4. Traced filterchunkrev! callers with rg
    5. Analyzed test coverage for uniqueness behavior

  key_findings:
    - finding: "PR is a REPL UX improvement, not a compiler change"
      confidence: "high"
      evidence: "All changes in stdlib/REPL/src/History/ and test files"

    - finding: "Deduplication is mode-aware using tuple key"
      confidence: "high"
      evidence: "seen::Set{Tuple{Symbol,String}} where key is (entry.mode, entry.content)"

    - finding: "Empty query preserves full history (no deduplication)"
      confidence: "high"
      evidence: |
        Conditional check in search.jl:159-163:
        if isempty(filter_spec.exacts) && isempty(filter_spec.negatives) &&
           isempty(filter_spec.regexps) && isempty(filter_spec.modes)
            # No filtering needed, just copy all candidates

    - finding: "Test written by Claude Code (per PR description)"
      confidence: "high"
      evidence: "PR body states: 'Tests written by Claude Code'"

independent_review:
  reviewed_at: "2026-01-22"
  reviewer: "Second analysis pass"
  methodology: |
    1. Read existing analysis to understand first analyst's findings
    2. Fetched PR merge commit aff738eb9d10a6ca2991588f7301342863d72041 from Julia repo
    3. Read full source files independently: resumablefiltering.jl, search.jl, display.jl, histfile.jl, History.jl
    4. Traced all filterchunkrev! callers with rg
    5. Verified HistEntry struct definition and deduplication key composition
    6. Cross-referenced test cases with implementation

  verification_of_original_analysis:
    - claim: "filterchunkrev! signature changed to require seen parameter"
      verified: true
      evidence: |
        Line 264-266 of resumablefiltering.jl:
        function filterchunkrev!(out::Vector{HistEntry}, candidates::DenseVector{HistEntry},
                                 spec::FilterSpec, seen::Set{Tuple{Symbol,String}}, idx::Int = length(candidates);
                                 maxtime::Float64 = Inf, maxresults::Int = length(candidates))

    - claim: "Deduplication uses (mode, content) tuple as key"
      verified: true
      evidence: |
        Line 272-274 of resumablefiltering.jl:
        if (entry.mode, entry.content) ∈ seen
            continue
        end
        Line 300: push!(seen, (entry.mode, entry.content))

    - claim: "Empty query bypasses deduplication"
      verified: true
      evidence: |
        Lines 159-163 of search.jl check all filter components are empty before
        using append!(state.candidates, cands_current) instead of filterchunkrev!

    - claim: "All callers documented"
      verified: true
      evidence: "rg 'filterchunkrev!' found exactly the callers listed in original analysis"

  additional_findings:

    - finding: "HistEntry struct excludes date and index from deduplication"
      detail: |
        The HistEntry struct is defined in histfile.jl:16-26:
        struct HistEntry
            mode::Symbol
            date::DateTime
            content::String
            index::UInt32
        end

        The deduplication key (mode, content) intentionally excludes:
        - date: Same command at different times is considered duplicate
        - index: Same command with different indices is considered duplicate

        This design choice means users see unique commands, not unique history entries.

    - finding: "Ordering mechanism explicitly preserves most recent occurrence"
      detail: |
        The algorithm works as follows:
        1. Iteration: idx:-1:1 (highest index to lowest, newest to oldest)
        2. First encounter of (mode, content) is added to seen set
        3. Subsequent (older) encounters are skipped
        4. pushfirst!(out, entry) maintains chronological order in output

        Result: Newest occurrence of each unique command is kept, output is
        oldest-first within the result set.

        Test verification at history.jl:377-378:
        @test length(results) == 1
        @test results[1] == dup_entries[5]  # cos(2π) - index 5 is most recent

    - finding: "Memory usage bounded by unique (mode, content) pairs"
      detail: |
        The seen Set grows to O(u) where u = number of unique (mode, content) pairs
        in the filtered results. For typical REPL usage with thousands of history
        entries, this might be hundreds to low thousands of unique commands.

        Memory per entry: ~8 bytes (Symbol pointer) + string allocation
        Estimated upper bound for 10,000 unique commands: ~1-2 MB

    - finding: "No impact on history file storage"
      detail: |
        The deduplication is purely a display/search optimization:
        - HistoryFile in histfile.jl stores all entries including duplicates
        - push!(hist, entry) in histfile.jl:209-288 adds without deduplication
        - Deduplication only occurs during interactive search display

    - finding: "SelectorState does not store the seen set persistently"
      detail: |
        The seen set is a local variable in run_display! (search.jl:65):
        filter_seen = Set{Tuple{Symbol,String}}()

        It is:
        - Created fresh for each search session
        - Cleared with empty!(filter_seen) when filter query changes (line 166)
        - Preserved across incremental loading chunks within same query

  compiler_impact_assessment:
    impact: "NONE"
    rationale:
      - "All changes confined to stdlib/REPL/src/History/ directory"
      - "No changes to Compiler/, base/, src/, or any compiler-related code"
      - "PR labeled only as 'REPL' - not compiler-related"
      - "No type inference, codegen, or optimization changes"
      - "No changes to any public API used by downstream compiler tools"

  downstream_package_impact:
    JET: "No impact - JET does not interact with REPL history"
    Enzyme: "No impact - Enzyme does not interact with REPL history"
    GPUCompiler: "No impact - GPUCompiler does not interact with REPL history"

  conclusion: |
    The original analysis is accurate and comprehensive. This PR is a pure REPL
    user experience improvement that adds deduplication to history search results.
    It has zero impact on the Julia compiler, type inference, optimization, or
    any downstream compiler tooling. The changes are well-tested and low-risk.
