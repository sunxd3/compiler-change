schema_version: "1.0"
pr:
  number: 60474
  title: "Allow parsing to `Expr`-structured `SyntaxTree`"
  url: "https://github.com/JuliaLang/julia/pull/60474"
  author: "mlechu"
  labels:
    - "JuliaLowering"
  merged_at: "2025-12-29T16:53:06Z"
  merge_commit_sha: "e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe"
  diff_url: "https://github.com/JuliaLang/julia/pull/60474.diff"
scope:
  files_touched:
    - "JuliaLowering/src/compat.jl"
    - "JuliaLowering/src/kinds.jl"
    - "JuliaLowering/test/compat.jl"
    - "JuliaSyntax/src/integration/expr.jl"
    - "JuliaSyntax/src/julia/kinds.jl"
    - "JuliaSyntax/src/porcelain/syntax_graph.jl"
  components:
    - "JuliaSyntax"
    - "JuliaLowering"
  pipeline_stages:
    - "Parsing"
    - "Lowering"
analysis:
  intent:
    summary: "Introduce a RawGreenNode -> Expr-structured SyntaxTree (EST) conversion path and validate it against the existing Expr conversion, enabling Expr-compatible SyntaxTree parsing for macros and tooling."
    issue_links:
      - "https://github.com/JuliaLang/julia/pull/60373"
      - "https://github.com/JuliaLang/julia/pull/60431"
  direct_changes:
    - summary: "Add an expr_structure parsing mode that converts parser output to Expr-shaped SyntaxTree via _green_to_est instead of the existing AST conversion."
      component: "JuliaSyntax/porcelain"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
          loc: "747-784"
          url: "https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaSyntax/src/porcelain/syntax_graph.jl#L747-L784"
          snippet: |
            function build_tree(::Type{SyntaxTree}, stream::ParseStream;
                                filename=nothing, first_line=1,
                                expr_structure=false)
                cursor = RedTreeCursor(stream)
                graph = SyntaxGraph()
                sf = SourceFile(stream; filename, first_line)
                source = SourceRef(sf, first_byte(stream), last_byte(stream))
                cs = SyntaxList(graph)
                for c in reverse_toplevel_siblings(cursor)
                    is_trivia(c) && !is_error(c) && continue
                    push!(cs, SyntaxTree(graph, sf, c; expr_structure))
                end
                # There may be multiple non-trivia toplevel nodes (e.g. parse error)
                length(cs) === 1 && return only(cs)
                id = new_id!(graph)
                setchildren!(graph, id, reverse(cs).ids)
                setattr!(graph, id, :source, source)
                setattr!(graph, id, :kind, K"wrapper")
                return SyntaxTree(graph, id)
            end

            function SyntaxTree(graph::SyntaxGraph, sf::SourceFile, cursor::RedTreeCursor; expr_structure)
                ensure_attributes!(graph, kind=Kind, syntax_flags=UInt16,
                                   source=SourceAttrType, value=Any, name_val=String)
                green_id = GC.@preserve sf begin
                    raw_offset, txtbuf = _unsafe_wrap_substring(sf.code)
                    offset = raw_offset - sf.byte_offset
                    _insert_green(graph, sf, txtbuf, offset, cursor)
                end
                gst = SyntaxTree(graph, green_id)
                if expr_structure
                    out = _green_to_est(gst, 0, gst)
                else
                    out = _green_to_ast(K"None", gst)
                end
                @assert !isnothing(out) "SyntaxTree requires >0 nontrivia nodes"
                return out
            end
    - summary: "Implement RawGreenNode -> EST conversion rules (including macrocall and literal handling) to match Expr semantics, with pre-recursion child preprocessing and parameter reordering."
      component: "JuliaSyntax/porcelain"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
          loc: "906-1037"
          url: "https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaSyntax/src/porcelain/syntax_graph.jl#L906-L1037"
          snippet: |
            function _green_to_est(parent::SyntaxTree, parent_i::Int,
                                   st::SyntaxTree; kw_in_params=false)
                if !should_include_node(st)
                    @assert kind(parent) === K"None" && parent_i === 0
                    return nothing
                end

                graph = syntax_graph(st)
                k = kind(st)
                coreref(s::String) = setattr!(newleaf(graph, st, K"core"), :name_val, s)
                symleaf(s::String) = setattr!(newleaf(graph, st, K"Identifier"), :name_val, s)
                valleaf(@nospecialize(v)) = setattr!(newleaf(graph, st, K"Value"), :value, v)

                if is_leaf(st)
                    return if k === K"CmdMacroName" || k === K"StrMacroName"
                        name = lower_identifier_name(st.name_val, k)
                        symleaf(name)
                    elseif k === K"VERSION"
                        valleaf(version_to_expr(st))
                    elseif (v = get(st, :value, nothing); v isa Union{Int128,UInt128,BigInt})
                        # syntax TODO: likely unnecessary; this is just to match RGN->Expr,
                        # which added this to match flisp parsing text->Expr.
                        macname = v isa Int128 ? "@int128_str" :
                            v isa UInt128 ? "@uint128_str" : "@big_str"
                        mac = valleaf(GlobalRef(Core, Symbol(macname)))
                        arg = valleaf(replace(sourcetext(st), '_'=>""))
                        ret_cids = tree_ids(mac, coreref("nothing"), arg)
                        newnode(graph, st, K"macrocall", ret_cids)
                    else
                        st
                    end
                end

                # Non-leaf cases: each branch should either set `ret_k` and `cs` or recurse
                # manually and return a finished SyntaxTree
                ret_k::Kind = k
                cs = preprocessed_green_children(st)
                n_cs = length(cs)

                if k === K"string" && n_cs > 0
                    return _string_to_est(st, cs; unwrap_literal=true)
                elseif k === K"cmdstring" && n_cs > 0
                    # (cmdstring _...) => (macrocall Core.@cmd lno joined_str)
                    cmd_arg = _string_to_est(st, cs; unwrap_literal=true)
                    loc_st = valleaf(source_location(LineNumberNode, st))
                    return newnode(graph, st, K"macrocall", tree_ids(
                        valleaf(GlobalRef(Core, Symbol("@cmd"))), loc_st, cmd_arg))
                elseif k === K"macro_name" && n_cs === 1
                    # "M.@x" => (. M (macro_name x)) => (. M @x)
                    # "@M.x" => (macro_name (. M x)) => (. M @x)
                    #           (macro_name else) => else
                    if kind(cs[1]) === K"Identifier"
                        return symleaf(lower_identifier_name(cs[1].name_val, K"macro_name"))
                    else
                        inner_st = cs[1]
                        inner_cs = preprocessed_green_children(inner_st)
                        if (length(inner_cs) === 2 && kind(inner_st) === K"." &&
                            kind(inner_cs[2]) === K"Identifier")
                            (lhs, raw_m) = _green_to_est(cs[1], 1, inner_cs[1]), inner_cs[2]
                            mname_s = lower_identifier_name(raw_m.name_val, K"macro_name")
                            mname = setattr!(mkleaf(raw_m), :name_val, mname_s)
                            mname_inert = newnode(graph, raw_m, K"inert", tree_ids(mname))
                            return mknode(inner_st, tree_ids(lhs, mname_inert))
                        else
                            return _green_to_est(parent, 1, inner_st)
                        end
                    end
                elseif k === K"?"
                    ret_k = K"if"
                elseif k === K"op=" && n_cs === 3
                    # (op= a + b) => (+= a b)
                    # (.op= a + b) => (.+= a b) below
                    op_s = string(cs[2]) * '='
                    lhs = _green_to_est(st, 0, cs[1])
                    rhs = _green_to_est(st, 0, cs[3])
                    out = newnode(graph, st, K"unknown_head", tree_ids(lhs, rhs))
                    return setattr!(out, :name_val, op_s)
                elseif k === K".op=" && n_cs === 3
                    op_s = '.' * string(cs[2]) * '='
                    lhs = _green_to_est(st, 0, cs[1])
                    rhs = _green_to_est(st, 0, cs[3])
                    out = newnode(graph, st, K"unknown_head", tree_ids(lhs, rhs))
                    return setattr!(out, :name_val, op_s)
                elseif k === K"macrocall" && n_cs > 0
                    # LineNumberNodes are not usually added to the tree as they are in Expr,
                    # but this specifically inserts the macrocall child for compatibility
                    loc_st = let loc = source_location(LineNumberNode, st)
                        if n_cs >= 2 && kind(cs[2]) === K"VERSION"
                            v = version_to_expr(popat!(cs, 2))
                            loc = Core.MacroSource(loc, v)
                        end
                        valleaf(loc)
                    end
                    insert!(cs, 2, loc_st)
                    # foo`x` parses to (macrocall foo::CmdMacroName (cmdstring ::CmdString))
                    # so we need to unwrap the CmdString or else we get two macrocalls
                    if n_cs >= 2 && kind(cs[1]) === K"CmdMacroName"
                        ret_cs = _map_green_to_est(st, cs)
                        ret_cs[3] = ret_cs[3][3] # node leak
                        return mknode(st, ret_cs)
                    end
                    do_ex = kind(cs[end]) === K"do" ? pop!(cs) : nothing
                    _reorder_parameters!(cs, 3)
                    !isnothing(do_ex) && return _make_do_expression(st, cs, do_ex)
                elseif k === K"doc"
                    # (doc str obj) => (macrocall Core.@doc lno str obj)
                    ret_k = K"macrocall"
                    pushfirst!(cs, valleaf(source_location(LineNumberNode, st)))
                    pushfirst!(cs, valleaf(GlobalRef(Core, Symbol("@doc"))))
                elseif k === K"dotcall" || k === K"call" && n_cs > 0
                    if is_infix_op_call(st) || is_postfix_op_call(st)
                        cs[2], cs[1] = cs[1], cs[2]
                    end
                    if is_postfix_op_call(st) && kind(cs[1]) == K"Identifier" &&
                        cs[1].name_val === "'"
                        popfirst!(cs)
                        ret_k = K"'"
                    end
                    do_ex = kind(cs[end]) === K"do" ? pop!(cs) : nothing
                    _reorder_parameters!(cs, 2)
                    if k === K"dotcall"
                        if is_prefix_call(st)
                            # (dotcall f args...) => (. f (tuple args...))
                            ret_cs = _map_green_to_est(st, cs)
                            tuple = newnode(graph, st, K"tuple", ret_cs[2:end])
                            return newnode(graph, st, K".", tree_ids(ret_cs[1], tuple))
                        else
                            # (dotcall + args...) => (call .+ args...)
                            ret_k = K"call"
                            if kind(cs[1]) === K"Identifier"
                                cs[1] = symleaf('.' * cs[1].name_val)
                            end
                        end
                    end
                    !isnothing(do_ex) && return _make_do_expression(st, cs, do_ex)
    - summary: "Adjust Expr<->EST conversion to recognize literal/value nodes and the core/nothing encoding when roundtripping SyntaxTree back to Expr."
      component: "JuliaLowering/compat"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/compat.jl"
          loc: "659-731"
          url: "https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaLowering/src/compat.jl#L659-L731"
          snippet: |
            function is_expr_value(st::SyntaxTree)
                k = kind(st)
                return JuliaSyntax.is_literal(k) || k === K"Value" ||
                    k === K"core" && st.name_val === "nothing"
            end

            function _expr_to_est(graph::SyntaxGraph, @nospecialize(e), src::LineNumberNode)
                st = if e === Core.nothing
                    # e.value can't be nothing in `K"Value"`, so represent with K"core"
                    setattr!(newleaf(graph, src, K"core"), :name_val, "nothing")
                elseif e isa Symbol
                    setattr!(newleaf(graph, src, K"Identifier"), :name_val, String(e))
                elseif e isa QuoteNode
                    cid, _ = _expr_to_est(graph, e.value, src)
                    newnode(graph, src, K"inert", NodeId[cid])
                elseif e isa Expr && e.head === :scope_layer
                    @assert length(e.args) === 2 && e.args[1] isa Symbol
                    ident = newleaf(graph, src, K"Identifier")
                    setattr!(ident, :name_val, String(e.args[1]))
                    setattr!(ident, :scope_layer, e.args[2])
                elseif e isa Expr
                    head_s = string(e.head)
                    st_k = find_kind(head_s)
                    old_src = _get_inner_lnn(e, src)
                    cs = NodeId[]
                    rm_linenodes = e.head in (:block, :toplevel)
                    for arg in e.args
                        if rm_linenodes && arg isa LineNumberNode
                            src = arg
                        else
                            cid, src = _expr_to_est(graph, arg, src)
                            push!(cs, cid)
                        end
                    end
                    if isnothing(st_k)
                        setattr!(newnode(graph, src, K"unknown_head", cs), :name_val, head_s)
                    else
                        newnode(graph, old_src, st_k, cs)
                    end
                # elseif e isa GlobalRef
                    # TODO: Better-behaved as K"globalref", but lowering doesn't know this
                else
                    # We may want additional special cases for other types where
                    # `Base.isa_ast_node(e)`, but `K"Value"` should be fine for most, since
                    # most are produced in or after lowering
                    if e isa LineNumberNode
                        # linenode oustside of block or toplevel
                        src = e
                    end
                    setattr!(newleaf(graph, src, K"Value"), :value, e)
                end
                @assert isa_lowering_ast_node(e) || is_expr_value(st)

                return st._id, src
            end

            function est_to_expr(st::SyntaxTree)
                k = kind(st)
                return if k === K"core" && numchildren(st) === 0 && st.name_val === "nothing"
                    nothing
                elseif is_leaf(st) && hasattr(st, :name_val)
                    n = Symbol(st.name_val)
                    hasattr(st, :scope_layer) ? Expr(:scope_layer, n, st.scope_layer) : n
                elseif is_leaf(st) && is_expr_value(st)
                    v = st.value
                    # Let `st.value isa Symbol` (or other AST node).  Since we enforce that
                    # this is never produced by the reverse Expr->SyntaxTree transformation,
                    # there is no lonely Expr for which `st` is the only SyntaxTree
                    # representation.  This means we can pick some other expr this
                    # represents, namely Expr(`(inert ,st.value)) rather than
                    # Expr(st.value).
                    isa_lowering_ast_node(v) ? QuoteNode(v) : v
    - summary: "Migrate EST-specific kinds (Value, core, unknown_head, inert, flatten) from JuliaLowering to JuliaSyntax to enable their use during parsing to SyntaxTree."
      component: "JuliaSyntax/kinds"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/julia/kinds.jl"
          loc: "1060-1072"
          url: "https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaSyntax/src/julia/kinds.jl#L1060-L1072"
          snippet: |
            # Kinds not corresponding to surface syntax in RawGreenNode, but required
            # for parsing to a provenance-containing structure that is compatible with
            # Expr.  May shrink with syntax evolution.
            "BEGIN_SYNTAXTREE_KINDS"
                # A literal Julia value of any kind, as might be inserted into the
                # AST during macro expansion.  Only used in parsing to SyntaxTree.
                "Value"
                "core"
                "unknown_head"
                "flatten"
                # QuoteNode; not quasiquote
                "inert"
            "END_SYNTAXTREE_KINDS"
        - source: "code"
          path: "JuliaLowering/src/kinds.jl"
          loc: "14-19"
          url: "https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaLowering/src/kinds.jl#L14-L19"
          snippet: |
            "gc_preserve_begin"
            "gc_preserve_end"
            # A (quoted) `Symbol`
            "Symbol"
            # TODO: Use `meta` for inbounds and loopinfo etc?
            "inbounds"
    - summary: "Extract version_to_expr as shared utility function for VERSION node conversion, used by both RGN->Expr and RGN->EST paths."
      component: "JuliaSyntax/integration"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/integration/expr.jl"
          loc: "220-224"
          url: "https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaSyntax/src/integration/expr.jl#L220-L224"
          snippet: |
            function version_to_expr(node)
                @assert kind(node) === K"VERSION"
                nv = numeric_flags(flags(node))
                return VersionNumber(1, nv รท 10, nv % 10)
            end
    - summary: "Add bulk parsing tests that compare RawGreenNode->EST->Expr against RawGreenNode->Expr across Julia codebases and stdlibs."
      component: "JuliaLowering/tests"
      evidence:
        - source: "test"
          path: "JuliaLowering/test/compat.jl"
          loc: "801-839"
          url: "https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaLowering/test/compat.jl#L801-L839"
          snippet: |
            @testset "Test RawGreenNode->EST->Expr against RawGreenNode->Expr" begin
                function make_est(str)
                    e_ref = try
                        JS.parseall(Expr, str)
                    catch _
                        nothing
                    end
                    isnothing(e_ref) && return 0
                    est_test = JS.parseall(SyntaxTree, str; expr_structure=true)
                    e_test = JL.est_to_expr(est_test)
                    pass = expr_equal_forgiving(e_test, e_ref)
                    @test pass
                    if !pass
                        ((e_ref_min, e_test_min), indices) = find_diff(e_ref, e_test)
                        @info "diff:" e_ref_min e_test_min indices # e_ref e_test
                    end
                    return 1
                end

                @testset "bulk parsed code, no linenodes" begin
                    test_each_in_path(make_est, JL_DIR)

                    basedir = joinpath(Sys.BINDIR, Base.DATAROOTDIR, "julia", "base")
                    test_each_in_path(make_est, basedir)

                    base_testdir = joinpath(Sys.BINDIR, Base.DATAROOTDIR, "julia", "test")
                    test_each_in_path(make_est, base_testdir)

                    @testset "Parse Julia stdlib at $(Sys.STDLIB)" begin
                        for stdlib in readdir(Sys.STDLIB)
                            fulldir = joinpath(Sys.STDLIB, stdlib)
                            if isdir(fulldir)
                                test_each_in_path(make_est, joinpath(Sys.STDLIB, fulldir))
                            end
                        end
                    end

                end
            end
  secondary_effects:
    - effect: "Expr-structured SyntaxTree parsing now performs pre-recursion child filtering and parameter reordering, which can change child ordering and insertion of synthetic nodes compared with raw-syntax trees when expr_structure=true."
      mechanism: |
        build_tree(::Type{SyntaxTree}; expr_structure=true)  [syntax_graph.jl:747-765]
          -> SyntaxTree(graph, sf, cursor; expr_structure)   [syntax_graph.jl:768-784]
            -> _green_to_est(parent, parent_i, st)           [syntax_graph.jl:906-1262]
              -> preprocessed_green_children(st)            [syntax_graph.jl:1277-1288]
              -> _reorder_parameters!(cs, params_pos)       [syntax_graph.jl:1292-1304]
              -> _map_green_to_est(parent, cs)              [syntax_graph.jl:1264-1273]
      downstream_surfaces:
        - "JuliaSyntax.parseall(SyntaxTree; expr_structure=true) consumers"
        - "Macro tooling that inspects SyntaxTree children order"
      likelihood: "medium"
      impact: "medium"
    - effect: "Macrocall nodes gain an inserted LineNumberNode/MacroSource child and version-aware MacroSource, affecting macro argument positions in Expr-structured trees."
      mechanism: |
        _green_to_est(...) handles K"macrocall" by inserting loc child at position 2 and
        wrapping VERSION into Core.MacroSource before parameters reordering.  [syntax_graph.jl:989-1009]
        version_to_expr() extracts VERSION from syntax flags  [expr.jl:220-224]
      downstream_surfaces:
        - "Macros that inspect Expr-structured SyntaxTree via est_to_expr"
        - "Tools expecting macrocall child positions to match Expr"
      likelihood: "low"
      impact: "medium"
    - effect: 'EST<->Expr roundtripping now treats K"core"/nothing and literal leaves to avoid producing raw Expr nodes from value leaves, changing how QuoteNode vs raw Expr values are emitted.'
      mechanism: |
        is_expr_value() and est_to_expr() accept literal/Value/core-nothing leaves
        and map AST nodes to QuoteNode to avoid ambiguous Expr values.  [compat.jl:659-752]
      downstream_surfaces:
        - "JuliaLowering.est_to_expr callers"
        - 'SyntaxTree constructors that use K"Value"/literal leaves'
      likelihood: "low"
      impact: "low"
    - effect: 'EST-specific kinds (Value, core, unknown_head, inert, flatten) are now defined in JuliaSyntax rather than JuliaLowering, affecting downstream tooling that checks kind provenance or kind ranges.'
      mechanism: |
        Kinds moved from JuliaLowering/src/kinds.jl to JuliaSyntax/src/julia/kinds.jl
        in the new BEGIN_SYNTAXTREE_KINDS section (1060-1072).
        These kinds are required for parsing to EST but do not correspond to surface syntax.
      downstream_surfaces:
        - "Tools checking JuliaSyntax.is_* kind predicates"
        - "IRTools, Cassette that inspect kind definitions"
      likelihood: "low"
      impact: "low"
  compatibility:
    internal_api:
      - field: "build_tree(::Type{SyntaxTree}; expr_structure)"
        change: "Adds expr_structure keyword to request Expr-structured SyntaxTree conversion via _green_to_est."
        evidence:
          - source: "code"
            path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
            loc: "747-784"
            url: "https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaSyntax/src/porcelain/syntax_graph.jl#L747-L784"
            snippet: |
              function build_tree(::Type{SyntaxTree}, stream::ParseStream;
                                  filename=nothing, first_line=1,
                                  expr_structure=false)
                  cursor = RedTreeCursor(stream)
                  graph = SyntaxGraph()
                  sf = SourceFile(stream; filename, first_line)
                  source = SourceRef(sf, first_byte(stream), last_byte(stream))
                  cs = SyntaxList(graph)
                  for c in reverse_toplevel_siblings(cursor)
                      is_trivia(c) && !is_error(c) && continue
                      push!(cs, SyntaxTree(graph, sf, c; expr_structure))
                  end
                  # There may be multiple non-trivia toplevel nodes (e.g. parse error)
                  length(cs) === 1 && return only(cs)
                  id = new_id!(graph)
                  setchildren!(graph, id, reverse(cs).ids)
                  setattr!(graph, id, :source, source)
                  setattr!(graph, id, :kind, K"wrapper")
                  return SyntaxTree(graph, id)
              end

              function SyntaxTree(graph::SyntaxGraph, sf::SourceFile, cursor::RedTreeCursor; expr_structure)
                  ensure_attributes!(graph, kind=Kind, syntax_flags=UInt16,
                                     source=SourceAttrType, value=Any, name_val=String)
                  green_id = GC.@preserve sf begin
                      raw_offset, txtbuf = _unsafe_wrap_substring(sf.code)
                      offset = raw_offset - sf.byte_offset
                      _insert_green(graph, sf, txtbuf, offset, cursor)
                  end
                  gst = SyntaxTree(graph, green_id)
                  if expr_structure
                      out = _green_to_est(gst, 0, gst)
                  else
                      out = _green_to_ast(K"None", gst)
                  end
                  @assert !isnothing(out) "SyntaxTree requires >0 nontrivia nodes"
                  return out
              end
      - field: "JuliaLowering.est_to_expr literal handling"
        change: 'Accepts K"core"/nothing and literal K"Value" nodes as Expr values with QuoteNode protection.'
        evidence:
          - source: "code"
            path: "JuliaLowering/src/compat.jl"
            loc: "659-752"
            url: "https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaLowering/src/compat.jl#L659-L752"
            snippet: |
              function is_expr_value(st::SyntaxTree)
                  k = kind(st)
                  return JuliaSyntax.is_literal(k) || k === K"Value" ||
                      k === K"core" && st.name_val === "nothing"
              end

              function est_to_expr(st::SyntaxTree)
                  k = kind(st)
                  return if k === K"core" && numchildren(st) === 0 && st.name_val === "nothing"
                      nothing
                  elseif is_leaf(st) && hasattr(st, :name_val)
                      n = Symbol(st.name_val)
                      hasattr(st, :scope_layer) ? Expr(:scope_layer, n, st.scope_layer) : n
                  elseif is_leaf(st) && is_expr_value(st)
                      v = st.value
                      # Let `st.value isa Symbol` (or other AST node).  Since we enforce that
                      # this is never produced by the reverse Expr->SyntaxTree transformation,
                      # there is no lonely Expr for which `st` is the only SyntaxTree
                      # representation.  This means we can pick some other expr this
                      # represents, namely Expr(`(inert ,st.value)) rather than
                      # Expr(st.value).
                      isa_lowering_ast_node(v) ? QuoteNode(v) : v
      - field: "Kind definitions (Value, core, unknown_head, inert)"
        change: "These kinds moved from JuliaLowering to JuliaSyntax in new BEGIN_SYNTAXTREE_KINDS section; tools checking kind module provenance may need updates."
        evidence:
          - source: "code"
            path: "JuliaSyntax/src/julia/kinds.jl"
            loc: "1060-1072"
            url: "https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaSyntax/src/julia/kinds.jl#L1060-L1072"
            snippet: |
              # Kinds not corresponding to surface syntax in RawGreenNode, but required
              # for parsing to a provenance-containing structure that is compatible with
              # Expr.  May shrink with syntax evolution.
              "BEGIN_SYNTAXTREE_KINDS"
                  "Value"
                  "core"
                  "unknown_head"
                  "flatten"
                  "inert"
              "END_SYNTAXTREE_KINDS"
    behavioral:
      - change: "Parsing with expr_structure=true yields SyntaxTree nodes reordered and normalized to match Expr forms (e.g., macrocall inserting loc child, parameter reordering, operator note)."
        evidence:
          - source: "code"
            path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
            loc: "989-1037"
            url: "https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaSyntax/src/porcelain/syntax_graph.jl#L989-L1037"
            snippet: |
              elseif k === K"macrocall" && n_cs > 0
                  # LineNumberNodes are not usually added to the tree as they are in Expr,
                  # but this specifically inserts the macrocall child for compatibility
                  loc_st = let loc = source_location(LineNumberNode, st)
                      if n_cs >= 2 && kind(cs[2]) === K"VERSION"
                          v = version_to_expr(popat!(cs, 2))
                          loc = Core.MacroSource(loc, v)
                      end
                      valleaf(loc)
                  end
                  insert!(cs, 2, loc_st)
                  # foo`x` parses to (macrocall foo::CmdMacroName (cmdstring ::CmdString))
                  # so we need to unwrap the CmdString or else we get two macrocalls
                  if n_cs >= 2 && kind(cs[1]) === K"CmdMacroName"
                      ret_cs = _map_green_to_est(st, cs)
                      ret_cs[3] = ret_cs[3][3] # node leak
                      return mknode(st, ret_cs)
                  end
                  do_ex = kind(cs[end]) === K"do" ? pop!(cs) : nothing
                  _reorder_parameters!(cs, 3)
                  !isnothing(do_ex) && return _make_do_expression(st, cs, do_ex)
  performance:
    compile_time:
      - impact: "ESTIMATED: O(n) additional tree-walk when expr_structure=true to preprocess children and reorder parameters before recursion."
        evidence:
          - source: "code"
            path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
            loc: "1258-1304"
            url: "https://github.com/JuliaLang/julia/blob/e9bbdafacfdb87eae42bbdd0a0885d0fc564edbe/JuliaSyntax/src/porcelain/syntax_graph.jl#L1258-L1304"
            snippet: |
              # Recurse on `cs`.  If no children change, just return `st`.
              ret_cs = _map_green_to_est(st, cs; kw_in_params)
              return ret_cs.ids == children(st).ids && ret_k == kind(st) ?
                  st : setattr!(mknode(st, ret_cs), :kind, ret_k)

              function _map_green_to_est(parent::SyntaxTree, cs::SyntaxList;
                                         kw_in_params=false, undef_parent=false)
                  ret_cs = SyntaxList(cs.graph)
                  for (i, c) in enumerate(cs)
                      new_c = _green_to_est(parent, undef_parent ? 0 : i, c; kw_in_params)
                      @assert should_include_node(new_c)
                      push!(ret_cs, new_c)
                  end
                  ret_cs
              end

              # (call f a b (parameters c d) (parameters e)) =>
              # (call f (parameters (parameters e) c d) a b)
              function _reorder_parameters!(cs::SyntaxList, params_pos::Int)
                  (length(cs) > params_pos && kind(cs[end]) === K"parameters") || return cs
                  local param_ball = pop!(cs)
                  while length(cs) >= 1 && kind(cs[end]) === K"parameters"
                      next_ball_cs = pushfirst!(copy(children(cs[end])), param_ball)
                      # `mknode` leaks nodes, but having multiple `parameters` blocks is
                      # extremely rare nonsense syntax (`f(a,b;c=d;e)`)
                      param_ball = mknode(cs[end], next_ball_cs)
                      pop!(cs)
                  end
                  insert!(cs, params_pos, param_ball)
                  nothing
              end
    runtime: []
  risk:
    level: "low"
    rationale:
      - "expr_structure is opt-in and defaults to the existing RawGreenNode->AST conversion path." 
      - "Bulk parsing tests compare RawGreenNode->EST->Expr to RawGreenNode->Expr across base, tests, and stdlib, reducing semantic drift risk."
  open_questions:
    - "How should the TODO-noted node leak in _reorder_parameters! (multiple parameters blocks) be handled in long-running tooling that repeatedly parses with expr_structure=true?"
    - "The K\".\" / K\"parens\" coalescing comment suggests parens can change results; should this be addressed before making expr_structure default?"
  recommendations:
    - "Downstream tools that switch to expr_structure=true should add golden tests around macrocall argument positions and parameter block ordering to catch subtle Expr-compat differences."
    - "Consider documenting the new expr_structure flag in JuliaSyntax user-facing docs once the WIP note is removed."
