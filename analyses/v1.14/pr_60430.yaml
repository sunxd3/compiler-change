schema_version: "1.0"
pr:
  number: 60430
  title: "Don't make graph type abstract in SyntaxTree"
  url: "https://github.com/JuliaLang/julia/pull/60430"
  author: "mlechu"
  labels:
    - "JuliaLowering"
  merged_at: "2025-12-24T19:41:25Z"
  merge_commit_sha: "c711544f4e229c9bde575e76918ee311b72914b2"
  diff_url: "https://github.com/JuliaLang/julia/pull/60430.diff"
scope:
  files_touched:
    - "JuliaSyntax/src/porcelain/syntax_graph.jl"
    - "JuliaLowering/src/ast.jl"
    - "JuliaLowering/src/closure_conversion.jl"
    - "JuliaLowering/src/desugaring.jl"
    - "JuliaLowering/src/eval.jl"
    - "JuliaLowering/src/linear_ir.jl"
    - "JuliaLowering/src/macro_expansion.jl"
    - "JuliaLowering/src/scope_analysis.jl"
  components:
    - "JuliaSyntax"
    - "JuliaLowering"
  pipeline_stages:
    - "Parsing"
    - "Lowering"
    - "LinearIR"
analysis:
  intent:
    summary: "Remove abstract graph type parameter from SyntaxTree/SyntaxList, keeping only abstract attribute storage (Attrs). The PR author noticed partially-parameterized SyntaxTrees in signatures causing method instance explosion. Change reduces precompilation time by ~25% according to PR description."
    issue_links: []
  direct_changes:
    - summary: "SyntaxTree now stores a concrete SyntaxGraph{Attrs} instead of an abstract graph type parameter, tying the tree directly to the attribute storage type."
      component: "JuliaSyntax"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
          loc: "189-198"
          url: "https://github.com/JuliaLang/julia/blob/c711544f4e229c9bde575e76918ee311b72914b2/JuliaSyntax/src/porcelain/syntax_graph.jl#L189-L198"
          snippet: |
            """
                struct SyntaxTree

            An ECS-style AST used in JuliaLowering.  Unstable, but may eventually replace
            SyntaxNode.
            """
            struct SyntaxTree{Attrs}
                _graph::SyntaxGraph{Attrs}
                _id::NodeId
            end
    - summary: "SyntaxList is now parameterized by attribute storage and explicitly stores SyntaxGraph{Attrs}. The SyntaxList(ctx, v::Vector{SyntaxTree}) constructor was removed."
      component: "JuliaSyntax"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
          loc: "449-463"
          url: "https://github.com/JuliaLang/julia/blob/c711544f4e229c9bde575e76918ee311b72914b2/JuliaSyntax/src/porcelain/syntax_graph.jl#L449-L463"
          snippet: |
            #-------------------------------------------------------------------------------
            # Lightweight vector of nodes ids with associated pointer to graph stored separately.
            mutable struct SyntaxList{Attrs, NodeIdVecType} <: AbstractVector{SyntaxTree}
                graph::SyntaxGraph{Attrs}
                ids::NodeIdVecType
            end

            function SyntaxList(graph::SyntaxGraph{T}, ids::AbstractVector{NodeId}) where {T}
                SyntaxList{T, typeof(ids)}(graph, ids)
            end

            SyntaxList(graph::SyntaxGraph) = SyntaxList(graph, Vector{NodeId}())
            SyntaxList(ctx) = SyntaxList(syntax_graph(ctx))

            syntax_graph(lst::SyntaxList) = lst.graph
    - summary: "Lowering contexts now store concrete SyntaxGraph{Attrs} and propagate Attrs through ClosureConversion and Linear IR structures, reducing abstract graph typing inside lowering passes."
      component: "JuliaLowering"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/closure_conversion.jl"
          loc: "1-38"
          url: "https://github.com/JuliaLang/julia/blob/c711544f4e229c9bde575e76918ee311b72914b2/JuliaLowering/src/closure_conversion.jl#L1-L38"
          snippet: |
            struct ClosureInfo{Attrs}
                # Global name of the type of the closure
                type_name::SyntaxTree{Attrs}
                # Names of fields for use with getfield, in order
                field_names::SyntaxList{Attrs, Vector{NodeId}}
                # Map from the original BindingId of closed-over vars to the index of the
                # associated field in the closure type.
                field_inds::Dict{IdTag,Int}
            end

            struct ClosureConversionCtx{Attrs} <: AbstractLoweringContext
                graph::SyntaxGraph{Attrs}
                bindings::Bindings
                mod::Module
                closure_bindings::Dict{IdTag,ClosureBindings}
                capture_rewriting::Union{Nothing,ClosureInfo{Attrs},
                                         SyntaxList{Attrs, Vector{NodeId}}}
                lambda_bindings::LambdaBindings
                # True if we're in a section of code which preserves top-level sequencing
                # such that closure types can be emitted inline with other code.
                is_toplevel_seq_point::Bool
                # True if this expression should not have toplevel effects, namely, it
                # should not declare the globals it references.  This allows generated
                # functions to refer to globals that have already been declared, without
                # triggering the "function body AST not pure" error.
                toplevel_pure::Bool
                toplevel_stmts::SyntaxList{Attrs, Vector{NodeId}}
                closure_infos::Dict{IdTag,ClosureInfo{Attrs}}
            end

            function ClosureConversionCtx(graph::SyntaxGraph{Attrs}, bindings::Bindings,
                                          mod::Module, closure_bindings::Dict{IdTag,ClosureBindings},
                                          lambda_bindings::LambdaBindings) where {Attrs}
                ClosureConversionCtx{Attrs}(
                    graph, bindings, mod, closure_bindings, nothing,
                    lambda_bindings, false, true, SyntaxList(graph),
                    Dict{IdTag,ClosureInfo{Attrs}}())
            end
        - source: "code"
          path: "JuliaLowering/src/linear_ir.jl"
          loc: "67-93"
          url: "https://github.com/JuliaLang/julia/blob/c711544f4e229c9bde575e76918ee311b72914b2/JuliaLowering/src/linear_ir.jl#L67-L93"
          snippet: |
            struct LinearIRContext{Attrs} <: AbstractLoweringContext
                graph::SyntaxGraph{Attrs}
                code::SyntaxList{Attrs, Vector{NodeId}}
                bindings::Bindings
                next_label_id::Ref{Int}
                is_toplevel_thunk::Bool
                lambda_bindings::LambdaBindings
                return_type::Union{Nothing, SyntaxTree{Attrs}}
                break_targets::Dict{String, JumpTarget{Attrs}}
                handler_token_stack::SyntaxList{Attrs, Vector{NodeId}}
                catch_token_stack::SyntaxList{Attrs, Vector{NodeId}}
                finally_handlers::Vector{FinallyHandler{Attrs}}
                symbolic_jump_targets::Dict{String,JumpTarget{Attrs}}
                symbolic_jump_origins::Vector{JumpOrigin{Attrs}}
                meta::Dict{Symbol, Any}
                mod::Module
            end

            function LinearIRContext(ctx, is_toplevel_thunk, lambda_bindings, return_type)
                graph = syntax_graph(ctx)
                rett = isnothing(return_type) ? nothing : reparent(graph, return_type)
                Attrs = typeof(graph.attributes)
                LinearIRContext(graph, SyntaxList(ctx), ctx.bindings, Ref(0),
                                is_toplevel_thunk, lambda_bindings, rett,
                                Dict{String,JumpTarget{Attrs}}(), SyntaxList(ctx), SyntaxList(ctx),
                                Vector{FinallyHandler{Attrs}}(), Dict{String,JumpTarget{Attrs}}(),
                                Vector{JumpOrigin{Attrs}}(), Dict{Symbol, Any}(), ctx.mod)
            end
    - summary: "Existing tests continue to validate SyntaxTree construction/parsing behavior, indicating the change is type-structural rather than a parsing semantic change."
      component: "JuliaSyntax"
      evidence:
        - source: "test"
          path: "JuliaSyntax/test/syntax_graph.jl"
          loc: "45-51"
          url: "https://github.com/JuliaLang/julia/blob/c711544f4e229c9bde575e76918ee311b72914b2/JuliaSyntax/test/syntax_graph.jl#L45-L51"
          snippet: |
            @testset "SyntaxTree parsing" begin
                # Errors should fall through
                @test parsestmt(SyntaxTree, "@"; ignore_errors=true) isa SyntaxTree
                @test parsestmt(SyntaxTree, "@@@"; ignore_errors=true) isa SyntaxTree
                @test parsestmt(SyntaxTree, "(a b c)"; ignore_errors=true) isa SyntaxTree
                @test parsestmt(SyntaxTree, "'a b c'"; ignore_errors=true) isa SyntaxTree
            end
  secondary_effects:
    - effect: "Lowering context types become more concrete, which can reduce specialization blow-up and precompile time in JuliaLowering-heavy workloads."
      mechanism: |
        All lowering contexts now parameterize on Attrs (the attribute storage type) instead of GraphType:

        MacroExpansionContext{Attrs}  [macro_expansion.jl:3]
          -> graph::SyntaxGraph{Attrs}  [macro_expansion.jl:4]
        DesugaringContext{Attrs}  [desugaring.jl:3]
          -> graph::SyntaxGraph{Attrs}  [desugaring.jl:4]
        ScopeResolutionContext{Attrs}  [scope_analysis.jl:55]
          -> graph::SyntaxGraph{Attrs}  [scope_analysis.jl:56]
        VariableAnalysisContext{Attrs}  [scope_analysis.jl:532]
          -> graph::SyntaxGraph{Attrs}  [scope_analysis.jl:533]
          -> method_def_stack::SyntaxList{Attrs, Vector{NodeId}}  [scope_analysis.jl:539]
        ClosureConversionCtx{Attrs}  [closure_conversion.jl:11]
          -> graph::SyntaxGraph{Attrs}  [closure_conversion.jl:12]
        LinearIRContext{Attrs}  [linear_ir.jl:67]
          -> graph::SyntaxGraph{Attrs}  [linear_ir.jl:68]
          -> Attrs = typeof(graph.attributes)  [linear_ir.jl:88]

        Helper structs also updated:
        JumpTarget{Attrs}, JumpOrigin{Attrs}, FinallyHandler{Attrs}  [linear_ir.jl:28-58]
        StatementListCtx{Ctx, Attrs}  [ast.jl:565]
        LoweringIterator{Attrs}  [eval.jl:35]
      downstream_surfaces:
        - "Lowering pass caching / method instance count"
        - "Precompilation time for JuliaLowering consumers"
      likelihood: "high"
      impact: "medium"
    - effect: "Custom graphs are no longer accepted by SyntaxTree/SyntaxList-based lowering contexts without wrapping in SyntaxGraph{Attrs}, reducing polymorphism at the SyntaxTree boundary."
      mechanism: |
        SyntaxTree{Attrs} stores _graph::SyntaxGraph{Attrs}  [syntax_graph.jl:195-197]
          -> SyntaxList{Attrs,...} stores graph::SyntaxGraph{Attrs}  [syntax_graph.jl:451-453]
          -> All contexts require SyntaxGraph{Attrs}, not abstract GraphType
          -> Previously: struct ClosureConversionCtx{GraphType}; graph::GraphType
          -> Now: struct ClosureConversionCtx{Attrs}; graph::SyntaxGraph{Attrs}
      downstream_surfaces:
        - "Packages that construct SyntaxTree with non-SyntaxGraph graphs"
        - "Custom AST graph experiments that relied on graph-type polymorphism"
      likelihood: "low"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "SyntaxTree{Attrs}::_graph"
        change: "Now concretely typed as SyntaxGraph{Attrs} instead of a generic graph type parameter, so type-parameterized extensions on SyntaxTree{GraphType} must adapt to Attrs-based typing."
        affected_tools: []
      - field: "SyntaxList{Attrs}::graph"
        change: "Now concretely typed as SyntaxGraph{Attrs}; downstream code depending on SyntaxList{GraphType} polymorphism will need refactoring."
        affected_tools: []
      - field: "SyntaxList(ctx, v::Vector{SyntaxTree})"
        change: "REMOVED - This constructor that converted a Vector{SyntaxTree} to SyntaxList was deleted. Code using this constructor must manually construct via SyntaxList(syntax_graph(ctx), NodeId[x._id for x in v])."
        affected_tools: []
    behavioral: []
  performance:
    compile_time:
      - "CLAIMED (PR author): Reduces precompilation time by about 25% for JuliaLowering. Author noted: 'we are down to less than double JuliaSyntax now!'"
      - "ESTIMATED: Fewer method instances due to concrete SyntaxGraph{Attrs} typing in lowering contexts. The Attrs-based parameterization prevents partially-parameterized SyntaxTrees in method signatures."
    runtime: []
  risk:
    level: "low"
    rationale:
      - "No algorithmic behavior changes in parsing/lowering; changes are type-structural."
      - "Potential impact is mostly on internal API expectations about graph type parameters."
      - "The removed SyntaxList(ctx, v::Vector{SyntaxTree}) constructor is an internal API unlikely to be used externally."
  open_questions:
    - "Are any downstream tools constructing SyntaxTree with custom graph types (non-SyntaxGraph) that now fail to type-check?"
    - "The claimed 25% precompilation improvement is from PR author observation; independent verification would strengthen confidence."
  recommendations:
    - "Run package CI or targeted precompile benchmarks for tools that specialize on SyntaxTree/SyntaxList types to confirm reduced method instance counts."
