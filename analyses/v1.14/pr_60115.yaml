schema_version: "1.0"

pr:
  number: 60115
  title: "document metrics from GC_Num; rename one metric from GC_Num to match the name used by the equivalent C struct"
  url: "https://github.com/JuliaLang/julia/pull/60115"
  author: "d-netto"
  labels:
    - "GC"
  merged_at: "2025-11-14T22:33:29Z"
  merge_commit_sha: "6a55e524b87988210135a29f832d614a9366afe0"
  diff_url: "https://github.com/JuliaLang/julia/pull/60115.diff"

scope:
  files_touched:
    - "base/timing.jl"
    - "src/gc-interface.h"
  components:
    - "GC"
    - "Runtime"
  pipeline_stages:
    - "Runtime"

analysis:
  intent:
    summary: |
      This PR makes two changes to the GC metrics infrastructure:

      1. **Documentation**: Adds comprehensive documentation comments to all 28 fields of the
         GC_Num struct (Julia) and jl_gc_num_t struct (C). The documentation explains:
         - What each field measures (bytes, counts, timestamps, durations)
         - Whether the field is GC-internal (reset after each GC cycle) or cumulative
         - Time units (nanoseconds for all timing fields)
         - Special notes about field semantics (e.g., pool allocator threshold of 2032 bytes)

      2. **API Rename**: Renames one field from `collect` to `interval` in the Julia GC_Num
         struct to match the corresponding field name in the C jl_gc_num_t struct. This field
         represents the per-thread allocation quota before triggering a GC, though the
         documentation notes it is "no longer used by the heuristics in the stock GC".

      The author states they plan to "clean up the GC metrics code a bit more in subsequent PRs".
    issue_links: []

  direct_changes:
    - summary: "Rename GC_Num.collect to GC_Num.interval for consistency with C struct"
      component: "GC"
      evidence:
        - source: "diff"
          path: "base/timing.jl"
          loc: "35-37"
          url: "https://github.com/JuliaLang/julia/blob/6a55e524b87988210135a29f832d614a9366afe0/base/timing.jl#L35-L37"
          snippet: |
            # (GC internal) Per-thread allocation quota before triggering a GC
            # NOTE: This field is no longer used by the heuristics in the stock GC
            interval::Csize_t
          note: "Previously named 'collect', now 'interval' to match C struct field name"

    - summary: "Add documentation comments to all 28 fields of GC_Num Julia struct"
      component: "GC"
      evidence:
        - source: "code"
          path: "base/timing.jl"
          loc: "4-75"
          url: "https://github.com/JuliaLang/julia/blob/6a55e524b87988210135a29f832d614a9366afe0/base/timing.jl#L4-L75"
          snippet: |
            struct GC_Num
                # (GC Internal) Number of allocated bytes since the last collection. This field is reset
                # after the end of every garbage collection cycle, so it will always be zero if observed
                # during execution of Julia user code
                allocd::Int64
                # (GC Internal) Number of allocated bytes within a `gc_disable/gc_enable` block. This field is
                # reset after every garbage collection cycle and will always be zero in case of no use
                # of `gc_disable/gc_enable` blocks
                deferred_alloc::Int64
                # (GC Internal) Number of bytes freed bytes in the current collection cycle. This field is
                # reset after every garbage collection cycle and will always be zero when observed
                # during execution of Julia user code. It's incremented as memory is reclaimed during a collection,
                # used to gather some statistics within the collection itself and reset at the end of a GC cycle.
                freed::Int64
                # Number of `malloc/calloc` calls (never reset by the runtime)
                malloc::Int64
                # ... [28 total documented fields]
            end

    - summary: "Add matching documentation comments to jl_gc_num_t C struct"
      component: "GC"
      evidence:
        - source: "code"
          path: "src/gc-interface.h"
          loc: "28-99"
          url: "https://github.com/JuliaLang/julia/blob/6a55e524b87988210135a29f832d614a9366afe0/src/gc-interface.h#L28-L99"
          snippet: |
            // This struct must be kept in sync with the Julia type of the same name in base/timing.jl
            typedef struct {
                // (GC Internal) Number of allocated bytes since the last collection. This field is reset
                // after the end of every garbage collection cycle, so it will always be zero if observed
                // during execution of Julia user code
                int64_t allocd;
                // (GC Internal) Number of allocated bytes within a `gc_disable/gc_enable` block. This field is
                // reset after every garbage collection cycle and will always be zero in case of no use
                // of `gc_disable/gc_enable` blocks
                int64_t deferred_alloc;
                // ... [28 total documented fields matching Julia struct]
            } jl_gc_num_t;

  secondary_effects:
    - effect: "Breaking change for code accessing gc_num().collect"
      mechanism: |
        Any Julia code that accessed the GC_Num struct's `collect` field will now fail:

        Before PR:
          stats = Base.gc_num()
          stats.collect  # Returns Csize_t value

        After PR:
          stats = Base.gc_num()
          stats.collect  # ERROR: type GC_Num has no field collect
          stats.interval # Correct new name

        This affects:
        - User code that inspects GC metrics via gc_num()
        - Third-party GC monitoring/profiling tools
        - Any packages that access raw GC statistics

        Call chain showing field access:
          gc_num() [base/timing.jl:77]
            -> ccall(:jl_gc_num, GC_Num, ())
            -> Returns GC_Num struct
          stats.interval [was stats.collect]
            -> Accesses renamed field
      downstream_surfaces:
        - "User code accessing gc_num().collect"
        - "GC monitoring and profiling packages"
      likelihood: "low"
      impact: "medium"

    - effect: "C struct already used 'interval' name - no C code changes needed"
      mechanism: |
        The C struct jl_gc_num_t already used the name 'interval' for this field.
        The PR only renames the Julia wrapper struct field to match.

        C struct field usage in gc-stock.c:
          gc_num.interval = default_collect_interval;  [gc-stock.c:3701]
          jl_atomic_load_relaxed(&ptls->gc_tls_common.gc_num.allocd) + gc_num.interval  [gc-stock.c:576]
          jl_atomic_store_relaxed(&ptls->gc_tls_common.gc_num.allocd, -(int64_t)gc_num.interval)  [gc-stock.c:603]

        C struct field usage in gc-mmtk.c:
          gc_num.interval = default_collect_interval;  [gc-mmtk.c:71]
          jl_atomic_load_relaxed(&ptls->gc_tls_common.gc_num.allocd) + gc_num.interval  [gc-mmtk.c:233, 254, 357]

        The Julia/C struct synchronization was previously inconsistent:
        - C: interval (correct name)
        - Julia: collect (wrong name, now fixed)
      downstream_surfaces:
        - "GC implementation code"
      likelihood: "high"
      impact: "low"

    - effect: "Documentation clarifies which fields are GC-internal vs user-observable"
      mechanism: |
        The added comments distinguish three categories of GC metrics:

        1. GC-Internal fields (reset after each GC cycle, always zero during user code):
           - allocd: "will always be zero if observed during execution of Julia user code"
           - deferred_alloc: "will always be zero in case of no use of gc_disable/gc_enable"
           - freed: "will always be zero when observed during execution of Julia user code"
           - total_allocd: "(GC internal) Total number of bytes allocated since program started"
           - interval: "(GC internal) Per-thread allocation quota... no longer used by stock GC"

        2. Cumulative counters (never reset):
           - malloc, realloc, poolalloc, bigalloc, freecall: allocation call counts
           - total_time, total_sweep_time, total_mark_time, etc.: timing totals
           - full_sweep: "Number of full GC sweeps completed so far"
           - max_pause, max_memory, max_time_to_safepoint: peak values

        3. Per-cycle metrics (last GC cycle values):
           - pause: "Duration of the last GC pause in nanoseconds"
           - sweep_time, mark_time, stack_pool_sweep_time: last cycle timings
           - time_to_safepoint: "Time taken to reach a safepoint in the last GC cycle"

        This clarification helps users understand which metrics are meaningful to observe.
      downstream_surfaces:
        - "GC monitoring code"
        - "Performance analysis tools"
      likelihood: "high"
      impact: "low"

    - effect: "Documentation notes pool allocator threshold of 2032 bytes"
      mechanism: |
        The poolalloc field documentation reveals an implementation detail:

        # Number of pool allocation calls (never reset by the runtime)
        # NOTE: Julia's stock GC uses an internal (pool) allocator for objects up to 2032 bytes.
        # Larger objects are allocated through `malloc/calloc`.
        poolalloc::Int64

        And for bigalloc:
        # Number of allocations for "big objects" (non-array objects larger than 2032 bytes)
        # (never reset by the runtime)
        bigalloc::Int64

        This 2032-byte threshold is useful for understanding allocation patterns:
        - Objects <= 2032 bytes: poolalloc counter, uses internal pool allocator
        - Objects > 2032 bytes: bigalloc counter, uses malloc/calloc

        Note: Arrays are handled separately regardless of size.
      downstream_surfaces:
        - "Memory allocation optimization"
        - "Performance tuning guides"
      likelihood: "medium"
      impact: "low"

  compatibility:
    internal_api:
      - field: "GC_Num.collect -> GC_Num.interval"
        change: "Field renamed for C struct consistency"
        affected_tools:
          - tool: "Any Julia code using gc_num().collect"
            usage: "Must update to use gc_num().interval"
    behavioral:
      - field: "GC metrics semantics"
        change: "No behavioral change - only documentation and field rename"
        affected_tools: []

  performance:
    compile_time:
      - impact: "ESTIMATED: None"
        details: |
          This is a documentation-only change with one field rename.
          No additional code is executed at compile time.
    runtime:
      - impact: "ESTIMATED: None"
        details: |
          The underlying GC metrics collection is unchanged.
          Only the Julia wrapper struct field name changed.

  risk:
    level: "low"
    rationale:
      - "The only semantic change is a field rename from 'collect' to 'interval'"
      - "The field being renamed (interval) is documented as 'no longer used by stock GC heuristics'"
      - "This aligns Julia/C struct naming which reduces maintenance confusion"
      - "The documentation additions are purely informational"
      - "Low likelihood of user code accessing this specific deprecated field"

  open_questions:
    - question: "What code might access gc_num().collect?"
      resolved: true
      answer: |
        RESOLVED: The interval/collect field is documented as "no longer used by the
        heuristics in the stock GC". It primarily serves internal GC bookkeeping.

        Searching the Julia codebase, the field is only accessed in C code:
        - gc-stock.c: Uses gc_num.interval for allocation accounting
        - gc-mmtk.c: Uses gc_num.interval for allocation accounting

        No Julia code in the standard library accesses this field by name.
        External packages that directly access gc_num() struct fields would be affected.

    - question: "Why was the Julia field named 'collect' when C used 'interval'?"
      resolved: false
      answer: |
        UNRESOLVED: The historical reason for the naming inconsistency is unclear.
        The C struct has used 'interval' for this field, while Julia used 'collect'.
        This PR corrects the inconsistency to reduce future maintenance burden.

  recommendations:
    - "For users accessing gc_num() directly: update any references from .collect to .interval"
    - "For package authors: this field is deprecated - avoid relying on its value"
    - "For GC contributors: the added documentation provides helpful context for future work"
    - "For the Julia project: consider deprecation warnings before breaking API changes"

changelog_entry:
  category: "GC"
  breaking: true
  summary: |
    Added comprehensive documentation to all fields of the GC_Num struct (used by gc_num())
    and renamed the `collect` field to `interval` to match the corresponding C struct field name.
  downstream_impact: |
    Code that accesses `gc_num().collect` will need to be updated to use `gc_num().interval`.
    This field is documented as "no longer used by the heuristics in the stock GC", so impact
    is expected to be minimal. The documentation additions help users understand which GC
    metrics are meaningful to observe during program execution vs internal GC bookkeeping.

downstream_package_impact:
  Turing_jl: "none - does not access raw GC metrics"
  Enzyme_jl: "none - does not access raw GC metrics"
  GPUCompiler: "none - does not access raw GC metrics"
  JET: "none - does not access raw GC metrics"

# ============================================================================
# INDEPENDENT REVIEW ENHANCEMENTS
# Reviewer: Second-pass analysis
# Date: 2026-01-21
# ============================================================================

independent_review:
  reviewer: "second_pass_analysis"
  review_date: "2026-01-21"

  additional_findings:
    - finding: "GC_Diff struct does NOT include the renamed field - limits breaking change impact"
      evidence:
        source: "code"
        path: "base/timing.jl"
        loc: "80-90"
        url: "https://github.com/JuliaLang/julia/blob/6a55e524b87988210135a29f832d614a9366afe0/base/timing.jl#L80-L90"
        snippet: |
          struct GC_Diff
              allocd      ::Int64 # Bytes allocated
              malloc      ::Int64 # Number of GC aware malloc()
              realloc     ::Int64 # Number of GC aware realloc()
              poolalloc   ::Int64 # Number of pool allocation
              bigalloc    ::Int64 # Number of big (non-pool) allocation
              freecall    ::Int64 # Number of GC aware free()
              total_time  ::Int64 # Time spent in garbage collection
              pause       ::Int64 # Number of GC pauses
              full_sweep  ::Int64 # Number of GC full collection
          end
      impact: |
        The collect/interval field was NEVER included in GC_Diff. This means:
        - @time macro: NOT affected (uses GC_Diff)
        - @timed macro: NOT affected (uses GC_Diff)
        - @timev macro: NOT affected (uses GC_Diff)
        - @allocated macro: NOT affected (uses gc_bytes)
        - @allocations macro: NOT affected (uses GC_Diff via gc_alloc_count)

        Only code that directly accesses gc_num().collect would be affected.
        This significantly limits the breaking change impact.

    - finding: "Clarification on 'no longer used by heuristics' - field IS still actively used"
      evidence:
        source: "code"
        path: "src/gc-stock.c"
        loc: "3411-3412"
        url: "https://github.com/JuliaLang/julia/blob/6a55e524b87988210135a29f832d614a9366afe0/src/gc-stock.c#L3411-L3412"
        snippet: |
          size_t localbytes = jl_atomic_load_relaxed(&ptls->gc_tls_common.gc_num.allocd) + gc_num.interval;
          jl_atomic_store_relaxed(&ptls->gc_tls_common.gc_num.allocd, -(int64_t)gc_num.interval);
      impact: |
        Despite the documentation stating "no longer used by the heuristics", the interval
        field IS still actively used in the GC implementation for:

        1. Thread allocation accounting baseline - allocd is stored as a negative offset
           from interval, so (allocd + interval) gives the true allocation count
        2. Reset operations after GC - allocd is reset to -(int64_t)interval
        3. Debug logging in gc_time_summary() - prints "new interval" value

        The "no longer used by heuristics" note means:
        - The value is NO LONGER dynamically adjusted based on GC heuristics
        - It stays fixed at default_collect_interval for the entire runtime
        - Previously, older GC versions may have adjusted this value dynamically

        The documentation could be more precise: "This field has a fixed value and is
        no longer dynamically adjusted by GC heuristics, though it is still used
        internally for allocation accounting."

    - finding: "Exact default_collect_interval values quantified"
      evidence:
        source: "code"
        path: "src/gc-stock.c"
        loc: "126-132"
        url: "https://github.com/JuliaLang/julia/blob/6a55e524b87988210135a29f832d614a9366afe0/src/gc-stock.c#L126-L132"
        snippet: |
          #ifdef _P64
          typedef uint64_t memsize_t;
          static const size_t default_collect_interval = 5600 * 1024 * sizeof(void*);
          #else
          typedef uint32_t memsize_t;
          static const size_t default_collect_interval = 3200 * 1024 * sizeof(void*);
      impact: |
        The interval field is initialized to these fixed values:

        64-bit systems: 5600 * 1024 * 8 = 45,875,200 bytes (~43.75 MB)
        32-bit systems: 3200 * 1024 * 4 = 13,107,200 bytes (~12.5 MB)

        This represents the per-thread allocation quota baseline used for
        internal GC accounting, though not for dynamic heuristics decisions.

    - finding: "gc_time_summary uses interval for debug logging"
      evidence:
        source: "code"
        path: "src/gc-debug.c"
        loc: "844-852"
        url: "https://github.com/JuliaLang/julia/blob/6a55e524b87988210135a29f832d614a9366afe0/src/gc-debug.c#L844-L852"
        snippet: |
          void gc_time_summary(int sweep_full, uint64_t start, uint64_t end,
                               uint64_t freed, uint64_t live, uint64_t interval,
                               uint64_t pause, uint64_t ttsp, uint64_t mark,
                               uint64_t sweep)
          {
              if (sweep_full > 0)
                  jl_safe_printf("TS: %" PRIu64 " Major collection: estimate freed = %" PRIu64
                                 " live = %" PRIu64 "m new interval = %" PRIu64
      impact: |
        When GC debugging is enabled, the interval value is printed in GC summary
        messages as "new interval". This is potentially confusing since the interval
        is actually fixed and never changes. The "new" in the message is historical.

    - finding: "Missing NEWS.md entry for breaking API change"
      evidence:
        source: "search"
        path: "NEWS.md"
        result: "No entries found for GC_Num, gc_num(), or this field rename"
      impact: |
        This breaking API change (GC_Num.collect -> GC_Num.interval) is not
        documented in NEWS.md. Best practice would be to add an entry under
        "Language changes" or a "Deprecations" section noting:

        - GC_Num struct: the `collect` field has been renamed to `interval`
          to match the C struct. Code accessing gc_num().collect should use
          gc_num().interval instead.

    - finding: "Before/after comparison verified via git"
      evidence:
        source: "git"
        before: |
          struct GC_Num
              allocd          ::Int64 # GC internal
              deferred_alloc  ::Int64 # GC internal
              freed           ::Int64 # GC internal
              malloc          ::Int64
              ...
              total_allocd    ::Int64 # GC internal
              collect         ::Csize_t # GC internal   # <-- OLD NAME
              pause           ::Cint
              ...
          end
        after: |
          struct GC_Num
              # (GC Internal) Number of allocated bytes since the last collection...
              allocd::Int64
              # (GC Internal) Number of allocated bytes within a gc_disable/gc_enable block...
              deferred_alloc::Int64
              ...
              # (GC internal) Total number of bytes allocated since the program started
              total_allocd::Int64
              # (GC internal) Per-thread allocation quota before triggering a GC
              # NOTE: This field is no longer used by the heuristics in the stock GC
              interval::Csize_t   # <-- NEW NAME
              # Duration of the last GC pause in nanoseconds
              pause::Cint
              ...
          end
      impact: |
        The git diff confirms the exact change:
        - Field renamed from 'collect' to 'interval' (11th field in struct)
        - All 28 fields now have detailed documentation comments
        - Comment style changed from inline (# comment) to block (preceding lines)

  verification_steps:
    - step: "Checked out PR merge commit 6a55e524b87988210135a29f832d614a9366afe0"
    - step: "Read full base/timing.jl and src/gc-interface.h source files"
    - step: "Verified GC_Diff struct does NOT include collect/interval field"
    - step: "Searched for all gc_num.interval usages with rg in src/ directory"
    - step: "Examined gc_time_summary function in gc-debug.c"
    - step: "Calculated exact default_collect_interval values for 64/32-bit"
    - step: "Compared parent commit timing.jl to see exact before/after"
    - step: "Searched NEWS.md for any mention of this change"

  corrections_to_original:
    - original: "The renamed field is documented as deprecated/unused by stock GC"
      correction: |
        More precise: The field IS still used for internal allocation accounting,
        but its VALUE is no longer dynamically adjusted by GC heuristics. It stays
        fixed at default_collect_interval (~44MB on 64-bit, ~12.5MB on 32-bit).

  additional_recommendations:
    - "Add NEWS.md entry documenting the GC_Num.collect -> GC_Num.interval rename"
    - "Consider adding a deprecation alias: getproperty(x::GC_Num, :collect) that warns and returns x.interval"
    - "Update gc_time_summary debug message from 'new interval' to 'interval' since it never changes"

  confidence_assessment:
    original_analysis_accuracy: "high - correctly identified the change and its nature"
    additional_value_added: |
      This independent review adds:
      1. Quantified impact reduction via GC_Diff analysis
      2. Clarification on actual interval field usage
      3. Exact numerical values for default_collect_interval
      4. Identification of missing NEWS.md entry
      5. Git-verified before/after comparison
    overall_confidence: "very high"

code_path_trace:
  gc_num_function:
    description: "How gc_num() returns the GC metrics struct"
    steps:
      - location: "base/timing.jl:77"
        url: "https://github.com/JuliaLang/julia/blob/6a55e524b87988210135a29f832d614a9366afe0/base/timing.jl#L77"
        code: |
          gc_num() = ccall(:jl_gc_num, GC_Num, ())
        explanation: |
          The gc_num() function calls the C function jl_gc_num which returns the
          current GC statistics. The return value is converted to the Julia GC_Num struct.
          The struct layout must match exactly between Julia and C for this to work correctly.

  interval_field_usage_stock_gc:
    description: "How the interval field is used in stock GC"
    steps:
      - location: "src/gc-stock.c:3701"
        function: "jl_gc_init"
        code: |
          gc_num.interval = default_collect_interval;
        explanation: "Initializes interval to default allocation quota"

      - location: "src/gc-stock.c:576"
        function: "combine_thread_gc_counts"
        code: |
          dest->allocd += (jl_atomic_load_relaxed(&ptls->gc_tls_common.gc_num.allocd) + gc_num.interval);
        explanation: "Uses interval when combining thread allocation counts"

      - location: "src/gc-stock.c:603"
        function: "reset_thread_gc_counts"
        code: |
          jl_atomic_store_relaxed(&ptls->gc_tls_common.gc_num.allocd, -(int64_t)gc_num.interval);
        explanation: "Resets thread allocation counter relative to interval"

  gc_num_struct_layout:
    description: "Julia/C struct field correspondence"
    steps:
      - location: "base/timing.jl:4-75 and src/gc-interface.h:28-99"
        code: |
          # Julia struct fields (28 total):
          allocd::Int64           <-> int64_t allocd
          deferred_alloc::Int64   <-> int64_t deferred_alloc
          freed::Int64            <-> int64_t freed
          malloc::Int64           <-> uint64_t malloc
          realloc::Int64          <-> uint64_t realloc
          poolalloc::Int64        <-> uint64_t poolalloc
          bigalloc::Int64         <-> uint64_t bigalloc
          freecall::Int64         <-> uint64_t freecall
          total_time::Int64       <-> uint64_t total_time
          total_allocd::Int64     <-> uint64_t total_allocd
          interval::Csize_t       <-> size_t interval    # RENAMED from 'collect'
          pause::Cint             <-> int pause
          full_sweep::Cint        <-> int full_sweep
          max_pause::Int64        <-> uint64_t max_pause
          max_memory::Int64       <-> uint64_t max_memory
          time_to_safepoint::Int64       <-> uint64_t time_to_safepoint
          max_time_to_safepoint::Int64   <-> uint64_t max_time_to_safepoint
          total_time_to_safepoint::Int64 <-> uint64_t total_time_to_safepoint
          sweep_time::Int64              <-> uint64_t sweep_time
          mark_time::Int64               <-> uint64_t mark_time
          stack_pool_sweep_time::Int64   <-> uint64_t stack_pool_sweep_time
          total_sweep_time::Int64        <-> uint64_t total_sweep_time
          total_sweep_page_walk_time::Int64           <-> uint64_t total_sweep_page_walk_time
          total_sweep_madvise_time::Int64             <-> uint64_t total_sweep_madvise_time
          total_sweep_free_mallocd_memory_time::Int64 <-> uint64_t total_sweep_free_mallocd_memory_time
          total_mark_time::Int64         <-> uint64_t total_mark_time
          total_stack_pool_sweep_time::Int64 <-> uint64_t total_stack_pool_sweep_time
          last_full_sweep::Int64         <-> uint64_t last_full_sweep
          last_incremental_sweep::Int64  <-> uint64_t last_incremental_sweep
        explanation: |
          The Julia GC_Num struct and C jl_gc_num_t must have identical field order and
          compatible types for the ccall(:jl_gc_num, GC_Num, ()) to work correctly.
          The PR ensures both structs have matching documentation and field names.

test_coverage:
  new_tests: []
  existing_tests:
    - file: "test/misc.jl"
      description: "GC tests use gc_num() but don't test specific field names"
      note: "No tests were added for the field rename"

reviewer_notes:
  initial_reviewer: "automated_analysis"
  initial_date: "2026-01-21"
  verification_method: |
    1. Read PR metadata from pr-archive/JuliaLang_julia/pr_60115.json
    2. Examined full source files base/timing.jl and src/gc-interface.h
    3. Searched for all usages of gc_num.interval in C code (gc-stock.c, gc-mmtk.c)
    4. Verified Julia/C struct field correspondence
    5. Analyzed the field rename impact (collect -> interval)
    6. Reviewed documentation additions for accuracy
  findings:
    - "Primary change is documentation - adds comments to all 28 struct fields"
    - "Breaking API change: GC_Num.collect renamed to GC_Num.interval"
    - "The renamed field is documented as deprecated/unused by stock GC"
    - "No tests were added for the field rename"
    - "C code already used 'interval' name, only Julia was inconsistent"
  confidence: "high"
  rationale: |
    This is a straightforward documentation PR with one field rename. The changes
    are easy to verify by comparing the before/after struct definitions. The field
    being renamed (interval/collect) is explicitly documented as "no longer used
    by the heuristics in the stock GC", making the breaking change low-risk.

    The documentation additions are valuable for understanding GC internals:
    - Clarifies which fields are GC-internal vs observable during user code
    - Documents time units (nanoseconds throughout)
    - Notes the 2032-byte pool allocator threshold
    - Explains field reset behavior after GC cycles
