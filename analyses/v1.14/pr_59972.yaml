schema_version: "1.0"
pr:
  number: 59972
  title: "Get rid of all PointerType::get call with element type"
  url: "https://github.com/JuliaLang/julia/pull/59972"
  author: "yuyichao"
  labels: []
  merged_at: "2025-10-28T17:46:20Z"
  merge_commit_sha: "32e1f4873e488e157daccf0c9a58ef04b8374b8d"
  diff_url: "https://github.com/JuliaLang/julia/pull/59972.diff"
scope:
  files_touched:
    - "src/ccall.cpp"
    - "src/cgutils.cpp"
    - "src/codegen.cpp"
    - "src/llvm-final-gc-lowering.cpp"
    - "src/llvm-propagate-addrspaces.cpp"
    - "src/llvmcalltest.cpp"
  components:
    - "Compiler.Codegen"
  pipeline_stages:
    - "Codegen"
analysis:
  intent:
    summary: "Migrate all LLVM PointerType::get calls from the deprecated typed-pointer API (PointerType::get(Type*, AddressSpace)) to the opaque-pointer API (PointerType::get(LLVMContext&, AddressSpace)) for LLVM 21 compatibility."
    quoted_from_pr: "This is now deprecated on LLVM 21."
    issue_links: []
    context: |
      Julia currently uses LLVM 20.1.8 (as of this PR merge). This PR prepares for
      LLVM 21 which fully deprecates the typed-pointer PointerType::get(Type*, AS) API.
      The JuliaType helpers in llvm-codegen-shared.h were already using the opaque
      pointer API, so this PR extends that pattern to all remaining callsites.
  direct_changes:
    - summary: "Replace PointerType::get(Type*, AddressSpace) calls with PointerType::get(LLVMContext&, AddressSpace) in ccall.cpp"
      component: "src/ccall.cpp"
      evidence:
        - source: "diff"
          path: "src/ccall.cpp"
          loc: "1317"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/ccall.cpp#L1317"
          snippet: |
            fargt_sig.push_back(PointerType::get(LLVMCtx, 0));
        - source: "diff"
          path: "src/ccall.cpp"
          loc: "1375"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/ccall.cpp#L1375"
          snippet: |
            pat = PointerType::get(LLVMCtx, AddressSpace::Derived);
    - summary: "Replace typed-pointer API calls with opaque-pointer API in cgutils.cpp address space casting helpers"
      component: "src/cgutils.cpp"
      evidence:
        - source: "diff"
          path: "src/cgutils.cpp"
          loc: "76-82"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/cgutils.cpp#L76-L82"
          snippet: |
            static Value *decay_derived(jl_codectx_t &ctx, Value *V)
            {
                Type *T = V->getType();
                if (T->getPointerAddressSpace() == AddressSpace::Derived)
                    return V;
                Type *NewT = PointerType::get(T->getContext(), AddressSpace::Derived);
                return ctx.builder.CreateAddrSpaceCast(V, NewT);
            }
        - source: "diff"
          path: "src/cgutils.cpp"
          loc: "86-93"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/cgutils.cpp#L86-L93"
          snippet: |
            static Value *maybe_decay_tracked(jl_codectx_t &ctx, Value *V)
            {
                Type *T = V->getType();
                if (T->getPointerAddressSpace() != AddressSpace::Tracked)
                    return V;
                Type *NewT = PointerType::get(T->getContext(), AddressSpace::Derived);
                return ctx.builder.CreateAddrSpaceCast(V, NewT);
            }
        - source: "diff"
          path: "src/cgutils.cpp"
          loc: "95-100"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/cgutils.cpp#L95-L100"
          snippet: |
            static Value *mark_callee_rooted(jl_codectx_t &ctx, Value *V)
            {
                assert(V->getType() == ctx.types().T_pjlvalue || V->getType() == ctx.types().T_prjlvalue);
                return ctx.builder.CreateAddrSpaceCast(V,
                    PointerType::get(V->getContext(), AddressSpace::CalleeRooted));
            }
    - summary: "Update jl_typecache_t initialization to use opaque pointer API for all Julia type pointers"
      component: "src/codegen.cpp"
      evidence:
        - source: "diff"
          path: "src/codegen.cpp"
          loc: "300-324"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/codegen.cpp#L300-L324"
          snippet: |
            T_ptr = getPointerTy(context);
            T_sigatomic = Type::getIntNTy(context, sizeof(sig_atomic_t) * 8);
            T_size = DL.getIntPtrType(context);
            sizeof_ptr = DL.getPointerSize();
            alignof_ptr = DL.getPointerABIAlignment(0);
            T_jlvalue = JuliaType::get_jlvalue_ty(context);
            T_pjlvalue = getPointerTy(context);
            T_prjlvalue = PointerType::get(context, AddressSpace::Tracked);
            T_ppjlvalue = getPointerTy(context);
            T_pprjlvalue = getPointerTy(context);

            T_jlfunc = JuliaType::get_jlfunc_ty(context);
            assert(T_jlfunc != NULL);
            T_jlfuncparams = JuliaType::get_jlfuncparams_ty(context);
            assert(T_jlfuncparams != NULL);

            T_jlgenericmemory = StructType::get(context, { T_size, T_pprjlvalue });
            Type *vaelts[] = { PointerType::get(context, AddressSpace::Loaded),
                               PointerType::get(context, AddressSpace::Tracked),
            };
            T_jlarray = StructType::get(context, ArrayRef<Type*>(vaelts));
            T_pjlarray = getPointerTy(context);
    - summary: "Update JuliaFunction declarations to use opaque pointer types for function signatures"
      component: "src/codegen.cpp"
      evidence:
        - source: "diff"
          path: "src/codegen.cpp"
          loc: "760"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/codegen.cpp#L760"
          snippet: |
            static const auto jlpgcstack_func = new JuliaFunction<>{
                "julia.get_pgcstack",
                [](LLVMContext &C) { return FunctionType::get(getPointerTy(C), false); },
                nullptr,
            };
        - source: "diff"
          path: "src/codegen.cpp"
          loc: "791-793"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/codegen.cpp#L791-L793"
          snippet: |
            static const auto jlthrow_func = new JuliaFunction<>{
                XSTR(jl_throw),
                [](LLVMContext &C) { return FunctionType::get(getVoidTy(C),
                        {PointerType::get(C, AddressSpace::CalleeRooted)}, false); },
    - summary: "Update GEP pointer type mutation to use opaque pointers in cgutils.cpp"
      component: "src/cgutils.cpp"
      evidence:
        - source: "diff"
          path: "src/cgutils.cpp"
          loc: "3831-3840"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/cgutils.cpp#L3831-L3840"
          snippet: |
            for (auto *User : Val->users()) {
                if (isa<GetElementPtrInst>(User)) {
                    GetElementPtrInst *Inst = cast<GetElementPtrInst>(User);
                    Inst->mutateType(PointerType::get(Inst->getContext(), ToAS));
                    recursively_adjust_ptr_type(Inst, FromAS, ToAS);
                }
    - summary: "Update llvm-final-gc-lowering.cpp to use opaque pointer for GC frame pointer cast"
      component: "src/llvm-final-gc-lowering.cpp"
      evidence:
        - source: "diff"
          path: "src/llvm-final-gc-lowering.cpp"
          loc: "54"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/llvm-final-gc-lowering.cpp#L54"
          snippet: |
            builder.CreatePointerCast(
                    builder.CreateConstInBoundsGEP1_32(T_prjlvalue, gcframe, 1, "frame.prev"),
                    PointerType::get(T_ppjlvalue->getContext(), 0)),
    - summary: "Update llvm-propagate-addrspaces.cpp to use opaque pointers for address space lifting"
      component: "src/llvm-propagate-addrspaces.cpp"
      evidence:
        - source: "diff"
          path: "src/llvm-propagate-addrspaces.cpp"
          loc: "163-173"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/llvm-propagate-addrspaces.cpp#L163-L173"
          snippet: |
            if (isa<GetElementPtrInst>(V) || isa<PHINode>(V) || isa<SelectInst>(V)) {
                Instruction *InstV = cast<Instruction>(V);
                Instruction *NewV = InstV->clone();
                ToInsert.push_back(std::make_pair(NewV, InstV));
                Type *NewRetTy = PointerType::get(InstV->getContext(), allocaAddressSpace);
                NewV->mutateType(NewRetTy);
                LiftingMap[InstV] = NewV;
                ToRevisit.push_back(NewV);
            }
    - summary: "Update llvmcalltest.cpp to use opaque pointer API for TrackedTy"
      component: "src/llvmcalltest.cpp"
      evidence:
        - source: "diff"
          path: "src/llvmcalltest.cpp"
          loc: "29"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/llvmcalltest.cpp#L29"
          snippet: |
            Type *TrackedTy = PointerType::get(Ctx, AddressSpace::Tracked);
  secondary_effects:
    - effect: "No semantic change to generated LLVM IR; opaque pointers are representation-equivalent with typed pointers in all LLVM versions supporting opaque pointers"
      mechanism: |
        LLVM's opaque pointer transition (since LLVM 13) means:
          - PointerType::get(LLVMContext&, AS) creates ptr addrspace(AS)
          - PointerType::get(Type*, AS) was deprecated (returns same opaque ptr)
          - Julia already uses opaque pointers via getPointerTy() helper [codegen.cpp:132-134]

        getPointerTy(LLVMContext &ctxt)  [codegen.cpp:132]
          return PointerType::get(ctxt, 0);

        All address spaces preserved:
          AddressSpace::Generic = 0      [llvm-codegen-shared.h:19]
          AddressSpace::Tracked = 10     [llvm-codegen-shared.h:20]
          AddressSpace::Derived = 11     [llvm-codegen-shared.h:21]
          AddressSpace::CalleeRooted = 12 [llvm-codegen-shared.h:22]
          AddressSpace::Loaded = 13      [llvm-codegen-shared.h:23]
      downstream_surfaces:
        - "LLVM IR generation (internal)"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "132-134"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/codegen.cpp#L132-L134"
          snippet: |
            auto getPointerTy(LLVMContext &ctxt) {
                return PointerType::get(ctxt, 0);
            }
        - source: "code"
          path: "src/llvm-codegen-shared.h"
          loc: "18-26"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/llvm-codegen-shared.h#L18-L26"
          snippet: |
            enum AddressSpace {
                Generic = 0,
                Tracked = 10,
                Derived = 11,
                CalleeRooted = 12,
                Loaded = 13,
                FirstSpecial = Tracked,
                LastSpecial = Loaded,
            };
    - effect: "Enables Julia to compile with LLVM 21 without deprecation warnings"
      mechanism: |
        LLVM 21 deprecates PointerType::get(Type*, unsigned) API.
        This PR removes all such calls, replacing them with the new
        context-based API that creates opaque pointers directly.

        The change is purely mechanical - replacing:
          PointerType::get(SomeType, AddressSpace)
        with:
          PointerType::get(Context, AddressSpace)

        No type information is lost because LLVM's opaque pointers
        don't carry element type information anyway.
      downstream_surfaces:
        - "Julia build system compatibility with LLVM 21+"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "diff"
          path: "src/cgutils.cpp"
          loc: "62"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/cgutils.cpp#L62"
          snippet: |
            // Once llvm deletes pointer element types, we won't need it here any more either.
    - effect: "Consistent use of opaque pointer API across all LLVM codegen files"
      mechanism: |
        This PR extends the pattern already established by getPointerTy() and
        JuliaType helpers. After this PR, the codebase uses three opaque pointer APIs:

        1. PointerType::get(LLVMContext&, AddressSpace) - for non-zero address spaces
           Used throughout codegen for Tracked, Derived, CalleeRooted, Loaded

        2. PointerType::getUnqual(LLVMContext&) - for default address space (0)
           Still used in ~20 callsites for generic/unqualified pointers

        3. getPointerTy(LLVMContext&) - Julia's convenience wrapper
           Wrapper for PointerType::get(ctx, 0), used extensively

        All three APIs are fully opaque-pointer compatible.
      downstream_surfaces:
        - "LLVM codegen internal consistency"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "132-134"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/codegen.cpp#L132-L134"
          snippet: |
            auto getPointerTy(LLVMContext &ctxt) {
                return PointerType::get(ctxt, 0);
            }
        - source: "code"
          path: "src/llvm-codegen-shared.h"
          loc: "33-47"
          url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/llvm-codegen-shared.h#L33-L47"
          snippet: |
            static inline llvm::PointerType* get_pjlvalue_ty(llvm::LLVMContext &C, unsigned addressSpace=0) {
                return llvm::PointerType::get(C, addressSpace);
            }

            static inline llvm::PointerType* get_prjlvalue_ty(llvm::LLVMContext &C) {
                return llvm::PointerType::get(C, AddressSpace::Tracked);
            }

            static inline llvm::PointerType* get_ppjlvalue_ty(llvm::LLVMContext &C) {
                return llvm::PointerType::get(C, 0);
            }
  compatibility:
    internal_api:
      - summary: "No internal API changes; all pointer types remain semantically equivalent"
        evidence:
          - source: "code"
            path: "src/llvm-codegen-shared.h"
            loc: "33-47"
            url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/llvm-codegen-shared.h#L33-L47"
            snippet: |
              static inline llvm::PointerType* get_pjlvalue_ty(llvm::LLVMContext &C, unsigned addressSpace=0) {
                  return llvm::PointerType::get(C, addressSpace);
              }

              static inline llvm::PointerType* get_prjlvalue_ty(llvm::LLVMContext &C) {
                  return llvm::PointerType::get(C, AddressSpace::Tracked);
              }

              static inline llvm::PointerType* get_ppjlvalue_ty(llvm::LLVMContext &C) {
                  return llvm::PointerType::get(C, 0);
              }

              static inline llvm::PointerType* get_pprjlvalue_ty(llvm::LLVMContext &C) {
                  return llvm::PointerType::get(C, 0);
              }
    behavioral:
      - summary: "No behavioral changes; generated IR is semantically equivalent"
        evidence:
          - source: "code"
            path: "src/cgutils.cpp"
            loc: "119"
            url: "https://github.com/JuliaLang/julia/blob/32e1f4873e488e157daccf0c9a58ef04b8374b8d/src/cgutils.cpp#L5119"
            snippet: |
              while (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(data)) { // ignoring bitcast will not be required with opaque pointers
  performance:
    compile_time:
      - summary: "ESTIMATED: No measurable impact; this is a pure API migration with equivalent runtime behavior"
        evidence:
          - source: "discussion"
            path: "PR body"
            snippet: |
              This is now deprecated on LLVM 21.
    runtime:
      - summary: "No runtime impact; generated machine code is identical"
        evidence:
          - source: "code"
            path: "src/codegen.cpp"
            loc: "132-134"
            snippet: |
              auto getPointerTy(LLVMContext &ctxt) {
                  return PointerType::get(ctxt, 0);
              }
  tests:
    changed_files: []
    new_behavior_assertions: []
    coverage_gaps:
      - "No new tests added; this is an internal API migration that preserves semantics"
  risk:
    level: "low"
    rationale:
      - "Pure API migration with no semantic changes to generated LLVM IR"
      - "All Julia-specific address spaces (Tracked, Derived, CalleeRooted, Loaded) are preserved"
      - "LLVM opaque pointers have been stable since LLVM 15; this just removes deprecated API usage"
      - "Changes are entirely within C++ codegen layer; no Julia-level changes"
      - "Author (yuyichao) is an experienced Julia core contributor"
      - "VERIFIED: Independent code search confirms no remaining typed-pointer API calls after this PR"
      - "The change is mechanical and deterministic - each replacement is one-to-one with no logic changes"
  open_questions:
    - "RESOLVED: LLVM 21 deprecates the typed-pointer API with warnings; full removal expected in a later LLVM version. This PR preemptively cleans up all usages."
    - "The comment in cgutils.cpp:62 ('Once llvm deletes pointer element types') is now historical - LLVM has already transitioned to opaque pointers. Consider removing this comment in a future cleanup PR."
  recommendations:
    - "No action required for downstream packages; this is transparent to Julia users and package authors"
    - "Downstream tools using LLVM C++ API directly (e.g., Enzyme, GPUCompiler at the native level) should ensure they also migrate away from typed pointer APIs if targeting LLVM 21+"
    - "JET, IRTools, and Cassette are unaffected as they operate at the Julia IR level, not LLVM IR level"
  reviewer_notes:
    independent_verification: |
      Verified by checking out merge commit 32e1f4873e488e157daccf0c9a58ef04b8374b8d
      and searching for remaining typed-pointer API calls.

      Search results confirmed:
      - All PointerType::get calls now use (LLVMContext&, AS) signature
      - ~50+ callsites use the new API consistently across 15+ source files
      - PointerType::getUnqual() calls remain (~20 sites) - this is also opaque-pointer compatible
      - getPointerTy() wrapper function was already using opaque pointer API

      The PR is complete and does not leave any deprecated API usage.
    additional_context: |
      Julia's LLVM version at time of merge: 20.1.8
      Target compatibility: LLVM 21+

      The JuliaType:: helpers in llvm-codegen-shared.h were NOT modified by this PR
      because they were already using the opaque pointer API before this change.
      This PR brought the remaining direct callsites into alignment with
      the established pattern.
