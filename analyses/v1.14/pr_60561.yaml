schema_version: "1.0"
pr:
  number: 60561
  title: "[JuliaLowering] Minor code quality improvements"
  url: "https://github.com/JuliaLang/julia/pull/60561"
  author: "aviatesk"
  labels:
    - "compiler:lowering"
    - "JuliaLowering"
  merged_at: "2026-01-06T19:14:06Z"
  merge_commit_sha: "4f713be0b388a1f2bce33f4e96b77635a7393135"
  diff_url: "https://github.com/JuliaLang/julia/pull/60561.diff"
scope:
  files_touched:
    - "JuliaLowering/src/desugaring.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Lowering"
analysis:
  intent:
    summary: "Improves isdefined-ness of local variables for JET-based analyses and removes unused variables. Four small refactors: (1) initialize iterstate to nothing for empty destructuring, (2) remove unused enumerate index in named tuple expansion, (3) add @isdefined guards for type_params/supertype in analyze_type_sig, (4) normalize nbits assignment in abstract/primitive type lowering."
    issue_links: []
  direct_changes:
    - summary: "Initialize iterstate to nothing when destructuring has zero LHS children, avoiding undefined local in empty destructuring case."
      component: "JuliaLowering/desugaring"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "280-282"
          url: "https://github.com/JuliaLang/julia/blob/4f713be0b388a1f2bce33f4e96b77635a7393135/JuliaLowering/src/desugaring.jl#L280-L282"
          snippet: |
            function _destructure(ctx, assignment_srcref, stmts, lhs, rhs, is_const)
                n_lhs = numchildren(lhs)
                iterstate = n_lhs > 0 ? new_local_binding(ctx, rhs, "iterstate") : nothing
        - source: "diff"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "279-282"
          url: "https://github.com/JuliaLang/julia/pull/60561/files#diff-ec952b0097a182bb41d8955ffe27fcadfd3922a1"
          snippet: |
            # BEFORE:
            function _destructure(ctx, assignment_srcref, stmts, lhs, rhs, is_const)
                n_lhs = numchildren(lhs)
                if n_lhs > 0
                    iterstate = new_local_binding(ctx, rhs, "iterstate")
                end
            # AFTER:
            function _destructure(ctx, assignment_srcref, stmts, lhs, rhs, is_const)
                n_lhs = numchildren(lhs)
                iterstate = n_lhs > 0 ? new_local_binding(ctx, rhs, "iterstate") : nothing
    - summary: "Remove unused enumerate index (i) in expand_named_tuple loop since the index was never used."
      component: "JuliaLowering/desugaring"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "1621"
          url: "https://github.com/JuliaLang/julia/blob/4f713be0b388a1f2bce33f4e96b77635a7393135/JuliaLowering/src/desugaring.jl#L1621"
          snippet: |
            for kw in kws
        - source: "diff"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "1620-1621"
          url: "https://github.com/JuliaLang/julia/pull/60561/files#diff-ec952b0097a182bb41d8955ffe27fcadfd3922a1"
          snippet: |
            # BEFORE:
            for (i,kw) in enumerate(kws)
            # AFTER:
            for kw in kws
    - summary: "Add @isdefined guards for type_params and supertype in analyze_type_sig to ensure all return values are defined before returning, improving JET analysis."
      component: "JuliaLowering/desugaring"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "3488-3492"
          url: "https://github.com/JuliaLang/julia/blob/4f713be0b388a1f2bce33f4e96b77635a7393135/JuliaLowering/src/desugaring.jl#L3488-L3492"
          snippet: |
            @isdefined(name) || throw(LoweringError(ex, "invalid type signature"))
            @isdefined(type_params) || throw(LoweringError(ex, "invalid type signature"))
            @isdefined(supertype) || throw(LoweringError(ex, "invalid type signature"))

            return (name, type_params, supertype)
        - source: "diff"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "3486-3492"
          url: "https://github.com/JuliaLang/julia/pull/60561/files#diff-ec952b0097a182bb41d8955ffe27fcadfd3922a1"
          snippet: |
            # BEFORE (only checked name):
            @isdefined(name) || throw(LoweringError(ex, "invalid type signature"))
            return (name, type_params, supertype)
            # AFTER (checks all three):
            @isdefined(name) || throw(LoweringError(ex, "invalid type signature"))
            @isdefined(type_params) || throw(LoweringError(ex, "invalid type signature"))
            @isdefined(supertype) || throw(LoweringError(ex, "invalid type signature"))
            return (name, type_params, supertype)
    - summary: "Move nbits assignment outside if/else block in expand_abstract_or_primitive_type, using ternary to set nbits=nothing for abstract types."
      component: "JuliaLowering/desugaring"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "3520-3529"
          url: "https://github.com/JuliaLang/julia/blob/4f713be0b388a1f2bce33f4e96b77635a7393135/JuliaLowering/src/desugaring.jl#L3520-L3529"
          snippet: |
            function expand_abstract_or_primitive_type(ctx, ex)
                is_abstract = kind(ex) == K"abstract"
                if is_abstract
                    @chk numchildren(ex) == 1
                else
                    @assert kind(ex) == K"primitive"
                    @chk numchildren(ex) == 2
                end
                nbits = is_abstract ? nothing : ex[2]
                name, type_params, supertype = analyze_type_sig(ctx, ex[1])
        - source: "diff"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "3524-3529"
          url: "https://github.com/JuliaLang/julia/pull/60561/files#diff-ec952b0097a182bb41d8955ffe27fcadfd3922a1"
          snippet: |
            # BEFORE (nbits only defined for primitive):
            else
                @assert kind(ex) == K"primitive"
                @chk numchildren(ex) == 2
                nbits = ex[2]
            end
            # AFTER (nbits always defined):
            else
                @assert kind(ex) == K"primitive"
                @chk numchildren(ex) == 2
            end
            nbits = is_abstract ? nothing : ex[2]
  secondary_effects:
    - effect: "JET and other static analysis tools can now track definedness of iterstate, type_params, supertype, and nbits locals without false positives."
      mechanism: |
        All four changes follow the same pattern: ensuring local variables are always
        assigned (even if to nothing) rather than conditionally defined.

        _destructure(ctx, ...)  [desugaring.jl:280]
          iterstate = n_lhs > 0 ? ... : nothing  # always defined

        expand_named_tuple(ctx, ...)  [desugaring.jl:1621]
          for kw in kws  # no unused (i, kw) binding

        analyze_type_sig(ctx, ex)  [desugaring.jl:3488-3490]
          @isdefined(type_params) check  # ensures defined before return
          @isdefined(supertype) check    # ensures defined before return

        expand_abstract_or_primitive_type(ctx, ex)  [desugaring.jl:3528]
          nbits = is_abstract ? nothing : ex[2]  # always defined
      downstream_surfaces:
        - "JET.jl isdefined analysis on JuliaLowering code"
        - "IDE tooling that relies on definedness tracking"
      likelihood: "high"
      impact: "low"
  compatibility:
    internal_api:
      - field: "JuliaLowering.analyze_type_sig return tuple (name, type_params, supertype)"
        change: "Now guaranteed to throw LoweringError if any of the three return values would be undefined. Previously only name was explicitly checked."
        affected_tools:
          - tool: "JET"
            usage: "JET.jl performs isdefined analysis on JuliaLowering code; these changes eliminate false positive warnings about potentially undefined locals."
    behavioral:
      - change: "No user-visible behavior change. All changes are internal code quality improvements that preserve existing semantics."
        impact: "None - error messages and behavior unchanged."
  performance:
    compile_time:
      - impact: "ESTIMATED: negligible. One additional @isdefined check per type signature lowering (constant-time). Ternary vs if-block is equivalent."
    runtime:
      - impact: "ESTIMATED: none. Changes are in lowering-time only; generated IR is identical."
  risk:
    level: "low"
    rationale:
      - "Changes are purely cosmetic refactors for static analysis friendliness."
      - "No semantic changes to generated IR or runtime behavior."
      - "All changes preserve existing error messages and control flow."
  open_questions: []
  recommendations:
    - "No downstream action required. This is a code quality improvement for JET-based static analysis of JuliaLowering itself."
  evidence_tests:
    - summary: "Existing IR tests verify destructuring produces iterstate slot when n_lhs > 0."
      source: "test"
      path: "JuliaLowering/test/destructuring_ir.jl"
      loc: "1-16"
      url: "https://github.com/JuliaLang/julia/blob/4f713be0b388a1f2bce33f4e96b77635a7393135/JuliaLowering/test/destructuring_ir.jl#L1-L16"
      snippet: |
        ########################################
        # Simple destructuring
        let
            (x,y) = as
        end
        #---------------------
        1   TestMod.as
        2   (call top.indexed_iterate %₁ 1)
        3   (= slot₂/x (call core.getfield %₂ 1))
        4   (= slot₁/iterstate (call core.getfield %₂ 2))
        5   TestMod.as
        6   slot₁/iterstate
        7   (call top.indexed_iterate %₅ 2 %₆)
        8   (= slot₃/y (call core.getfield %₇ 1))
        9   TestMod.as
        10  (return %₉)
    - summary: "Invalid type signatures trigger LoweringError with 'invalid type signature' message."
      source: "test"
      path: "JuliaLowering/test/typedefs_ir.jl"
      loc: "258-280"
      url: "https://github.com/JuliaLang/julia/blob/4f713be0b388a1f2bce33f4e96b77635a7393135/JuliaLowering/test/typedefs_ir.jl#L258-L280"
      snippet: |
        ########################################
        # Error: Abstract type definition with bad signature
        abstract type A() end
        #---------------------
        LoweringError:
        abstract type A() end
        #             └─┘ ── invalid type signature

        ########################################
        # Error: Abstract type definition with bad signature
        abstract type A(){T} end
        #---------------------
        LoweringError:
        abstract type A(){T} end
        #             └────┘ ── invalid type signature

        ########################################
        # Error: Abstract type definition with bad signature
        abstract type A() <: B end
        #---------------------
        LoweringError:
        abstract type A() <: B end
        #            └───────┘ ── invalid type signature
  caller_search:
    - summary: "Callers of _destructure - used by expand_assignment for tuple destructuring."
      source: "rg"
      command: "rg '_destructure\\(' JuliaLowering/"
      matches:
        - "JuliaLowering/src/desugaring.jl:280:function _destructure(ctx, assignment_srcref, stmts, lhs, rhs, is_const)"
        - "JuliaLowering/src/desugaring.jl:443:    _destructure(ctx, ex, stmts, lhs, rhs1, is_const)"
    - summary: "Callers of expand_named_tuple - used for keyword args and named tuple literals."
      source: "rg"
      command: "rg 'expand_named_tuple\\(' JuliaLowering/"
      matches:
        - "JuliaLowering/src/desugaring.jl:1614:function expand_named_tuple(ctx, ex, kws, eq_is_kw;"
        - "JuliaLowering/src/desugaring.jl:1698:        kw_container := expand_named_tuple(ctx, srcref, kws, false;"
        - "JuliaLowering/src/desugaring.jl:4534:            expand_forms_2(ctx, expand_named_tuple(ctx, ex, children(ex[1]), true))"
        - "JuliaLowering/src/desugaring.jl:4536:            expand_forms_2(ctx, expand_named_tuple(ctx, ex, children(ex), true))"
    - summary: "Callers of analyze_type_sig - used by struct, abstract, and primitive type lowering."
      source: "rg"
      command: "rg 'analyze_type_sig\\(' JuliaLowering/"
      matches:
        - "JuliaLowering/src/desugaring.jl:3466:function analyze_type_sig(ctx, ex)"
        - "JuliaLowering/src/desugaring.jl:3529:    name, type_params, supertype = analyze_type_sig(ctx, ex[1])"
        - "JuliaLowering/src/desugaring.jl:4011:    struct_name, type_params, supertype = analyze_type_sig(ctx, type_sig)"
