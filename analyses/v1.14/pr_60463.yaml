schema_version: "1.0"
reviewer_notes:
  independent_analysis_performed: true
  analysis_date: "2026-01-21"
  reviewer_findings: |
    Independent code review confirms the original analysis is accurate.
    Key enhancements made:

    1. CORRECTION: The conditional thread resume (tid != -1 check) was ALREADY
       present in the old code. The PR only reorganizes preprocessor directives
       for clarity - the behavioral change is the API switch, not the resume logic.

    2. ADDED: Detailed abort state machine protocol documentation showing
       how abort_profile_ptr states (0,1,2,3) coordinate between jl_unw_step()
       and profile_timeout_cb() for deadlock recovery.

    3. ADDED: Windows API comparison explaining why CreateTimerQueueTimer is
       more reliable than RegisterWaitForSingleObject for timeout-only callbacks.

    4. VERIFIED: Call chains traced through stackwalk.c confirm
       RtlLookupFunctionEntry is called at lines 418 and 431 during stackwalk,
       which can deadlock on Windows loader lock if suspended thread holds it.

    5. VERIFIED: No compiler pipeline impact - this is purely Windows profiler
       runtime C code with no effect on type inference, IR, or codegen.
pr:
  number: 60463
  title: "[Windows] Use `TimerQueue` API to register Profile watchdog"
  url: "https://github.com/JuliaLang/julia/pull/60463"
  author: "topolarity"
  labels:
    - "system:windows"
  merged_at: "2025-12-24T00:17:06Z"
  merge_commit_sha: "d53e65e56175d9b091db3a056a632110442de94c"
  diff_url: "https://github.com/JuliaLang/julia/pull/60463.diff"

scope:
  files_touched:
    - "src/signals-win.c"
  components:
    - "Runtime (Windows signal handling)"
    - "Profiler"
  pipeline_stages: []

analysis:
  intent:
    summary: |
      Replaces the Windows profiler watchdog timer implementation from using
      `RegisterWaitForSingleObject` with a dummy Event to using the `TimerQueue` API
      (`CreateTimerQueue`/`CreateTimerQueueTimer`).

      On x86-64 Windows, the profiler relies on this timeout callback to avoid
      (otherwise unavoidable) deadlocks between `RtlLookupFunctionEntry` and many
      other internal Windows runtime functions including `RtlAllocateHeap` and
      `LdrLoadDll`. The old `RegisterWaitForSingleObject` API was unreliable -
      in contended situations it would drop the callback on the floor entirely,
      causing the profiler to deadlock instead of timing out and recovering.

      The PR author notes this doesn't solve all deadlocks (referencing PR #60454
      and @xal-0's findings) but appears to be a "significant improvement" on
      real-world machines.
    issue_links:
      - "https://github.com/JuliaLang/julia/pull/60454"
      - "https://github.com/JuliaLang/julia/pull/60454#issuecomment-3687877148"

  direct_changes:
    - summary: "Replace dummy Event with TimerQueue at profile thread initialization"
      component: "Profiler (Windows)"
      evidence:
        - source: "code"
          path: "src/signals-win.c"
          loc: "484-491"
          url: "https://github.com/JuliaLang/julia/blob/d53e65e56175d9b091db3a056a632110442de94c/src/signals-win.c#L484-L491"
          snippet: |
            static DWORD WINAPI profile_bt( LPVOID lparam )
            {
                // Note: illegal to use jl_* functions from this thread except for profiling-specific functions
                HANDLE hTimerQueue = CreateTimerQueue();
                if (hTimerQueue == NULL) {
                    jl_safe_fprintf(ios_safe_stderr, "failed to create profile watchdog timer queue.\n");
                    abort();
                }

    - summary: "Replace RegisterWaitForSingleObject with CreateTimerQueueTimer"
      component: "Profiler (Windows)"
      evidence:
        - source: "code"
          path: "src/signals-win.c"
          loc: "533-539"
          url: "https://github.com/JuliaLang/julia/blob/d53e65e56175d9b091db3a056a632110442de94c/src/signals-win.c#L533-L539"
          snippet: |
            HANDLE hTimer = NULL;
            if (!CreateTimerQueueTimer(&hTimer, hTimerQueue, profile_timeout_cb,
                                       &timeout_data, 1000 /* milliseconds */, 0,
                                       WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD)) {
                // Failed to register wait, proceed without timeout protection
                hTimer = NULL;
            }

    - summary: "Replace UnregisterWaitEx with DeleteTimerQueueTimer for cleanup"
      component: "Profiler (Windows)"
      evidence:
        - source: "code"
          path: "src/signals-win.c"
          loc: "548-555"
          url: "https://github.com/JuliaLang/julia/blob/d53e65e56175d9b091db3a056a632110442de94c/src/signals-win.c#L548-L555"
          snippet: |
            // Wait for callback to complete or cancel before continuing
            if (hTimer != NULL)
                DeleteTimerQueueTimer(hTimerQueue, hTimer, INVALID_HANDLE_VALUE);
            if (timeout_data.tid != -1)
                jl_thread_resume(tid);
            #else
            jl_thread_resume(tid);
            #endif

    - summary: "Replace CloseHandle with DeleteTimerQueue at thread exit"
      component: "Profiler (Windows)"
      evidence:
        - source: "code"
          path: "src/signals-win.c"
          loc: "581"
          url: "https://github.com/JuliaLang/julia/blob/d53e65e56175d9b091db3a056a632110442de94c/src/signals-win.c#L581"
          snippet: |
            DeleteTimerQueue(hTimerQueue);

    - summary: "Timeout increased from 100ms to 1000ms"
      component: "Profiler (Windows)"
      evidence:
        - source: "diff"
          path: "src/signals-win.c"
          loc: "535"
          url: "https://github.com/JuliaLang/julia/blob/d53e65e56175d9b091db3a056a632110442de94c/src/signals-win.c#L535"
          snippet: |
            # Old (RegisterWaitForSingleObject):
            #   &timeout_data, 100, WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD
            # New (CreateTimerQueueTimer):
                                       &timeout_data, 1000 /* milliseconds */, 0,

    - summary: "Conditional thread resume based on timeout_data.tid"
      component: "Profiler (Windows)"
      evidence:
        - source: "code"
          path: "src/signals-win.c"
          loc: "551-555"
          url: "https://github.com/JuliaLang/julia/blob/d53e65e56175d9b091db3a056a632110442de94c/src/signals-win.c#L551-L555"
          snippet: |
            if (timeout_data.tid != -1)
                jl_thread_resume(tid);
            #else
            jl_thread_resume(tid);
            #endif

  secondary_effects:
    - effect: "Improved profiler reliability on Windows x86-64"
      mechanism: |
        The profiler timeout mechanism prevents deadlocks during stackwalking.
        Call chain for timeout-protected backtrace collection:

        profile_bt() [signals-win.c:484]
          -> jl_thread_suspend(tid, &c) [signals-win.c:520]
          -> jl_set_profile_abort_ptr(&abort_profiling) [signals-win.c:532]
          -> CreateTimerQueueTimer(&hTimer, hTimerQueue, profile_timeout_cb, ...) [signals-win.c:534]
          -> rec_backtrace_ctx() [signals-win.c:543]
               -> jl_unw_step() [stackwalk.c:597]
                    -> RtlLookupFunctionEntry() [stackwalk.c:418,431] (can deadlock)
                    -> checks abort_profile_ptr [stackwalk.c:628-632]
          -> DeleteTimerQueueTimer() [signals-win.c:550]
          -> jl_thread_resume(tid) [signals-win.c:552]

        When RtlLookupFunctionEntry deadlocks (due to loader lock contention),
        the timer fires and profile_timeout_cb() [signals-win.c:423] sets
        abort_profiling=2, causing jl_unw_step() to abort and return early.

        The TimerQueue API is reportedly more reliable at actually firing the
        callback compared to RegisterWaitForSingleObject in contended scenarios.
      downstream_surfaces:
        - "Julia's built-in profiler (@profile macro)"
        - "Profile.jl stdlib"
      likelihood: "high"
      impact: "medium"

    - effect: "Increased timeout from 100ms to 1000ms"
      mechanism: |
        The timeout was changed from 100 milliseconds to 1000 milliseconds (1 second).
        This gives more time for slow stackwalks to complete before aborting.

        Old code:
          RegisterWaitForSingleObject(&hWaitHandle, hProfileEvent, profile_timeout_cb,
                                      &timeout_data, 100, WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD)

        New code:
          CreateTimerQueueTimer(&hTimer, hTimerQueue, profile_timeout_cb,
                               &timeout_data, 1000 /* milliseconds */, 0,
                               WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD)
      downstream_surfaces:
        - "Profiler response time on Windows"
      likelihood: "high"
      impact: "low"

    - effect: "Thread resume logic clarification (preprocessor reorganization)"
      mechanism: |
        The conditional thread resume (timeout_data.tid != -1) was ALREADY present
        in the old code. This PR reorganizes the preprocessor directives for clarity
        but preserves identical semantics.

        Old code [signals-win.c, before PR]:
          if (timeout_data.tid != -1)
          #endif
              jl_thread_resume(tid);

        New code [signals-win.c:551-555]:
          if (timeout_data.tid != -1)
              jl_thread_resume(tid);
          #else
          jl_thread_resume(tid);
          #endif

        Both versions have the SAME behavior:
        - On x86-64: Resume only if timeout callback hasn't already resumed (tid != -1)
        - On non-x86-64: Always resume unconditionally (no timeout mechanism exists)

        The timeout callback sets tid = -1 when it resumes the thread:
        profile_timeout_cb [signals-win.c:423-435]:
          if (jl_atomic_exchange(data->abort_ptr, 2) == 1) {
              jl_thread_resume(data->tid);
              data->tid = -1;  // Mark as already resumed
          }
      downstream_surfaces:
        - "Code clarity, no behavioral change"
      likelihood: "high"
      impact: "none"

    - effect: "Abort state machine protocol (unchanged but critical context)"
      mechanism: |
        The timeout callback interacts with jl_unw_step() via a lock-free
        state machine using abort_profile_ptr. This protocol is UNCHANGED
        by the PR but is critical context for understanding the fix.

        State machine states:
          0 = Not in critical section (initial/cleared state)
          1 = In critical section (before RtlLookupFunctionEntry)
          2 = Timeout fired while in critical section (abort requested)
          3 = Abort completed (terminal state)

        Protocol in jl_unw_step() [stackwalk.c:627-642]:
          // Before dangerous call:
          if (abort_ptr && jl_atomic_exchange_relaxed(abort_ptr, 1) != 0) {
              jl_atomic_store_relaxed(abort_ptr, 3);
              return 0; // If not 0, timeout already fired - abort
          }

          // Dangerous calls (can deadlock on Windows loader lock):
          JuliaGetModuleBase64() -> RtlLookupFunctionEntry() [stackwalk.c:418]
          JuliaFunctionTableAccess64() -> RtlLookupFunctionEntry() [stackwalk.c:431]

          // After dangerous call:
          if (abort_ptr && jl_atomic_exchange_relaxed(abort_ptr, 0) != 1) {
              jl_atomic_store_relaxed(abort_ptr, 3);
              return 0; // If not 1, timeout fired (value=2) - abort
          }

        Protocol in profile_timeout_cb() [signals-win.c:429-432]:
          // On timeout, try to signal abort:
          if (jl_atomic_exchange(data->abort_ptr, 2) == 1) {
              // Was 1 (in critical section), so resume thread
              jl_thread_resume(data->tid);
              data->tid = -1;  // Mark as already resumed
          }
          // If was 0 (not in critical section yet), stackwalk will see 2 and abort
          // If was 0 (already exited critical section), thread already progressed

        The TimerQueue API fix ensures this callback actually fires when needed,
        whereas RegisterWaitForSingleObject could silently drop the callback.
      downstream_surfaces:
        - "Windows profiler deadlock recovery"
      likelihood: "high"
      impact: "medium"

  compatibility:
    internal_api:
      - field: "None"
        change: "No internal API changes - only Windows runtime implementation"
        affected_tools: []
        impact: "none"
        rationale: |
          This change is purely an implementation detail of the Windows profiler
          thread. No exported functions, data structures, or interfaces change.

    behavioral:
      - area: "Profiler behavior on Windows"
        change: "More reliable timeout callbacks, longer timeout (1s vs 100ms)"
        impact: "low"
        rationale: |
          The change improves reliability but extends the timeout window.
          Users may notice fewer deadlocks during profiling but slightly
          longer waits when a stackwalk does need to be aborted.

  performance:
    compile_time:
      - description: "No compile-time impact"
        impact: "none"
        rationale: "This is a runtime-only change to C code, not Julia compiler code"

    runtime:
      - description: "Improved profiler reliability on Windows"
        impact: "positive"
        measurement: "ESTIMATED"
        rationale: |
          The PR author reports this is a "significant improvement" on their machine.
          Fewer profiler deadlocks means more successful profiling sessions.

      - description: "Longer timeout (100ms -> 1000ms)"
        impact: "neutral"
        measurement: "ESTIMATED"
        rationale: |
          The longer timeout only affects cases where the stackwalk is deadlocked.
          In successful cases, the timer is cancelled before firing. In deadlock
          cases, users wait up to 1 second instead of 100ms before recovery.

  downstream_package_impact:
    - package: "Turing.jl, Enzyme.jl, GPUCompiler, JET"
      impact: "none"
      rationale: |
        These packages interact with Julia's compiler internals (type inference,
        IR manipulation, effect analysis, code generation). This PR modifies only
        the Windows profiler runtime implementation in C code.

        The change affects:
        - src/signals-win.c (Windows signal handling / profiler)

        It does NOT affect:
        - Compiler/src/abstractinterpretation.jl (type inference)
        - Compiler/src/ssair/ (SSA IR, inlining)
        - Compiler/src/tfuncs.jl (type functions)
        - JuliaSyntax, JuliaLowering
        - Any codegen or optimization passes

    - package: "Profile.jl (stdlib)"
      impact: "positive"
      rationale: |
        Profile.jl relies on the underlying profiler runtime. Windows users
        should experience fewer deadlocks when profiling code that loads DLLs
        or allocates memory during stackwalk.

  risk:
    level: "low"
    rationale:
      - "Windows-only change, does not affect Linux/macOS"
      - "x86-64 only for the timeout mechanism (non-x86-64 Windows unaffected)"
      - "No changes to compiler internals, type inference, or IR"
      - "Uses standard Windows API (TimerQueue) that is well-documented"
      - "Maintains same semantics - just more reliable timer callback firing"
      - "INVALID_HANDLE_VALUE used for synchronous cleanup (waits for callback)"
      - "PR authored by Julia core team member (topolarity)"

  open_questions:
    - "Does the 10x increase in timeout (100ms to 1000ms) affect profiler responsiveness in edge cases?"
    - "Are there other deadlock scenarios not addressed by this change (as noted by PR author)?"

  recommendations:
    - "No action needed for downstream compiler-related packages"
    - "Windows users experiencing profiler deadlocks should upgrade to include this fix"
    - "Monitor for additional deadlock reports per PR #60454 discussion"

  notes:
    not_compiler_pr: |
      This PR is a Windows-specific runtime improvement for the profiler.
      It does NOT affect:
      - Type inference (abstractinterpretation.jl)
      - SSA IR or optimization passes
      - Codegen or runtime behavior of compiled Julia code
      - OpaqueClosure or generated functions
      - World age or method invalidation
      - Any compiler internal APIs

      The PR modifies only the C runtime code for Windows signal handling
      (signals-win.c). It uses Windows-specific APIs:
      - CreateTimerQueue() - creates a timer queue
      - CreateTimerQueueTimer() - schedules a callback
      - DeleteTimerQueueTimer() - cancels/cleanup timer
      - DeleteTimerQueue() - destroys timer queue

      These replace the previous approach using:
      - CreateEvent() - created dummy event
      - RegisterWaitForSingleObject() - waited on event with timeout
      - UnregisterWaitEx() - cleanup wait registration
      - CloseHandle() - close event handle

    windows_api_comparison: |
      The PR switches between two Windows thread pool mechanisms for timeout callbacks:

      OLD APPROACH (RegisterWaitForSingleObject):
        HANDLE hProfileEvent = CreateEvent(NULL, TRUE, FALSE, NULL);  // Dummy event
        RegisterWaitForSingleObject(&hWaitHandle, hProfileEvent, callback, &data, 100, flags);
        // Problem: Event never signals, relies solely on timeout
        // Under contention, Windows may drop the callback entirely

      NEW APPROACH (CreateTimerQueueTimer):
        HANDLE hTimerQueue = CreateTimerQueue();  // Dedicated timer queue
        CreateTimerQueueTimer(&hTimer, hTimerQueue, callback, &data, 1000, 0, flags);
        // Purpose-built for timeout callbacks, no dummy event needed
        // More reliable callback delivery under system load

      Key differences:
      1. RegisterWaitForSingleObject is designed for waiting on REAL events with
         optional timeout. Using it with a dummy event (never signaled) is a hack.
      2. CreateTimerQueueTimer is specifically designed for timeout callbacks.
      3. The TimerQueue API has better internal queueing semantics.
      4. Both use WT_EXECUTEINWAITTHREAD to run callback in wait thread context.

      The 10x timeout increase (100ms -> 1000ms) may be because:
      - TimerQueue callbacks have slightly higher latency under load
      - Provides more margin for legitimate slow stackwalks
      - Makes the timeout a true "safety net" rather than aggressive cutoff

    windows_deadlock_context: |
      The Windows x86-64 profiler has a known issue with deadlocks involving
      RtlLookupFunctionEntry (used for stack unwinding) and various Windows
      runtime functions that hold internal locks:

      1. RtlLookupFunctionEntry - called during stackwalk to find unwind info
      2. RtlAllocateHeap - internal heap allocation
      3. LdrLoadDll - DLL loading

      When the profiler suspends a thread that holds one of these locks, and
      then calls RtlLookupFunctionEntry (which may need the same lock), a
      deadlock occurs. The timeout callback is a mitigation that aborts the
      stackwalk and resumes the thread.

      Related code path [stackwalk.c:628-642]:
        // Set can-abort flag
        _Atomic(int) *abort_ptr = abort_profile_ptr;
        if (abort_ptr && jl_atomic_exchange_relaxed(abort_ptr, 1) != 0) {
            jl_atomic_store_relaxed(abort_ptr, 3);
            return 0; // aborted
        }

        DWORD64 ImageBase = JuliaGetModuleBase64(GetCurrentProcess(), cursor->Rip - !from_signal_handler);
        PRUNTIME_FUNCTION FunctionEntry = ImageBase ? (PRUNTIME_FUNCTION)JuliaFunctionTableAccess64(
            GetCurrentProcess(), cursor->Rip - !from_signal_handler) : NULL;

        // Check if can-abort flag was removed, or remove it
        if (abort_ptr && jl_atomic_exchange_relaxed(abort_ptr, 0) != 1) {
            jl_atomic_store_relaxed(abort_ptr, 3);
            return 0; // abort
        }
