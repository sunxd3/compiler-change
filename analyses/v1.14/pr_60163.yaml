schema_version: "1.0"
pr:
  number: 60163
  title: "Fix conversion from `K\"meta\"` to `Expr`"
  url: "https://github.com/JuliaLang/julia/pull/60163"
  author: "mlechu"
  labels:
    - "compiler:lowering"
  merged_at: "2025-11-18T21:25:11Z"
  merge_commit_sha: "602e5dfcdc"
  diff_url: "https://github.com/JuliaLang/julia/pull/60163.diff"
scope:
  files_touched:
    - "JuliaLowering/src/ast.jl"
    - "JuliaLowering/src/kinds.jl"
    - "JuliaLowering/src/linear_ir.jl"
    - "JuliaLowering/test/hooks.jl"
    - "JuliaSyntax/src/integration/expr.jl"
    - "JuliaSyntax/src/julia/kinds.jl"
  components:
    - "JuliaSyntax"
    - "JuliaLowering"
  pipeline_stages:
    - "Parsing"
    - "Lowering"
    - "LinearIR"
analysis:
  intent:
    summary: "Fix K\"meta\" to Expr conversion by unquoting QuoteNode(Symbol) arguments, consolidate K\"meta\" kind registration in JuliaSyntax, and remove redundant CompileHints constructor."
    issue_links: []
    quoted_from_pr: "A small tweak: JuliaLowering uses quoted symbols in meta forms, where Expr does not. Miscellaneous test fixes are also included (CompileHints was overwriting a constructor, and isdefined(Core, :_lower) isn't so necessary in this repository)"
  direct_changes:
    - summary: "K\"meta\" nodes converted to Expr now unquote QuoteNode(Symbol) arguments to match Expr(:meta, :inline, ...) expectations."
      component: "JuliaSyntax integration"
      evidence:
        - source: "diff"
          path: "JuliaSyntax/src/integration/expr.jl"
          loc: "637-644"
          url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaSyntax/src/integration/expr.jl#L637-L644"
          snippet: |
            elseif k == K"meta"
                # Expr uses plain identifiers, but JuliaSyntax uses quoted (Symbol) identifiers
                for (i, a) in enumerate(args)
                    if a isa QuoteNode && a.value isa Symbol
                        args[i] = a.value
                    end
                end
            end
    - summary: "K\"meta\" kind moved from JuliaLowering to JuliaSyntax kind registration, avoiding duplicate registration."
      component: "JuliaSyntax kinds"
      evidence:
        - source: "diff"
          path: "JuliaSyntax/src/julia/kinds.jl"
          loc: "1034-1036"
          url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaSyntax/src/julia/kinds.jl#L1034-L1036"
          snippet: |
            "parens"
            "importpath"
            "meta"
        - source: "diff"
          path: "JuliaLowering/src/kinds.jl"
          loc: "21-25"
          url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaLowering/src/kinds.jl#L21-L25"
          snippet: |
            # A (quoted) `Symbol`
            "Symbol"
            # QuoteNode; not quasiquote
            "inert"
            # TODO: Use `meta` for inbounds and loopinfo etc?
    - summary: "Removed redundant CompileHints(Dict) constructor; compile_lambda now builds CompileHints iteratively."
      component: "JuliaLowering linear IR"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/linear_ir.jl"
          loc: "1105-1111"
          url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaLowering/src/linear_ir.jl#L1105-L1111"
          snippet: |
            code = renumber_body(ctx, ctx.code, slot_rewrites)
            meta = CompileHints()
            for (k, v) in ctx.meta
                meta = CompileHints(meta, k, v)
            end
            @ast ctx ex [K"code_info"(is_toplevel_thunk=ex.is_toplevel_thunk,
                                      slots=slots, meta=meta)
        - source: "diff"
          path: "JuliaLowering/src/ast.jl"
          loc: "539"
          url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaLowering/src/ast.jl#L539"
          snippet: |
            const CompileHints = Base.ImmutableDict{Symbol,Any}
    - summary: "Integration test for @propagate_inbounds @inline meta conversion enabled (previously commented as broken)."
      component: "JuliaLowering tests"
      evidence:
        - source: "test"
          path: "JuliaLowering/test/hooks.jl"
          loc: "83"
          url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaLowering/test/hooks.jl#L83"
          snippet: |
            @test jeval("Base.@propagate_inbounds @inline meta_double_quote_issue(x) = x") isa Function
  secondary_effects:
    - effect: "Expr(:meta, ...) arguments produced via JuliaSyntax no longer retain quoted symbols, which stabilizes meta-processing during lowering and macro expansion."
      mechanism: |
        _node_to_expr(retexpr, loc, srcrange, nodehead, args, ...) [JuliaSyntax/src/integration/expr.jl:319]
          -> handles K"meta" at line 637-643
          -> for each arg: if a isa QuoteNode && a.value isa Symbol, args[i] = a.value
        This ensures Expr(:meta, :inline, :propagate_inbounds) has Symbol args, not QuoteNode(:inline).
      downstream_surfaces:
        - "Macro expansion paths that expect Expr(:meta, :inline, ...) with Symbol arguments"
        - "JuliaLowering activation via parseall(Expr, ...) which relies on correct Expr format"
        - "Any downstream tooling pattern-matching on Expr(:meta, ...) argument types"
      likelihood: "high"
      impact: "medium"
      evidence:
        - source: "diff"
          path: "JuliaSyntax/src/integration/expr.jl"
          loc: "637-644"
          url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaSyntax/src/integration/expr.jl#L637-L644"
          snippet: |
            elseif k == K"meta"
                # Expr uses plain identifiers, but JuliaSyntax uses quoted (Symbol) identifiers
                for (i, a) in enumerate(args)
                    if a isa QuoteNode && a.value isa Symbol
                        args[i] = a.value
                    end
                end
            end
    - effect: "Parallel QuoteNode unpacking in _to_lowered_expr ensures consistency between SyntaxTree->Expr paths."
      mechanism: |
        _to_lowered_expr(ex::SyntaxTree, stmt_offset) [JuliaLowering/src/eval.jl:407-413]
          -> K"meta" branch unpacks QuoteNode for first argument
          -> args[1] = arg1.value where arg1 isa QuoteNode
        This code path handles SyntaxTree K"meta" -> lowered Expr(:meta) conversion,
        complementing the JuliaSyntax node_to_expr path which handles parsed K"meta" nodes.
      downstream_surfaces:
        - "CodeInfo generation from SyntaxTree (to_code_info call chain)"
        - "Any tooling inspecting lowered IR containing Expr(:meta)"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/eval.jl"
          loc: "407-413"
          url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaLowering/src/eval.jl#L407-L413"
          snippet: |
            elseif k == K"meta"
                args = Any[_to_lowered_expr(e, stmt_offset) for e in children(ex)]
                # Unpack K"Symbol" QuoteNode as `Expr(:meta)` requires an identifier here.
                arg1 = args[1]
                @assert arg1 isa QuoteNode
                args[1] = arg1.value
                Expr(:meta, args...)
    - effect: "K\"meta\" kind consolidation removes redundant registration, preventing potential kind ID conflicts."
      mechanism: |
        Before: K"meta" registered in both:
          - JuliaLowering/src/kinds.jl (as extension kind)
          - JuliaSyntax/src/julia/kinds.jl (would conflict)
        After: K"meta" only registered in JuliaSyntax/src/julia/kinds.jl:1035
        JuliaLowering still uses K"meta" but now relies on JuliaSyntax's registration.
      downstream_surfaces:
        - "Any code comparing K\"meta\" kind IDs across modules"
        - "Tooling that inspects registered kinds"
      likelihood: "low"
      impact: "low"
      evidence:
        - source: "diff"
          path: "JuliaLowering/src/kinds.jl"
          loc: "21-25"
          url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaLowering/src/kinds.jl#L21-L25"
          snippet: |
            # A (quoted) `Symbol`
            "Symbol"
            # QuoteNode; not quasiquote
            "inert"
            # TODO: Use `meta` for inbounds and loopinfo etc?
  compatibility:
    internal_api:
      - summary: "CompileHints(Dict) constructor removed; use iterative CompileHints(parent, k, v) instead."
        evidence:
          - source: "diff"
            path: "JuliaLowering/src/ast.jl"
            loc: "539"
            url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaLowering/src/ast.jl#L539"
            snippet: |
              const CompileHints = Base.ImmutableDict{Symbol,Any}
    behavioral:
      - summary: "Expr(:meta, ...) arguments are now plain Symbols, not QuoteNode(Symbol). Code pattern-matching on QuoteNode in meta args will break."
        evidence:
          - source: "diff"
            path: "JuliaSyntax/src/integration/expr.jl"
            loc: "637-644"
            url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaSyntax/src/integration/expr.jl#L637-L644"
            snippet: |
              elseif k == K"meta"
                  # Expr uses plain identifiers, but JuliaSyntax uses quoted (Symbol) identifiers
                  for (i, a) in enumerate(args)
                      if a isa QuoteNode && a.value isa Symbol
                          args[i] = a.value
                      end
                  end
              end
  performance:
    compile_time:
      - summary: "ESTIMATED: O(n) iteration over ctx.meta entries per lambda to build CompileHints; n is typically small (0-5 meta hints)."
        evidence:
          - source: "diff"
            path: "JuliaLowering/src/linear_ir.jl"
            loc: "1106-1109"
            url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaLowering/src/linear_ir.jl#L1106-L1109"
            snippet: |
              meta = CompileHints()
              for (k, v) in ctx.meta
                  meta = CompileHints(meta, k, v)
              end
    runtime:
      - summary: "No runtime impact; changes are compile-time only for metadata handling."
        evidence:
          - source: "diff"
            path: "JuliaLowering/src/linear_ir.jl"
            loc: "1106-1109"
            url: "https://github.com/JuliaLang/julia/blob/602e5dfcdc/JuliaLowering/src/linear_ir.jl#L1106-L1109"
            snippet: |
              meta = CompileHints()
              for (k, v) in ctx.meta
                  meta = CompileHints(meta, k, v)
              end
  tests:
    changed_files:
      - "JuliaLowering/test/hooks.jl"
    new_behavior_assertions:
      - "Base.@propagate_inbounds @inline combined meta macros now work through JuliaLowering.activate! path"
      - "Test verifies meta_double_quote_issue function definition succeeds via jeval()"
    coverage_gaps:
      - "No explicit test for K\"meta\" -> Expr conversion with multiple QuoteNode arguments"
      - "No test for edge case where meta args contain non-Symbol QuoteNodes"
  risk:
    level: "low"
    rationale:
      - "Change is limited to metadata conversion and JuliaSyntax Expr normalization."
      - "Previously broken test now passes, indicating the fix addresses a real issue."
      - "CompileHints constructor removal is a refactor that maintains equivalent behavior."
      - "K\"meta\" kind consolidation is a cleanup with no semantic change."
  open_questions:
    - "Should other QuoteNode arguments in K\"meta\" (non-Symbol values) also be unpacked?"
  recommendations:
    - "Downstream tools should treat Expr(:meta, ...) arguments as plain Symbols, not QuoteNodes."
    - "When constructing CompileHints, use the iterative pattern: meta = CompileHints(meta, k, v)."
    - "Tools checking for K\"meta\" kind should not assume it is registered in JuliaLowering."
