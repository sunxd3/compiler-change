schema_version: "1.0"

pr:
  number: 60093
  title: "aotcompile: implement build healing"
  url: "https://github.com/JuliaLang/julia/pull/60093"
  author: "vtjnash"
  labels:
    - "compiler:codegen"
  merged_at: "2025-11-13T20:16:54Z"
  merge_commit_sha: "59896641c53fd4ec9cb8d4b510871eaacbc2933d"
  diff_url: "https://github.com/JuliaLang/julia/pull/60093.diff"

scope:
  files_touched:
    - "src/aotcompile.cpp"
  components:
    - "Codegen"
    - "AOT Compilation"
  pipeline_stages:
    - "Codegen"
    - "Native Code Generation"
    - "Sysimage/Pkgimage Creation"

analysis:
  intent:
    summary: |
      Implements "build healing" for AOT (ahead-of-time) compilation, allowing the AOT compiler
      to substitute equivalent already-compiled CodeInstances at compile time rather than
      waiting for runtime. This mirrors functionality already present in the JIT compiler
      (jl_get_ci_equiv in gf.c), bringing the same optimization to sysimage and package image
      generation.
    issue_links: []

  direct_changes:
    - summary: "Add get_ci_equiv_compiled function to find equivalent compiled CodeInstances"
      component: "src/aotcompile.cpp"
      evidence:
        - source: "code"
          path: "src/aotcompile.cpp"
          loc: "425-445"
          url: "https://github.com/JuliaLang/julia/blob/59896641c53fd4ec9cb8d4b510871eaacbc2933d/src/aotcompile.cpp#L425-L445"
          snippet: |
            static jl_compiled_functions_t::iterator get_ci_equiv_compiled(jl_code_instance_t *ci JL_PROPAGATES_ROOT, jl_compiled_functions_t &compiled_functions) JL_NOTSAFEPOINT
            {
                jl_value_t *def = ci->def;
                jl_value_t *owner = ci->owner;
                jl_value_t *rettype = ci->rettype;
                size_t min_world = jl_atomic_load_relaxed(&ci->min_world);
                size_t max_world = jl_atomic_load_relaxed(&ci->max_world);
                for (auto it = compiled_functions.begin(), E = compiled_functions.end(); it != E; ++it) {
                    auto codeinst = it->first;
                    if (codeinst != ci &&
                        jl_atomic_load_relaxed(&codeinst->inferred) != NULL &&
                        jl_atomic_load_relaxed(&codeinst->min_world) <= min_world &&
                        jl_atomic_load_relaxed(&codeinst->max_world) >= max_world &&
                        jl_egal(codeinst->def, def) &&
                        jl_egal(codeinst->owner, owner) &&
                        jl_egal(codeinst->rettype, rettype)) {
                        return it;
                    }
                }
                return compiled_functions.end();
            }

    - summary: "Integrate equivalent CodeInstance lookup into resolve_workqueue"
      component: "src/aotcompile.cpp"
      evidence:
        - source: "code"
          path: "src/aotcompile.cpp"
          loc: "463-476"
          url: "https://github.com/JuliaLang/julia/blob/59896641c53fd4ec9cb8d4b510871eaacbc2933d/src/aotcompile.cpp#L463-L476"
          snippet: |
            auto it = compiled_functions.find(codeinst);
            if (it == compiled_functions.end())
                it = get_ci_equiv_compiled(codeinst, compiled_functions);
            if (it != compiled_functions.end()) {
                auto &decls = it->second.decls;
                invokeName = decls.functionObject;
                if (decls.functionObject == "jl_fptr_args") {
                    preal_decl = decls.specFunctionObject;
                }
                else if (decls.functionObject != "jl_fptr_sparam" && decls.functionObject != "jl_f_opaque_closure_call" && decls.functionObject != "jl_fptr_const_return") {
                    preal_decl = decls.specFunctionObject;
                    preal_specsig = true;
                }
            }

  secondary_effects:
    - effect: "Reduced code duplication in sysimages and package images"
      mechanism: |
        resolve_workqueue() processes compilation work items [aotcompile.cpp:447-552]
          -> For each CodeInstance in the workqueue, first tries direct lookup in compiled_functions
          -> If not found, calls get_ci_equiv_compiled() to find an equivalent
          -> If equivalent found, reuses its function declarations (invokeName, preal_decl, preal_specsig)
          -> This avoids emitting duplicate code for equivalent CodeInstances
      downstream_surfaces:
        - "Sysimage generation (jl_create_native)"
        - "Package image generation"
        - "Any AOT compilation workflow"
      likelihood: "high"
      impact: "low"

    - effect: "Better compile-time method resolution"
      mechanism: |
        When a method is called that requires compilation during AOT:
        1. The call site emits a prototype declaration for the callee [jitlayers.cpp context]
        2. resolve_workqueue patches these prototypes to point to actual compiled functions
        3. Previously, if exact CodeInstance wasn't found, prototype remained unresolved
        4. Now, equivalent CodeInstances can be substituted, improving method resolution

        Call chain:
        jl_create_native() [aotcompile.cpp:707 entry point]
          -> populates compiled_functions from codeinfos [aotcompile.cpp:828-854]
          -> resolve_workqueue(params, method_roots, compiled_functions) [aotcompile.cpp:866]
            -> for each workqueue item, lookup in compiled_functions [aotcompile.cpp:463]
            -> fallback to get_ci_equiv_compiled() [aotcompile.cpp:464-465]
            -> use declarations from equivalent if found [aotcompile.cpp:466-476]
          -> jl_fvar_map populated from compiled_functions AFTER resolve_workqueue [aotcompile.cpp:958]
      downstream_surfaces:
        - "Method dispatch optimization in precompiled images"
        - "Cross-module method calls in pkgimages"
      likelihood: "medium"
      impact: "low"

    - effect: "Alignment with JIT behavior for consistent semantics"
      mechanism: |
        The JIT already has equivalent functionality via jl_get_ci_equiv() in gf.c:

        JL_DLLEXPORT jl_code_instance_t *jl_get_ci_equiv(jl_code_instance_t *ci JL_PROPAGATES_ROOT, size_t target_world) JL_NOTSAFEPOINT
        {
            jl_value_t *def = ci->def;
            jl_method_instance_t *mi = jl_get_ci_mi(ci);
            jl_value_t *owner = ci->owner;
            jl_value_t *rettype = ci->rettype;
            size_t min_world = jl_atomic_load_relaxed(&ci->min_world);
            size_t max_world = jl_atomic_load_relaxed(&ci->max_world);
            jl_code_instance_t *codeinst = jl_atomic_load_relaxed(&mi->cache);
            while (codeinst) {
                if (codeinst != ci &&
                    jl_atomic_load_relaxed(&codeinst->inferred) != NULL &&
                    (target_world ? 1 : jl_atomic_load_relaxed(&codeinst->invoke) != NULL) &&
                    jl_atomic_load_relaxed(&codeinst->min_world) <= (target_world ? target_world : min_world) &&
                    jl_atomic_load_relaxed(&codeinst->max_world) >= (target_world ? target_world : max_world) &&
                    jl_egal(codeinst->def, def) &&
                    jl_egal(codeinst->owner, owner) &&
                    jl_egal(codeinst->rettype, rettype)) {
                    return codeinst;
                }
                codeinst = jl_atomic_load_relaxed(&codeinst->next);
            }
            return ci;
        }

        The JIT uses this in jitlayers.cpp:423:
            jl_code_instance_t *compiled_ci = jl_get_ci_equiv(codeinst, 0);

        KEY DIFFERENCE: JIT checks (invoke != NULL) when target_world=0, AOT only checks (inferred != NULL).
        JIT searches the MethodInstance cache linked list; AOT searches compiled_functions DenseMap.
      downstream_surfaces:
        - "Behavioral parity between JIT and AOT compiled code"
      likelihood: "high"
      impact: "low"

    - effect: "jl_get_ci_equiv also used in type inference compilation queue"
      mechanism: |
        The JIT equivalent jl_get_ci_equiv is also called from Compiler/src/typeinfer.jl
        during add_codeinsts_to_jit! workflow:

        # From typeinfer.jl:1545-1554
        if iszero(ccall(:jl_mi_cache_has_ci, Cint, (Any, Any), mi, callee))
            cached = ccall(:jl_get_ci_equiv, Any, (Any, UInt), callee, get_inference_world(workqueue.interp))::CodeInstance
            if cached === callee
                # make sure callee is gc-rooted and cached, as required by jl_add_codeinst_to_jit
                code_cache(workqueue.interp)[mi] = callee
            else
                # use an existing CI from the cache, if there is available one that is compatible
                callee === ci && (ci = cached)
                callee = cached
            end
        end

        This establishes the pattern as well-tested in the codebase.
      downstream_surfaces:
        - "JIT compilation of type inference results"
        - "Compiler/src module integration"
      likelihood: "high"
      impact: "low"

  compatibility:
    internal_api:
      - field: "jl_compiled_functions_t iteration"
        change: "New function iterates over compiled_functions to find equivalents"
        affected_tools:
          - "Tools that analyze or modify AOT compilation artifacts"
          - "Custom sysimage builders that inspect compiled_functions state"

      - field: "jl_fvar_map CodeInstance identity"
        change: "jl_fvar_map still contains ORIGINAL CodeInstances from compiled_functions, not substituted ones"
        detail: |
          The substitution in resolve_workqueue only affects workqueue prototype resolution.
          jl_fvar_map is populated AFTER resolve_workqueue from compiled_functions [aotcompile.cpp:958]:
              data->jl_fvar_map[this_code] = std::make_tuple(func_id, cfunc_id);
          The 'this_code' comes from compiled_functions, not the workqueue.
          Therefore, jl_get_llvm_cis() and jl_get_function_id() return original CodeInstances.
        affected_tools:
          - "Code analyzing jl_fvar_map entries"
          - "staticdata.c consumers of jl_get_llvm_cis()"

    behavioral:
      - change: "Workqueue prototype resolution may use different CodeInstance"
        description: |
          Tools or code that rely on exact CodeInstance identity for workqueue items
          may see different behavior. If two CodeInstances are equivalent
          (same def, owner, rettype, compatible world ages), the AOT compiler may now
          substitute one for the other when resolving prototypes.
        affected_patterns:
          - "Code tracking which specific CodeInstance a prototype resolves to"
          - "Debugging tools inspecting prototype resolution"

  performance:
    compile_time:
      - impact: "Slight increase in AOT compile time"
        description: |
          ESTIMATED: O(n*m) where n = workqueue size, m = compiled_functions size
          For each unresolved CodeInstance in workqueue, linear scan of compiled_functions.
          Mitigated by:
          - Only triggered when direct hash lookup fails (line 463)
          - compiled_functions typically small relative to total method count
          - Early termination on first match
          - DenseMap iteration is cache-efficient

          Search only occurs when compiled_functions.find() returns end(),
          meaning the exact CodeInstance isn't in compiled_functions.
        measurement: "ESTIMATED"

    runtime:
      - impact: "Potential improvement in image load time and code size"
        description: |
          By reusing compiled functions for equivalent CodeInstances:
          - Reduced code duplication in sysimages/pkgimages
          - Smaller image file sizes
          - Faster image loading due to less code to relocate
          - Better instruction cache utilization at runtime
        measurement: "ESTIMATED"

  risk:
    level: "low"
    rationale:
      - "Small, focused change (24 lines added)"
      - "Mirrors existing well-tested JIT functionality (jl_get_ci_equiv)"
      - "Author (vtjnash) is a core Julia runtime developer with deep expertise"
      - "Equivalence criteria are strict: same def, owner, rettype, compatible worlds"
      - "Only affects AOT compilation path, not runtime semantics"
      - "Falls back gracefully if no equivalent found"
      - "jl_fvar_map identity preserved - only prototype resolution affected"

  equivalence_criteria:
    description: "Two CodeInstances are considered equivalent for AOT healing if:"
    criteria:
      - "Different CodeInstance objects (codeinst != ci)"
      - "Target has inferred code (inferred != NULL)"
      - "Target world range encompasses source: target.min_world <= source.min_world AND target.max_world >= source.max_world"
      - "Same method definition (jl_egal(def, def))"
      - "Same owner token (jl_egal(owner, owner))"
      - "Same return type (jl_egal(rettype, rettype))"
    difference_from_jit:
      description: "The AOT version differs from JIT jl_get_ci_equiv in one key aspect"
      detail: |
        JIT (target_world=0): requires (invoke != NULL) - the substitute must already be compiled
        AOT: only requires (inferred != NULL) - the substitute only needs inferred code

        This is correct because:
        - JIT needs an already-compiled function to call at runtime
        - AOT is generating code, so it only needs IR/inferred code to emit declarations

  open_questions:
    - "Could this affect reproducibility of AOT builds if DenseMap iteration order varies?"
    - "Are there edge cases where substituting equivalent CodeInstances changes observable behavior?"
    - "Should the equivalence check also consider exctype (exception type) for stricter matching?"
    - "Why does AOT check (inferred != NULL) while JIT checks (invoke != NULL) - is this intentional?"

  recommendations:
    - "Monitor for any reports of unexpected behavior in sysimage/pkgimage generation"
    - "Consider adding metrics/logging to track how often build healing activates"
    - "Document the equivalence criteria for downstream tooling maintainers"
    - "Consider whether DenseMap iteration order could cause non-reproducible builds"

  reviewer_notes:
    added_by_second_review: true
    additional_findings:
      - finding: "fvar_map identity is preserved"
        detail: |
          Initial analysis suggested fvar_map entries might change identity. After tracing
          the call chain: resolve_workqueue (line 866) runs BEFORE fvar_map population
          (line 958), but resolve_workqueue only affects workqueue items, not compiled_functions.
          The fvar_map is keyed by CodeInstances from compiled_functions, which are unchanged.
          Therefore jl_get_llvm_cis() and jl_get_function_id() return original CodeInstances.

      - finding: "Integration with type inference verified"
        detail: |
          The jl_get_ci_equiv function is also called from Compiler/src/typeinfer.jl at
          lines 1546 and 1635 during the add_codeinsts_to_jit! flow. This establishes
          the equivalence substitution pattern as well-tested in the existing codebase,
          reducing the risk of this AOT extension.

      - finding: "invoke vs inferred check difference is intentional"
        detail: |
          The JIT version requires invoke != NULL because it needs a callable function.
          The AOT version only requires inferred != NULL because it's generating code
          from IR, not calling existing compiled code. This difference is correct.

downstream_package_impact:
  opaque_closure:
    affected: false
    description: |
      OpaqueClosure compilation goes through the same AOT pipeline but uses the same
      equivalence criteria. The proto.oc handling in resolve_workqueue (lines 525-547)
      happens after the equivalent lookup, so OpaqueClosure invokes are resolved correctly.

  generated_functions:
    affected: false
    description: |
      Generated functions (@generated) produce CodeInstances through normal compilation.
      Build healing applies the same equivalence rules regardless of how the CodeInstance
      was created, so generated function results are handled consistently.

  world_age_invalidation:
    affected: false
    description: |
      World age checking is part of the equivalence criteria. A CodeInstance is only
      substituted if its world range encompasses the target's world range, ensuring
      no invalid code can be selected.

  internal_api_consumers:
    jet:
      affected: "unlikely"
      description: |
        JET operates primarily on inference results, not AOT artifacts.
        JET reads CodeInstance.inferred for analysis, which is not affected by
        the prototype resolution substitution.

    irtools:
      affected: "unlikely"
      description: |
        IRTools operates on IR representation, not compiled native code.
        The substitution only affects which compiled function a prototype resolves to.

    gpucompiler:
      affected: "possible"
      description: |
        GPUCompiler uses Julia's compilation infrastructure for GPU code generation.
        If it uses AOT-like compilation paths similar to jl_create_native, equivalent
        CodeInstance substitution could affect which function variants are selected.
        However, GPUCompiler typically manages its own compilation state.

    enzyme:
      affected: "unlikely"
      description: |
        Enzyme performs AD transformation on LLVM IR. The source CodeInstance
        identity shouldn't affect Enzyme's differentiation, as it operates on
        the IR content rather than CodeInstance metadata.
