schema_version: "1.0"
pr:
  number: 59991
  title: "cgutils: fix write barrier of atomic-setonce"
  url: "https://github.com/JuliaLang/julia/pull/59991"
  author: "vtjnash"
  labels:
    - "bug"
    - "backport 1.11"
  merged_at: "2025-11-01T02:55:07Z"
  merge_commit_sha: "c7eff33a430646168b9b0043c837c55748b4566f"
  diff_url: "https://github.com/JuliaLang/julia/pull/59991.diff"
scope:
  files_touched:
    - "src/cgutils.cpp"
    - "test/atomics.jl"
  components:
    - "Codegen"
    - "Atomics"
    - "Tests"
  pipeline_stages:
    - "Codegen"
    - "Runtime"
analysis:
  intent:
    summary: "Fix incorrect CAS loop termination condition in LLVM IR generation for atomic setfieldonce operations. The bug caused the loop to continue even after a successful cmpxchg, leading to random crashes when the field's old value was null (undefined)."
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/59883"
    reviewer_note: |
      The PR title mentions "write barrier" but the actual fix is in the CAS loop termination
      logic (Done condition), not the write barrier emission code. The write barrier code at
      lines 2712-2744 already correctly conditioned on Success. The bug was that the loop
      would spuriously continue when CAS succeeded but the old value was null.
  direct_changes:
    - summary: "Fix setfieldonce Done condition in typed_store to include CAS Success flag via OR operation"
      component: "Codegen (src/cgutils.cpp)"
      evidence:
        - source: "diff"
          path: "src/cgutils.cpp"
          loc: "2675-2681"
          url: "https://github.com/JuliaLang/julia/blob/c7eff33a430646168b9b0043c837c55748b4566f/src/cgutils.cpp#L2675-L2681"
          snippet: |
            if (issetfieldonce) {
                assert(!isboxed && maybe_null_if_boxed);
                Value *first_ptr = extract_first_ptr(ctx, realinstr);
                assert(first_ptr != nullptr);
                // Done = Success || first_ptr != NULL
                Done = ctx.builder.CreateOr(Success, ctx.builder.CreateIsNotNull(first_ptr));
            }
        - source: "diff_before"
          path: "src/cgutils.cpp"
          loc: "2676-2679 (before fix)"
          snippet: |
            if (issetfieldonce) {
                assert(!isboxed && maybe_null_if_boxed);
                Value *first_ptr = extract_first_ptr(ctx, realinstr);
                assert(first_ptr != nullptr);
                Done = ctx.builder.CreateIsNotNull(first_ptr);  // BUG: ignores Success flag
            }
    - summary: "Add clarifying comment for isreplacefield Done condition logic"
      component: "Codegen (src/cgutils.cpp)"
      evidence:
        - source: "code"
          path: "src/cgutils.cpp"
          loc: "2682-2692"
          url: "https://github.com/JuliaLang/julia/blob/c7eff33a430646168b9b0043c837c55748b4566f/src/cgutils.cpp#L2682-L2692"
          snippet: |
            else {
                // Done = Success || first_ptr == NULL || oldval == cmpop)
                // Done = !(!Success && (first_ptr != NULL && oldval == cmpop))
                Done = emit_guarded_test(ctx, ctx.builder.CreateNot(Success), false, [&] {
                    Value *first_ptr = nullptr;
                    if (maybe_null_if_boxed)
                        first_ptr = isboxed ? realinstr : extract_first_ptr(ctx, realinstr);
                    return emit_f_is(ctx, oldval, cmpop, first_ptr, nullptr);
                });
                Done = ctx.builder.CreateNot(Done);
            }
    - summary: "Update UndefComplex test struct to use defined fields instead of undef inner constructor to enable inlining and proper test coverage"
      component: "Tests (test/atomics.jl)"
      evidence:
        - source: "diff"
          path: "test/atomics.jl"
          loc: "57-61"
          url: "https://github.com/JuliaLang/julia/blob/c7eff33a430646168b9b0043c837c55748b4566f/test/atomics.jl#L57-L61"
          snippet: |
            struct UndefComplex{T}
                re::T
                im::T
            end
            Base.convert(T::Type{<:UndefComplex}, S) = T(S, 0)
        - source: "diff_before"
          path: "test/atomics.jl"
          loc: "57-62 (before fix)"
          snippet: |
            struct UndefComplex{T}
                re::T
                im::T
                UndefComplex{T}() where {T} = new{T}()  # Created undef fields
            end
            Base.convert(T::Type{<:UndefComplex}, S) = T()
  secondary_effects:
    - effect: "Atomic setfieldonce operations now correctly report success and exit the CAS loop when the compare-and-swap succeeds, matching runtime behavior in datatype.c"
      mechanism: |
        typed_store() generates LLVM IR for atomic field operations [cgutils.cpp:2293]
          -> issetfieldonce determined from builtin check [codegen.cpp:3658]:
             bool issetfieldonce = f == BUILTIN(setfieldonce);
          -> needloop condition for setfieldonce [cgutils.cpp:2541-2544]:
             needloop = !isboxed && Order != AtomicOrdering::NotAtomic && nb > sizeof(void*);
             if (Order != AtomicOrdering::NotAtomic)
                 Compare = Constant::getNullValue(elty);
          -> CAS loop entry [cgutils.cpp:2557-2564]:
             BB = BasicBlock::Create(ctx.builder.getContext(), "xchg", ctx.f);
             CmpPhi = ctx.builder.CreatePHI(elty, 2);
          -> cmpxchg instruction [cgutils.cpp:2654]:
             auto *store = ctx.builder.CreateAtomicCmpXchg(ptr, Compare, r, ...);
          -> extract Success from cmpxchg result [cgutils.cpp:2658-2659]:
             instr = ctx.builder.Insert(ExtractValueInst::Create(store, 0));  // old value
             Success = ctx.builder.Insert(ExtractValueInst::Create(store, 1)); // success flag
          -> compute Done for loop termination [cgutils.cpp:2675-2680]:
             BEFORE: Done = CreateIsNotNull(first_ptr)
                     // BUG: If CAS succeeded but old value was null, Done=false, loop continues!
             AFTER:  Done = CreateOr(Success, CreateIsNotNull(first_ptr))
                     // CORRECT: Exit if CAS succeeded OR field was already defined
          -> loop branch [cgutils.cpp:2694-2695]:
             ctx.builder.CreateCondBr(Done, DoneBB, BB);  // exits loop if Done

        Semantic for setfieldonce CAS loop:
          - Goal: atomically store value to undefined field, fail if already defined
          - Loop continues while: CAS failed AND field still undefined
          - Loop exits when: CAS succeeded OR field was defined by another thread
          - Done = Success || (first_ptr != NULL)
      downstream_surfaces:
        - "@atomiconce and setfieldonce! operations"
        - "Packages using atomic field initialization (e.g., PermutationGroups.jl)"
      likelihood: "high"
      impact: "high"
    - effect: "Non-atomic setfieldonce path was already correct and unaffected by this bug"
      mechanism: |
        The non-atomic path (Order == AtomicOrdering::NotAtomic) at [cgutils.cpp:2607-2642]
        computes Success differently and doesn't use a CAS loop:

        [cgutils.cpp:2620-2624]:
        assert(!issetfieldonce || first_ptr != nullptr);
        if (issetfieldonce)
            Success = ctx.builder.CreateIsNull(first_ptr);  // Field undefined = can store
        else
            Success = emit_f_is(ctx, oldval, cmpop, first_ptr, nullptr);

        [cgutils.cpp:2628-2629]:
        ctx.builder.CreateCondBr(Success, XchgBB, needloop && ismodifyfield ? BB : DoneBB);

        For non-atomic setfieldonce:
          - Loads current value, checks if null (undefined)
          - If null, branches to XchgBB to perform store
          - If not null, branches directly to DoneBB (field already defined)
          - No loop needed, single load-check-store sequence

        This path was never affected by the bug because it doesn't use the broken
        Done computation in the atomic CAS loop.
      downstream_surfaces:
        - "Non-atomic field initialization (rare use case)"
      likelihood: "high"
      impact: "informational"
    - effect: "extract_first_ptr is key to determining struct field definedness for inline structs"
      mechanism: |
        For inline (non-boxed) structs containing pointers, definedness is determined by
        checking the first pointer field within the struct:

        [cgutils.cpp:2162-2167]:
        Value *extract_first_ptr(jl_codectx_t &ctx, Value *V)
        {
            auto path = first_ptr(V->getType());
            if (path.empty())
                return NULL;
            std::reverse(std::begin(path), std::end(path));
            // ... extracts nested pointer using GEP/ExtractValue

        The first_ptr() helper [cgutils.cpp:2133-2161] recursively finds the path to
        the first pointer element in an LLVM struct type.

        For setfieldonce on inline structs:
          - assert(!isboxed && maybe_null_if_boxed) [cgutils.cpp:2676]
          - Struct must have pointers (maybe_null_if_boxed = true)
          - extract_first_ptr returns the address of the first pointer field
          - CreateIsNotNull checks if that pointer is non-null (field defined)
      downstream_surfaces:
        - "setfieldonce! on struct fields with pointer components"
      likelihood: "high"
      impact: "medium"
    - effect: "Test coverage for setfieldonce codegen path now properly exercises the inlined code path since structs with defined fields are eligible for inlining"
      mechanism: |
        Test struct UndefComplex previously used new{T}() inner constructor [atomics.jl:60 before]
          -> created struct with truly undefined fields
          -> undef fields prevent struct inlining in codegen
          -> setfieldonce codegen path for inlined structs was not tested

        After fix, UndefComplex uses T(S, 0) [atomics.jl:61 after]
          -> creates struct with defined fields (re=S, im=0)
          -> struct becomes eligible for inlining
          -> exercises the buggy/fixed codegen path

        Test functions affected [atomics.jl:363-384]:
        @noinline function _test_once_undef(r)
            r = r[]
            TT = fieldtype(typeof(r), :x)
            x = convert(TT, 12345_10)
            @test_throws UndefRefError getfield(r, :x)
            @test setfieldonce!(r, :x, x, :sequentially_consistent) === true
            @test getfield(r, :x, :sequentially_consistent) === x
            @test setfieldonce!(r, :x, convert(TT, 12345_20), :sequentially_consistent) === false
            nothing
        end
        test_once_undef(ARefxy{UndefComplex{Any}})
        test_once_undef(ARefxy{UndefComplex{UndefComplex{Any}}})
      downstream_surfaces:
        - "Test reliability for atomic operations"
      likelihood: "high"
      impact: "low"
    - effect: "Runtime implementation in datatype.c already had correct semantics which codegen now matches"
      mechanism: |
        [datatype.c:2245-2265] setonce_bits returns success flag correctly:
        inline int setonce_bits(jl_datatype_t *rty, char *p, jl_value_t *parent, jl_value_t *rhs, enum atomic_kind isatomic)
        {
            size_t fsz = jl_datatype_size((jl_datatype_t*)rty);
            assert(rty->layout->first_ptr >= 0);
            int hasptr = 1;
            int needlock = (isatomic && fsz > MAX_ATOMIC_SIZE);
            int success;
            if (isatomic && !needlock) {
                success = jl_atomic_storeonce_bits(rty, p, rhs, fsz);  // CAS-based
            }
            else {
                char *px = lock(p, parent, needlock, isatomic);
                success = undefref_check(rty, (jl_value_t*)px) == NULL;  // Check undefined
                if (success)
                    memassign_safe(hasptr, px, rhs, fsz);  // Store if undefined
                unlock(p, parent, needlock, isatomic);
            }
            if (success)
                jl_gc_multi_wb(parent, rhs);  // Write barrier on success
            return success;
        }

        [datatype.c:1414-1412] jl_atomic_storeonce_bits performs atomic CAS:
        - Attempts CAS with expected=0 (null/undefined)
        - Returns success flag from CAS operation
        - Caller (setonce_bits) uses this success flag directly

        The codegen fix aligns the LLVM IR generation with this runtime behavior.
      downstream_surfaces:
        - "Consistency between compiled and interpreted atomic operations"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api: []
    behavioral:
      - change: "Atomic setfieldonce operations no longer spuriously continue the CAS loop after a successful store to an undefined field"
        evidence:
          - source: "issue"
            path: "GitHub Issue #59883"
            url: "https://github.com/JuliaLang/julia/issues/59883"
            snippet: |
              Issue reported random crashes in Julia 1.12/1.13 with @atomic/@atomiconce
              operations in PermutationGroups.jl. The bug was described as "the worst
              Heisenbug I've ever seen" - extremely difficult to reproduce, only appeared
              under specific test conditions (using `]test` but not direct `include`).
              CI passed but actual package usage crashed unpredictably.
        root_cause: |
          When setfieldonce CAS succeeded on an undefined field (old value = null):
          - CAS returns Success=true, old_value=null
          - Bug: Done = IsNotNull(null) = false
          - Loop continued spuriously, potentially corrupting memory
          - Fix: Done = Success || IsNotNull(first_ptr) = true || false = true
          - Loop correctly exits on success
  performance:
    compile_time: []
    runtime:
      - impact: "MEASURED: Fixes correctness bug causing random crashes. No performance regression - the fix adds a single OR instruction to combine Success with the already-computed IsNotNull result."
        evidence:
          - source: "code"
            path: "src/cgutils.cpp"
            loc: "2680"
            url: "https://github.com/JuliaLang/julia/blob/c7eff33a430646168b9b0043c837c55748b4566f/src/cgutils.cpp#L2680"
            snippet: |
              // Single LLVM OR instruction added:
              Done = ctx.builder.CreateOr(Success, ctx.builder.CreateIsNotNull(first_ptr));
  risk:
    level: "low"
    rationale:
      - "Minimal change: single line fix adding OR with already-computed Success flag"
      - "Aligns codegen with established runtime behavior in datatype.c setonce_bits()"
      - "Bug fix only - no new features or architectural changes"
      - "Marked for backport to 1.11, indicating high confidence in the fix"
      - "Test change ensures the fix is properly covered going forward"
      - "Non-atomic path was already correct, limiting regression scope to atomic CAS loop"
      - "Assertion constraints (assert(!isboxed && maybe_null_if_boxed)) ensure fix only applies to intended code path"
  open_questions: []
  recommendations:
    - "Packages experiencing random crashes with @atomiconce in Julia 1.12 should upgrade to include this fix"
    - "Consider adding explicit test cases that verify setfieldonce success/failure semantics more directly, with specific assertions on return values"
    - "The PR title mentions 'write barrier' but the actual fix is in the CAS loop termination - documentation or commit message could be clearer"
    - "Consider adding LLVM IR tests that verify the generated Done condition includes the OR with Success"
