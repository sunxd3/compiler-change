schema_version: "1.0"
pr:
  number: 60170
  title: "[JuliaLowering] Reconstruct macro name before, not during, macro expansion"
  url: "https://github.com/JuliaLang/julia/pull/60170"
  author: "mlechu"
  labels:
    - "compiler:lowering"
  merged_at: "2025-12-04T21:30:38Z"
  merge_commit_sha: "f163ed8c"
  diff_url: "https://github.com/JuliaLang/julia/pull/60170.diff"
scope:
  files_touched:
    - "JuliaLowering/src/ast.jl"
    - "JuliaLowering/src/compat.jl"
    - "JuliaLowering/src/macro_expansion.jl"
    - "JuliaLowering/src/syntax_graph.jl"
    - "JuliaLowering/test/compat.jl"
    - "JuliaLowering/test/macros.jl"
    - "JuliaLowering/test/macros_ir.jl"
    - "JuliaLowering/test/utils.jl"
    - "test/JuliaLowering_stdlibs.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Parsing"
    - "Lowering"
    - "MacroExpansion"
analysis:
  intent:
    summary: "Move macro-name reconstruction into SyntaxGraph lowering so macro expansion sees identifiers (e.g., @mac) directly, simplifying macro name handling and fixing edge cases like @__dot__ and @static in @preserve."
    issue_links:
      - "https://github.com/JuliaLang/JuliaLowering.jl/issues/121"
  direct_changes:
    - summary: "Convert macro-name nodes (macro_name / StrMacroName / CmdMacroName) into K\"Identifier\" with @-prefixed name_val during green->AST conversion, including dotted macro paths. Uses lower_identifier_name from JuliaSyntax."
      component: "JuliaLowering/src/syntax_graph.jl"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/julia/literal_parsing.jl"
          loc: "457-468"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/base/JuliaSyntax/src/julia/literal_parsing.jl#L457-L468"
          snippet: |
            function lower_identifier_name(name::AbstractString, k::Kind)
                # Replicate eager lowering done by the flisp parser
                if k == K"macro_name"
                    name == "." ? "@__dot__" : "@$name"
                elseif k == K"StrMacroName"
                    "@$(name)_str"
                elseif k == K"CmdMacroName"
                    "@$(name)_cmd"
                else
                    name
                end
            end
        - source: "code"
          path: "JuliaLowering/src/syntax_graph.jl"
          loc: "889-906"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/syntax_graph.jl#L889-L906"
          snippet: |
            elseif k === K"CmdMacroName" || k === K"StrMacroName"
                name = lower_identifier_name(ex.name_val, k)
                setattr!(makeleaf(graph, ex, K"Identifier"),
                         :name_val, name)
            elseif k === K"macro_name"
                # M.@x parses to (. M (macro_name x))
                # @M.x parses to (macro_name (. M x))
                # We want (. M @x) (both identifiers) in either case
                @assert numchildren(ex) === 2 && kind(ex[1]) === K"@"
                id = ex[2]
                mname_raw = (kind(id) === K"." ? id[2] : id).name_val
                mac_id = setattr!(makeleaf(graph, ex, K"Identifier"), :name_val,
                                  lower_identifier_name(mname_raw, K"macro_name"))
                if kind(id) === K"."
                    makenode(graph, ex, ex, NodeId[id[1]._id, mac_id._id])
                else
                    mac_id
                end
    - summary: "Macro expansion now operates on the reconstructed identifier directly by removing the fixup_macro_name function entirely. The eval_macro_name function now receives @-prefixed identifiers from _green_to_ast, and cmdstring macrocalls use @cmd identifiers."
      component: "JuliaLowering/src/macro_expansion.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/macro_expansion.jl"
          loc: "164-196"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/macro_expansion.jl#L164-L196"
          snippet: |
            function eval_macro_name(ctx::MacroExpansionContext, mctx::MacroContext, ex0::SyntaxTree)
                mod = current_layer(ctx).mod
                ex = expand_forms_1(ctx, ex0)  # No more fixup_macro_name(ctx, ...) call
                try
                    if kind(ex) === K"Value"
                        !(ex.value isa GlobalRef) ? ex.value :
                            Base.invoke_in_world(ctx.macro_world, getglobal,
                                                 ex.value.mod, ex.value.name)
                    elseif kind(ex) === K"Identifier"
                        layer = get(ex, :scope_layer, nothing)
                        if !isnothing(layer)
                            mod = ctx.scope_layers[layer].mod
                        end
                        Base.invoke_in_world(ctx.macro_world, getproperty,
                                             mod, Symbol(ex.name_val))
                    elseif kind(ex) === K"." &&
                            (ed = _eval_dot(ctx.macro_world, mod, ex); !isnothing(ed))
                        ed
                    else
                        ctx2, ex2 = expand_forms_2(ctx, ex)
                        ctx3, ex3 = resolve_scopes(ctx2, ex2)
                        ctx4, ex4 = convert_closures(ctx3, ex3)
                        ctx5, ex5 = linearize_ir(ctx4, ex4)
                        expr_form = to_lowered_expr(ex5)
                        ccall(:jl_toplevel_eval, Any, (Any, Any), mod, expr_form)
                    end
                catch err
                    throw(MacroExpansionError(mctx, ex, "Macro not found", :all, err))
                end
            end
        - source: "diff"
          path: "JuliaLowering/src/macro_expansion.jl"
          loc: "138-165 (removed)"
          url: "https://github.com/JuliaLang/julia/pull/60170/files#diff-macro_expansion"
          snippet: |
            # REMOVED: The fixup_macro_name function was entirely deleted:
            # function fixup_macro_name(ctx::MacroExpansionContext, ex::SyntaxTree)
            #     k = kind(ex)
            #     if k == K"StrMacroName" || k == K"CmdMacroName"
            #         layerid = get(ex, :scope_layer, current_layer_id(ctx))
            #         newname = JuliaSyntax.lower_identifier_name(ex.name_val, k)
            #         makeleaf(ctx, ex, ex, [:kind=>K"Identifier", :scope_layer=>layerid,
            #                                :name_val=>newname])
            #     elseif k == K"macro_name"
            #         ...
            #     end
            # end
            # This simplification was possible because _green_to_ast now handles
            # macro name reconstruction during green->AST conversion.
        - source: "code"
          path: "JuliaLowering/src/macro_expansion.jl"
          loc: "488-491"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/macro_expansion.jl#L488-L491"
          snippet: |
            elseif k == K"cmdstring"
                @chk numchildren(ex) == 1
                e2 = @ast ctx ex [K"macrocall" "@cmd"::K"core" ex[1]]
                expand_macro(ctx, e2)
    - summary: "Compat Expr->SyntaxTree conversion treats macrocall names as @-prefixed identifiers, including @__dot__ rewriting and do-block macrocalls without wrapping a macro_name node."
      component: "JuliaLowering/src/compat.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/compat.jl"
          loc: "262-274"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/compat.jl#L262-L274"
          snippet: |
            elseif e.head === :macrocall
                @assert nargs >= 2
                a1,a1_esc = unwrap_esc(e.args[1])
                child_exprs = collect_expr_parameters(e, 3)
                if child_exprs[2] isa LineNumberNode
                    src = child_exprs[2]
                end
                deleteat!(child_exprs, 2)
                if a1 isa Symbol && a1 === Symbol("@__dot__")
                    child_exprs[1] = Symbol("@.")
                elseif a1 isa Expr && nargs === 2 && a1.args[2] === Symbol("@__dot__")
                    child_exprs[1] = Expr(a1.head, a1.args[1], Symbol("@."))
                elseif a1 isa GlobalRef && a1.mod === Core
                    # Syntax-introduced macrocalls are listed here for reference.  We
                    # probably don't need to convert these.
                    if a1.name === Symbol("@cmd")
                    elseif a1.name === Symbol("@doc") && nargs === 4 # two macro args only
                        # Single-arg @doc is a lookup not corresponding to K"doc"
                        # Revise sometimes calls @doc with three args, but probably shouldn't
                        st_k = K"doc"
                        child_exprs = child_exprs[2:3]
        - source: "code"
          path: "JuliaLowering/src/compat.jl"
          loc: "406-422"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/compat.jl#L406-L422"
          snippet: |
            elseif e.head === :do
                # Expr:
                # (do (call f args...) (-> (tuple lam_args...) (block ...)))
                # SyntaxTree:
                # (call f args... (do (tuple lam_args...) (block ...)))
                if e.args[1].head === :macrocall
                    st_k = K"macrocall"
                    callargs = collect_expr_parameters(e.args[1], 3)
                    if callargs[2] isa LineNumberNode
                        src = callargs[2]
                    end
                    deleteat!(callargs, 2)
                else
                    callargs = collect_expr_parameters(e.args[1], 2)
                    st_k = K"call"
                end
                child_exprs = Any[callargs..., Expr(:do_lambda, e.args[2].args...)]
  secondary_effects:
    - effect: "Macrocall names now carry the '@' prefix as identifiers throughout the SyntaxTree, which changes match patterns for utilities that search for specific macros (e.g., @SyntaxTree, @ast_)."
      mechanism: |
        _green_to_ast() converts K"macro_name"/K"StrMacroName"/K"CmdMacroName" into K"Identifier" with @-prefixed name_val  [syntax_graph.jl:889-906]
        -> expand_forms_1() operates on the identifier directly during macro expansion  [macro_expansion.jl:155-183]
        -> _find_SyntaxTree_macro() now matches name.name_val == "@SyntaxTree" instead of "SyntaxTree"  [syntax_graph.jl:576-593]
        -> format_ir_for_test() special-cases @ast_ by checking for Identifier "@ast_"  [test/utils.jl:150-158]
      downstream_surfaces:
        - "JuliaLowering SyntaxTree utilities (macro search and test harnesses)"
        - "Tools pattern-matching SyntaxTree kinds for macro names"
      likelihood: "high"
      impact: "medium"
    - effect: "Expr compatibility lowering emits macrocall nodes that contain escaped @-prefixed identifiers (instead of K\"macro_name\" nodes), changing legacy macrocall shape accepted by expr_to_syntaxtree."
      mechanism: |
        _insert_convert_expr() handles Expr(:macrocall, ...) by directly rewriting @__dot__ and leaving macro name as an identifier  [compat.jl:262-274]
        -> tests assert escaped macro names appear as K"Identifier" "@mac" in the SyntaxTree  [test/compat.jl:494-608]
      downstream_surfaces:
        - "Legacy macro producers emitting Expr(:macrocall, ...)"
        - "Downstream AST transforms that expect K\"macro_name\" wrappers"
      likelihood: "high"
      impact: "medium"
    - effect: "Error message highlighting for macro-not-found errors shifts slightly because the macro name node now includes the '@' prefix in its span."
      mechanism: |
        MacroExpansionError highlights the source range of the macro name expression.
        Before: macro_name node spans just the identifier (e.g., "m_not_exist")
        After: K"Identifier" "@m_not_exist" includes '@' in its span
        -> error caret in macros_ir.jl test shifted: "#              └──────────┘" instead of "#               └─────────┘"
      downstream_surfaces:
        - "Error message display formatting"
        - "Tools parsing error output for macro location"
      likelihood: "high"
      impact: "low"
    - effect: "Fixes edge case where nested macros like @static inside @preserve failed (JuliaLowering.jl/issues/121) because macro name reconstruction happened too late."
      mechanism: |
        Before: fixup_macro_name was called during macro expansion, which could miss @-prefixing
                when macros were nested in certain patterns (e.g., GC.@preserve @static ...)
        After: _green_to_ast performs reconstruction before any expansion, ensuring consistent naming
        -> Test added to verify: GC.@preserve @static if true @__MODULE__ else end
      downstream_surfaces:
        - "Nested macro patterns involving @static, @__dot__, @preserve"
        - "VersionNumber macro patterns (v\"1.14\" inside @preserve)"
      likelihood: "high"
      impact: "high"
      evidence:
        - source: "test"
          path: "JuliaLowering/test/macros.jl"
          loc: "350-356"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/test/macros.jl#L350-L356"
          snippet: |
            # JuliaLowering.jl/issues/121
            @test JuliaLowering.include_string(test_mod, """
            GC.@preserve @static if true @__MODULE__ else end
            """) isa Module
            @test JuliaLowering.include_string(test_mod, """
            GC.@preserve @static if true v"1.14" else end
            """) isa VersionNumber
  compatibility:
    internal_api:
      - field: "SyntaxTree node kinds for macro names"
        change: "K\"macro_name\"/K\"StrMacroName\"/K\"CmdMacroName\" are normalized to K\"Identifier\" with @-prefixed name_val during SyntaxGraph lowering."
        affected_tools:
          - tool: "JuliaLowering SyntaxTree utilities"
            usage: "_find_SyntaxTree_macro expects Identifier name_val == \"@SyntaxTree\" when matching macrocall nodes."
          - tool: "JuliaLowering test harness"
            usage: "format_ir_for_test checks kind(ex[1]) == K\"Identifier\" && ex[1].name_val == \"@ast_\" for macro handling."
        evidence:
          - source: "code"
            path: "JuliaLowering/src/syntax_graph.jl"
            loc: "576-593"
            url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/src/syntax_graph.jl#L576-L593"
            snippet: |
              if firstline == line && kind(c) == K"macrocall" && begin
                          name = c[1]
                          if kind(name) == K"."
                              name = name[2]
                          end
                          @assert kind(name) == K"Identifier"
                          name.name_val == "@SyntaxTree"
                      end
          - source: "code"
            path: "JuliaLowering/test/utils.jl"
            loc: "150-158"
            url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/test/utils.jl#L150-L158"
            snippet: |
              function format_ir_for_test(mod, case)
                  ex = parsestmt(SyntaxTree, case.input)
                  try
                      if (kind(ex) == K"macrocall" && kind(ex[1]) == K"Identifier" &&
                          ex[1].name_val == "@ast_")
                          # Total hack, until @ast_ can be implemented in terms of new-style
                          # macros.
                          ex = Base.eval(mod, Expr(ex))
                      end
    behavioral:
      - change: "Expr-to-SyntaxTree compatibility now expects escaped macro names to appear as @-prefixed identifiers (e.g., \"@mac\") rather than K\"macro_name\" wrappers."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/compat.jl"
            loc: "494-609"
            url: "https://github.com/JuliaLang/julia/blob/f163ed8c/JuliaLowering/test/compat.jl#L494-L609"
            snippet: |
              # `@mac x` with macro name escaped
              @test JuliaLowering.expr_to_syntaxtree(Expr(:macrocall, esc(Symbol("@mac")), nothing, :x)) ≈
                  @ast_ [K"macrocall"
                      [K"escape" "@mac"::K"Identifier"]
                      "x"::K"Identifier"
                  ]

              # `@mac x` with macro name escaped
              @test JuliaLowering.expr_to_syntaxtree(
                  Expr(:macrocall, esc(Expr(:(.), :A, QuoteNode(Symbol("@mac")))), nothing, :x)
              ) ≈ @ast_ [K"macrocall"
                  [K"escape"
                      [K"."
                          "A"::K"Identifier"
                          "@mac"::K"Identifier"
                      ]
                  ]
                  "x"::K"Identifier"
              ]
  performance:
    compile_time:
      - description: "Removes one AST traversal pass (fixup_macro_name) from macro expansion."
        impact: "ESTIMATED: Negligible positive impact - one fewer tree walk per macro expansion."
    runtime: []
  compatibility_improvements:
    - description: "Stdlib precompilation compatibility improved from 38/52 to 40/52 non-sysimage stdlibs."
      evidence:
        - source: "test"
          path: "test/JuliaLowering_stdlibs.jl"
          loc: "1-17"
          url: "https://github.com/JuliaLang/julia/blob/f163ed8c/test/JuliaLowering_stdlibs.jl#L1-L17"
          snippet: |
            # known precompilation failures under JL (reduced from 14 to 12 entries)
            const INCOMPATIBLE_STDLIBS = String[
                "InteractiveUtils"
                "LazyArtifacts"
                "LibGit2"
                "Pkg"
                "REPL"
                "REPLExt"
                "SparseArrays"
                "SparseArraysExt"
                "Statistics"
                "SuiteSparse"
                "TOML"
                "Test"
            ]
  risk:
    level: "medium"
    rationale:
      - "Macro name nodes are normalized earlier, which can break downstream SyntaxTree pattern matching in tooling that relied on K\"macro_name\"/StrMacroName/CmdMacroName nodes."
      - "Changes affect macro expansion hygiene and compat lowering paths that are widely exercised (macrocalls, @__dot__, @cmd)."
  open_questions:
    - "Are there downstream packages (CSTParser/JET extensions) that rely on K\"macro_name\" or Str/CmdMacroName nodes from JuliaLowering SyntaxTree output?"
    - "Do any macro tooling paths rely on name strings without '@' (e.g., 'SyntaxTree' vs '@SyntaxTree') outside the updated helpers?"
  recommendations:
    - "Update downstream SyntaxTree visitors to treat macro names as K\"Identifier\" with '@' prefix, including dotted macro paths."
    - "Audit macro-related utilities for string comparisons to ensure they match '@macro' names (e.g., @SyntaxTree, @ast_)."
    - "When converting Expr(:macrocall, ...) in tooling, avoid reintroducing K\"macro_name\" nodes; use identifiers to align with the new lowering pipeline."
