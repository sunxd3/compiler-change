schema_version: "1.0"
pr:
  number: 60226
  title: "[JuliaLowering] Fix handling of unnamed args in `@generated` functions"
  url: "https://github.com/JuliaLang/julia/pull/60226"
  author: "topolarity"
  labels:
    - "compiler:lowering"
  merged_at: "2025-11-24T23:23:21Z"
  merge_commit_sha: "47c627152131e11562fef655d4d329c3fb001300"
  diff_url: "https://github.com/JuliaLang/julia/pull/60226.diff"
scope:
  files_touched:
    - "JuliaLowering/src/desugaring.jl"
    - "JuliaLowering/src/runtime.jl"
    - "JuliaLowering/test/functions.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "MacroExpansion"
    - "Lowering"
    - "ScopeResolution"
analysis:
  intent:
    summary: "Fix JuliaLowering for @generated methods with unnamed arguments by synthesizing unique stub names (#arg{i}#) and correcting bugs in non-SyntaxTree return value handling. Required to get Dates pre-compiling with JuliaLowering."
    issue_links: []
  direct_changes:
    - summary: 'Introduce a helper that assigns deterministic placeholder names ("#arg{i}#") to unnamed arguments (BindingId) so generated-function stubs avoid repeated "#unused#" names.'
      component: "JuliaLowering/src/desugaring.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "2537-2545"
          url: "https://github.com/JuliaLang/julia/blob/47c627152131e11562fef655d4d329c3fb001300/JuliaLowering/src/desugaring.jl#L2537-L2545"
          snippet: |
            function stub_argname(n::SyntaxTree, i)
                if kind(n) == K"Identifier"
                    return n.name_val::String
                elseif kind(n) == K"BindingId"
                    # flisp lowering calls these unnamed arguments "#unused#", but JL does
                    # not accept that as a repeated argument name
                    return "#arg" * string(i) * "#"
                else @assert false "Unexpected argument kind: $(kind(n))" end
            end
        - source: "code"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "2572-2576"
          url: "https://github.com/JuliaLang/julia/blob/47c627152131e11562fef655d4d329c3fb001300/JuliaLowering/src/desugaring.jl#L2572-L2576"
          snippet: |
            [K"call"
                "svec"::K"core"
                "#self#"::K"Symbol"
                (stub_argname(n,i)::K"Symbol"(n) for (i,n) in enumerate(arg_names[2:end]))...
            ]
    - summary: "Fix three bugs in non-SyntaxTree return value handling: use correct context (ctx1), correct source reference (g.srcref), and correct value variable (ex0). Original code used undefined variables 'ctx', 'ex', and 'expanded'."
      component: "JuliaLowering/src/runtime.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/runtime.jl"
          loc: "341-343"
          url: "https://github.com/JuliaLang/julia/blob/47c627152131e11562fef655d4d329c3fb001300/JuliaLowering/src/runtime.jl#L341-L343"
          snippet: |
            else
                ex0 = @ast ctx1 g.srcref ex0::K"Value"
            end
        - source: "diff"
          path: "JuliaLowering/src/runtime.jl"
          loc: "342"
          url: "https://github.com/JuliaLang/julia/pull/60226/files#diff-runtime"
          snippet: |
            # Before (buggy):
            #   ex0 = @ast ctx ex expanded::K"Value"
            # After (fixed):
            #   ex0 = @ast ctx1 g.srcref ex0::K"Value"
            # Fixes: ctx->ctx1, ex->g.srcref, expanded->ex0
    - summary: "Add a regression test ensuring generated functions with unnamed arguments execute correctly under JuliaLowering."
      component: "JuliaLowering/test/functions.jl"
      evidence:
        - source: "test"
          path: "JuliaLowering/test/functions.jl"
          loc: "516-524"
          url: "https://github.com/JuliaLang/julia/blob/47c627152131e11562fef655d4d329c3fb001300/JuliaLowering/test/functions.jl#L516-L524"
          snippet: |
            @test JuliaLowering.include_string(test_mod, """
            begin
                @generated function f_gen_unnamed_args(::Type{T}, y, ::Type{U}) where {T, U}
                    return (T, y, U)
                end

                f_gen_unnamed_args(Int, UInt8(3), Float64)
            end
            """) == (Int, UInt8, Float64)
  secondary_effects:
    - effect: 'Unnamed arguments in @generated methods no longer collide on "#unused#" and can be lowered without duplicate-argument errors.'
      mechanism: |
        expand_function_generator(...)  [desugaring.jl:2490]
          -> stub_argname(n,i)  [desugaring.jl:2537-2544]
            returns "#arg{i}#" for BindingId unnamed args
          -> GeneratedFunctionStub(argnames = svec("#self#", stub_argname(...)))  [desugaring.jl:2571-2576]
          -> GeneratedFunctionStub runtime uses g.argnames to synthesize lambda binders
             in lowering scope resolution  [runtime.jl:354-360]
      downstream_surfaces:
        - "@generated functions in Base/stdlib and packages that include unnamed Type parameters"
        - "JuliaLowering users that precompile stdlibs (e.g., Dates)"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "GeneratedFunctionStub.argnames"
        change: 'Unnamed arguments now appear as synthesized "#arg{i}#" placeholders instead of repeated "#unused#".'
        affected_tools:
          - tool: "JuliaLowering internal lowering"
            usage: "runtime.jl uses g.argnames to create lambda argument bindings via adopt_scope."
        evidence:
          - source: "code"
            path: "JuliaLowering/src/runtime.jl"
            loc: "354-360"
            url: "https://github.com/JuliaLang/julia/blob/47c627152131e11562fef655d4d329c3fb001300/JuliaLowering/src/runtime.jl#L354-L360"
            snippet: |
              ex2 = @ast ctx2 ex0 [K"lambda"(is_toplevel_thunk=false, toplevel_pure=true)
                  [K"block"
                      (adopt_scope(string(n)::K"Identifier", layer) for n in g.argnames)...
                  ]
                  [K"block"
                      (adopt_scope(string(n)::K"Identifier", layer) for n in g.spnames)...
                  ]
                  ex2
              ]
    behavioral:
      - change: "Generated functions with unnamed arguments are accepted by JuliaLowering and evaluate correctly."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/functions.jl"
            loc: "516-524"
            url: "https://github.com/JuliaLang/julia/blob/47c627152131e11562fef655d4d329c3fb001300/JuliaLowering/test/functions.jl#L516-L524"
            snippet: |
              @test JuliaLowering.include_string(test_mod, """
              begin
                  @generated function f_gen_unnamed_args(::Type{T}, y, ::Type{U}) where {T, U}
                      return (T, y, U)
                  end

                  f_gen_unnamed_args(Int, UInt8(3), Float64)
              end
              """) == (Int, UInt8, Float64)
  performance:
    compile_time: []
    runtime: []
  risk:
    level: "low"
    rationale:
      - "Change is localized to generated-function stub argument naming in desugaring.jl and bug fixes for non-SyntaxTree returns in runtime.jl."
      - "The runtime.jl fix corrects previously broken code paths (undefined variables ctx, ex, expanded)."
      - "New test exercises the previously failing case of unnamed arguments in @generated methods."
      - "Required for Dates stdlib precompilation with JuliaLowering."
  open_questions: []
  recommendations:
    - 'Downstream tooling that inspects GeneratedFunctionStub.argnames should tolerate synthesized "#arg{i}#" placeholders for unnamed arguments.'
    - "If diagnostic tooling depends on source locations for generated code, validate that g.srcref is now propagated for non-SyntaxTree returns."
