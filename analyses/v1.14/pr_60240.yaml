schema_version: "1.0"

pr:
  number: 60240
  title: "REPL: Use event to orchestrate precompilation script"
  url: "https://github.com/JuliaLang/julia/pull/60240"
  diff_url: "https://github.com/JuliaLang/julia/pull/60240.diff"
  author: "IanButterworth"
  labels:
    - "building"
    - "REPL"
  created_at: "2025-11-25T12:54:35Z"
  merged_at: "2025-12-05T20:36:05Z"
  merge_commit_sha: "443ece3094de43696047f3e2c7091aa16f6a5a5a"

scope:
  files_touched:
    - "stdlib/REPL/src/LineEdit.jl"
    - "stdlib/REPL/src/REPL.jl"
    - "stdlib/REPL/src/precompile.jl"
    - "test/precompile.jl"
  components:
    - "REPL"
    - "LineEdit"
    - "Precompilation"
  pipeline_stages: []

analysis:
  intent:
    summary: |
      Fixes a race condition in REPL precompilation (#60239) where the precompile script
      would desynchronize from the REPL prompts on slower systems (particularly macOS x86).
      The previous approach used string matching to detect when the REPL was ready for input
      by scanning output for prompt strings ("julia> ", "pkg> ", etc.). This was fragile
      because output could arrive in chunks that split prompt strings, causing the script
      to miss prompts or proceed before the REPL was actually ready.

      The new approach adds a `prompt_ready_event` field to both `MIState` and `LineEditREPL`
      structs, using Julia's `Base.Event` synchronization primitive. The REPL's `prompt!`
      function now calls `notify(s.prompt_ready_event)` immediately after the prompt is
      activated, providing a reliable synchronization point that doesn't depend on parsing
      terminal output.
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/60239"
    quoted_from_pr: |
      - Add a prompt `Base.event` to REPL and use it to orchestrate the precompile script,
        rather than awkwardly reading for prompt prints

  direct_changes:
    - summary: "Added prompt_ready_event field to MIState struct"
      component: "LineEdit"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/LineEdit.jl"
          loc: "71-92"
          url: "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib/REPL/src/LineEdit.jl#L71-L92"
          snippet: |
            mutable struct MIState
                interface::ModalInterface
                active_module::Module
                current_module::Module
                current_mode::TextInterface
                aborted::Bool
                mode_state::IdDict{TextInterface,ModeState}
                kill_ring::Vector{String}
                kill_idx::Int
                previous_key::Vector{Char}
                key_repeats::Int
                last_action::Symbol
                current_action::Symbol
                async_channel::Channel{Function}
                line_modify_lock::Base.ReentrantLock
                hint_generation_lock::Base.ReentrantLock
                n_keys_pressed::Int
                # Optional event that gets notified each time the prompt is ready for input
                prompt_ready_event::Union{Nothing, Base.Event}
            end

            MIState(i, mod, c, a, m) = MIState(i, mod, mod, c, a, m, String[], 0, Char[], 0, :none, :none, Channel{Function}(), Base.ReentrantLock(), Base.ReentrantLock(), 0, nothing)

    - summary: "Added prompt ready notification in prompt! function"
      component: "LineEdit"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/LineEdit.jl"
          loc: "2980-2986"
          url: "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib/REPL/src/LineEdit.jl#L2980-L2986"
          snippet: |
            try
                activate(prompt, s, term, term)
                # Notify that prompt is ready for input
                if s.prompt_ready_event !== nothing
                    notify(s.prompt_ready_event)
                end
                old_state = mode(s)

    - summary: "Added prompt_ready_event field to LineEditREPL struct"
      component: "REPL"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/REPL.jl"
          loc: "761-795"
          url: "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib/REPL/src/REPL.jl#L761-L795"
          snippet: |
            mutable struct LineEditREPL <: AbstractREPL
                t::TextTerminal
                hascolor::Bool
                prompt_color::String
                input_color::String
                answer_color::String
                shell_color::String
                help_color::String
                pkg_color::String
                history_file::Bool
                in_shell::Bool
                in_help::Bool
                envcolors::Bool
                waserror::Bool
                specialdisplay::Union{Nothing,AbstractDisplay}
                options::Options
                mistate::Union{MIState,Nothing}
                last_shown_line_infos::Vector{Tuple{String,Int}}
                interface::ModalInterface
                backendref::REPLBackendRef
                frontend_task::Task
                # Optional event to notify when the prompt is ready (used by precompilation)
                prompt_ready_event::Union{Nothing, Base.Event}
                function LineEditREPL(t,hascolor,prompt_color,input_color,answer_color,shell_color,help_color,pkg_color,history_file,in_shell,in_help,envcolors)
                    opts = Options()
                    opts.hascolor = hascolor
                    if !hascolor
                        opts.beep_colors = [""]
                    end
                    r = new(t,hascolor,prompt_color,input_color,answer_color,shell_color,help_color,pkg_color,history_file,in_shell,
                        in_help,envcolors,false,nothing, opts, nothing, Tuple{String,Int}[])
                    r.prompt_ready_event = nothing
                    r
                end
            end

    - summary: "Added event propagation from repl to mistate in run_frontend"
      component: "REPL"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/REPL.jl"
          loc: "1670-1676"
          url: "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib/REPL/src/REPL.jl#L1670-L1676"
          snippet: |
            repl.backendref = backend
            repl.mistate = LineEdit.init_state(terminal(repl), interface)
            # Copy prompt_ready_event from repl to mistate (used by precompilation)
            if isdefined(repl, :prompt_ready_event) && repl.prompt_ready_event !== nothing
                repl.mistate.prompt_ready_event = repl.prompt_ready_event
            end
            run_interface(terminal(repl), interface, repl.mistate)

    - summary: "Rewrote precompile script to use event-based synchronization"
      component: "Precompilation"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/precompile.jl"
          loc: "52-69"
          url: "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib/REPL/src/precompile.jl#L52-L69"
          snippet: |
            # Event that REPL notifies each time it's ready for input (autoreset so each wait blocks until next notify)
            prompt_ready = Base.Event(true)
            # Event to signal that REPL.activate has been called
            activate_done = Base.Event()

            atreplinit() do repl
                # Set the prompt_ready_event on the repl - run_frontend will copy it to mistate
                if repl isa REPL.LineEditREPL
                    repl.prompt_ready_event = prompt_ready
                end
                # Start async task to wait for first prompt then activate the module
                t = @async begin
                    wait(prompt_ready)
                    REPL.activate(REPL.Precompile; interactive_utils=false)
                    notify(activate_done)
                end
                Base.errormonitor(t)
            end
        - source: "code"
          path: "stdlib/REPL/src/precompile.jl"
          loc: "170-183"
          url: "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib/REPL/src/precompile.jl#L170-L183"
          snippet: |
            # Input our script
            precompile_lines = split(repl_script::String, '\n'; keepempty=false)
            for l in precompile_lines
                # If the line ends with a CTRL_C, don't write an extra newline
                # CTRL_C cancels input but doesn't print a new prompt, so don't wait
                if endswith(l, CTRL_C)
                    write(ptm, l)
                    sleep(0.1)  # Brief pause to let CTRL_C be processed
                else
                    write(ptm, l, "\n")
                    # Wait for REPL to signal it's ready for next input
                    wait(prompt_ready)
                end
            end

    - summary: "Improved error detection with line-by-line checking"
      component: "Precompilation"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/precompile.jl"
          loc: "28-44"
          url: "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib/REPL/src/precompile.jl#L28-L44"
          snippet: |
            function check_output()
                str = String(take!(copy(debug_output)))
                for line in eachline(IOBuffer(str))
                    if occursin("ERROR:", line) && !any(e -> occursin(e, line), allowed_errors)
                        println(stderr, """
                        ========================================================================
                        ERROR: Unexpected error during REPL precompilation
                        ========================================================================
                        Debug output:
                        ------------------------------------------------------------------------
                        """)
                        println(stderr, str)
                        println(stderr, "========================================================================")
                        error("REPL precompilation encountered unexpected error: $line")
                    end
                end
            end

    - summary: "Relaxed test assertion to handle potential prefix output"
      component: "Test"
      evidence:
        - source: "code"
          path: "test/precompile.jl"
          loc: "1421-1422"
          url: "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/test/precompile.jl#L1421-L1422"
          snippet: |
            # BEFORE: @test read(fname, String) == "Iterators\n"
            # AFTER:
            @test endswith(read(fname, String), "Iterators\n")

  pipeline_impact: []

  secondary_effects:
    - effect: "New public-ish API surface for REPL prompt synchronization"
      mechanism: |
        The new prompt_ready_event fields on MIState and LineEditREPL provide a
        mechanism for external code to synchronize with REPL prompt availability.

        Data flow:
        1. External code creates Base.Event(true) (autoreset event)
        2. Sets repl.prompt_ready_event = event before REPL starts
        3. run_frontend() copies event to repl.mistate.prompt_ready_event [REPL.jl:1673-1674]
        4. prompt!() calls notify(s.prompt_ready_event) after activate() [LineEdit.jl:2983-2984]
        5. External code calls wait(event) to block until prompt is ready

        This pattern could be useful for:
        - Automated REPL testing frameworks
        - REPL automation tools
        - Interactive debugging tools
      downstream_surfaces:
        - "Testing frameworks that automate REPL interaction"
        - "IDE integrations with Julia REPL"
        - "Automated documentation systems"
      likelihood: "low"
      impact: "low"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/LineEdit.jl"
          loc: "2980-2984"
          url: "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib/REPL/src/LineEdit.jl#L2980-L2984"
          snippet: |
            activate(prompt, s, term, term)
            # Notify that prompt is ready for input
            if s.prompt_ready_event !== nothing
                notify(s.prompt_ready_event)
            end

    - effect: "Simplified output handling removes BufferStream dependency"
      mechanism: |
        The old implementation used a BufferStream (output_copy) to capture and
        parse REPL output looking for prompt strings. The new implementation
        eliminates this complexity:

        BEFORE (removed):
        - output_copy = Base.BufferStream()
        - readuntil(output_copy, JULIA_PROMPT) pattern
        - Multiple prompt string constants (JULIA_PROMPT, PKG_PROMPT, SHELL_PROMPT, HELP_PROMPT)
        - Complex string matching loop with sleep() calls

        AFTER:
        - Simple wait(prompt_ready) calls
        - No prompt string parsing needed
        - More deterministic timing

        This removes ~50 lines of fragile string-matching code and eliminates
        race conditions that occurred when prompt strings were split across
        multiple read operations.
      downstream_surfaces:
        - "Precompilation reliability"
        - "Build system stability"
      likelihood: "high"
      impact: "medium"
      evidence:
        - source: "diff"
          path: "stdlib/REPL/src/precompile.jl"
          snippet: |
            # REMOVED code pattern:
            JULIA_PROMPT = "julia> "
            ACTIVATED_JULIA_PROMPT = "(REPL.Precompile) julia> "
            PKG_PROMPT = "pkg> "
            SHELL_PROMPT = "shell> "
            HELP_PROMPT = "help?> "

            # And the complex matching loop:
            while !eof(output_copy)
                strbuf *= String(readavailable(output_copy))
                occursin(ACTIVATED_JULIA_PROMPT, strbuf) && break
                occursin(PKG_PROMPT, strbuf) && break
                occursin(SHELL_PROMPT, strbuf) && break
                occursin(HELP_PROMPT, strbuf) && break
                sleep(0.01)
            end

    - effect: "Changed error handling to capture full debug output on failure"
      mechanism: |
        The error reporting changed from immediately logging errors with @error
        to capturing output in an IOBuffer and only printing on failure.

        BEFORE:
        - check_errors() called after each readuntil
        - Used @error with Base.PrecompilableError() and exit(1)

        AFTER:
        - check_output() called once at end
        - Prints full debug_output buffer on error
        - Uses regular error() for clearer stack traces

        This provides better debugging information when precompilation fails.
      downstream_surfaces:
        - "Build debugging"
        - "CI/CD error diagnosis"
      likelihood: "medium"
      impact: "low"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/precompile.jl"
          loc: "28-44"
          snippet: |
            function check_output()
                str = String(take!(copy(debug_output)))
                for line in eachline(IOBuffer(str))
                    if occursin("ERROR:", line) && !any(e -> occursin(e, line), allowed_errors)
                        println(stderr, """
                        ========================================================================
                        ERROR: Unexpected error during REPL precompilation
                        ========================================================================
                        Debug output:
                        ------------------------------------------------------------------------
                        """)
                        println(stderr, str)
                        error("REPL precompilation encountered unexpected error: $line")
                    end
                end
            end

  compatibility:
    internal_api:
      - summary: "New field added to MIState struct"
        evidence:
          - source: "code"
            path: "stdlib/REPL/src/LineEdit.jl"
            loc: "88-92"
            url: "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib/REPL/src/LineEdit.jl#L88-L92"
            snippet: |
              # Optional event that gets notified each time the prompt is ready for input
              prompt_ready_event::Union{Nothing, Base.Event}
              end

              MIState(i, mod, c, a, m) = MIState(i, mod, mod, c, a, m, String[], 0, Char[], 0, :none, :none, Channel{Function}(), Base.ReentrantLock(), Base.ReentrantLock(), 0, nothing)
        notes: |
          Field is optional (Union with Nothing) and defaults to nothing in the constructor.
          Existing code that doesn't use the new field is unaffected.
          Code that directly constructs MIState or inspects its fields may need updates,
          but this struct is internal to REPL stdlib.
      - summary: "New field added to LineEditREPL struct"
        evidence:
          - source: "code"
            path: "stdlib/REPL/src/REPL.jl"
            loc: "782-793"
            url: "https://github.com/JuliaLang/julia/blob/443ece3094de43696047f3e2c7091aa16f6a5a5a/stdlib/REPL/src/REPL.jl#L782-L793"
            snippet: |
              # Optional event to notify when the prompt is ready (used by precompilation)
              prompt_ready_event::Union{Nothing, Base.Event}
              function LineEditREPL(t,hascolor,prompt_color,input_color,answer_color,shell_color,help_color,pkg_color,history_file,in_shell,in_help,envcolors)
                  opts = Options()
                  opts.hascolor = hascolor
                  if !hascolor
                      opts.beep_colors = [""]
                  end
                  r = new(t,hascolor,prompt_color,input_color,answer_color,shell_color,help_color,pkg_color,history_file,in_shell,
                      in_help,envcolors,false,nothing, opts, nothing, Tuple{String,Int}[])
                  r.prompt_ready_event = nothing
                  r
              end
        notes: |
          Same pattern as MIState: field is optional, defaults to nothing.
          Non-breaking for code that doesn't explicitly use the new field.
    behavioral:
      - summary: "Precompilation script timing is now deterministic"
        evidence:
          - source: "analysis"
            snippet: |
              The old script used sleep(0.01) calls and string matching, leading
              to non-deterministic timing that could fail on slow systems.

              The new script uses proper event synchronization:
              - wait(prompt_ready) blocks until REPL signals readiness
              - sleep(0.1) only used for CTRL_C handling (specific timing requirement)

              This makes precompilation more reliable across different system speeds.

  performance:
    compile_time: []
    runtime:
      - summary: "Improved REPL precompilation reliability and potentially speed"
        evidence:
          - source: "analysis"
            snippet: |
              ESTIMATED impact on precompilation time:

              - Removes multiple sleep(0.01) calls from the critical path
              - Event-based wait() is more efficient than polling with sleep()
              - No string parsing overhead for prompt detection

              Net effect: Likely slightly faster precompilation on fast systems,
              dramatically more reliable on slow systems.

              No impact on regular REPL usage - the prompt_ready_event is only
              used when explicitly set (defaults to nothing).

  tests:
    changed_files:
      - "test/precompile.jl"
    new_behavior_assertions:
      - "Test assertion relaxed: endswith() instead of exact equality for namespace warning output"
    coverage_gaps:
      - "No explicit unit tests for prompt_ready_event mechanism"
      - "Precompilation script tested implicitly during Julia build"

  risk:
    level: "low"
    rationale:
      - "No compiler internals affected - purely REPL/stdlib change"
      - "New fields are optional with nothing defaults - non-breaking"
      - "Event-based synchronization is a proven pattern in Julia"
      - "Fixes real race condition that caused CI failures (#60239)"
      - "Changes are isolated to REPL precompilation infrastructure"
      - "No effect on type inference, lowering, optimization, or codegen"

  open_questions:
    - "Should prompt_ready_event be documented for external use, or remain internal?"

  recommendations:
    - "No action required for downstream compiler packages (JET, Enzyme, GPUCompiler)"
    - "This PR has zero impact on compiler internals or optimization"
    - "Testing tools that interact with REPL could potentially leverage the new event mechanism"

classification:
  type: "stdlib-infrastructure"
  compiler_relevant: false
  breaking_change: false
  requires_downstream_action: false

notes: |
  This PR is NOT a compiler change - it fixes REPL precompilation infrastructure.

  The core problem was a race condition in how the precompilation script detected
  when the REPL was ready for the next line of input. The old approach:

  1. Read terminal output into a buffer
  2. Scan for prompt strings like "julia> " or "pkg> "
  3. When found, send next input line

  This failed when:
  - Output arrived in chunks that split prompt strings
  - System was slow and output/input got out of sync
  - Multiple prompts printed rapidly (like after REPL.activate)

  The new approach uses Julia's Base.Event synchronization primitive:

  1. Create autoreset event: prompt_ready = Base.Event(true)
  2. Set repl.prompt_ready_event = prompt_ready before starting REPL
  3. REPL's prompt!() calls notify(event) when prompt is displayed
  4. Precompile script calls wait(event) before sending each input

  The autoreset property (Event(true)) means each wait() blocks until the
  next notify(), providing clean one-to-one synchronization.

  Key files and their roles:
  - LineEdit.jl: Contains MIState struct (REPL modal interface state)
  - REPL.jl: Contains LineEditREPL struct and run_frontend()
  - precompile.jl: Contains repl_workload() that drives precompilation

  The prompt_ready_event field propagation:
  1. atreplinit() sets repl.prompt_ready_event [precompile.jl:60]
  2. run_frontend() copies to repl.mistate.prompt_ready_event [REPL.jl:1673-1674]
  3. prompt!() reads from s.prompt_ready_event and calls notify() [LineEdit.jl:2983-2984]

  This PR has absolutely NO impact on:
  - Type inference or abstract interpretation
  - Lowering or IR generation
  - SSA optimization passes
  - Code generation or LLVM
  - OpaqueClosure handling
  - Generated functions
  - World age or method invalidation
  - Any internal compiler APIs

  It is safe to ignore for all compiler-focused downstream package analysis.

reviewer_verification:
  reviewed_at: "2026-01-22"
  reviewer: "Independent analysis"
  verification_method: |
    1. Checked out merge commit 443ece3094de43696047f3e2c7091aa16f6a5a5a
    2. Verified all code snippets against actual source files
    3. Searched for all usages of prompt_ready_event and atreplinit
    4. Traced data flow through run_frontend and prompt! functions

  line_number_corrections:
    - file: "stdlib/REPL/src/REPL.jl"
      original_loc: "1688-1694"
      corrected_loc: "1670-1676"
      description: "run_frontend event propagation code"
    - file: "stdlib/REPL/src/REPL.jl"
      original_loc: "764-797"
      corrected_loc: "761-795"
      description: "LineEditREPL struct definition"
    - file: "stdlib/REPL/src/LineEdit.jl"
      original_loc: "88-92"
      corrected_loc: "71-92"
      description: "MIState struct needed full definition for context"

  snippet_accuracy:
    - path: "stdlib/REPL/src/LineEdit.jl"
      loc: "88-89"
      status: "VERIFIED - prompt_ready_event field at lines 88-89"
    - path: "stdlib/REPL/src/LineEdit.jl"
      loc: "2980-2986"
      status: "VERIFIED - prompt! notification code at lines 2980-2986"
    - path: "stdlib/REPL/src/REPL.jl"
      loc: "761-795"
      status: "VERIFIED - LineEditREPL struct with new field"
    - path: "stdlib/REPL/src/REPL.jl"
      loc: "1670-1676"
      status: "VERIFIED - run_frontend event copy code"
    - path: "stdlib/REPL/src/precompile.jl"
      loc: "52-69"
      status: "VERIFIED - Event creation and atreplinit setup"
    - path: "stdlib/REPL/src/precompile.jl"
      loc: "170-183"
      status: "VERIFIED - Script input loop with wait(prompt_ready)"
    - path: "stdlib/REPL/src/precompile.jl"
      loc: "28-44"
      status: "VERIFIED - check_output() function"
    - path: "test/precompile.jl"
      loc: "1421-1422"
      status: "VERIFIED - Test assertion change to endswith()"

  additional_findings:
    - finding: "MIState usage is extensive within REPL stdlib"
      evidence: |
        Found 100+ references to MIState within stdlib/REPL/src/LineEdit.jl.
        MIState is used as the type for state parameter in virtually all
        keymap handler functions and editing operations.
      impact: "Internal only - all usages are within the REPL stdlib"

    - finding: "prompt_ready_event usage is localized"
      evidence: |
        grep for prompt_ready_event found exactly 10 occurrences:
        - LineEdit.jl:89 (field definition)
        - LineEdit.jl:2983-2984 (notify in prompt!)
        - REPL.jl:783 (field definition)
        - REPL.jl:792 (initialization to nothing)
        - REPL.jl:1672-1674 (copy from repl to mistate)
        - precompile.jl:58,60 (setting the event)
      impact: "Confirms change is well-encapsulated"

    - finding: "atreplinit hook pattern is documented"
      evidence: |
        stdlib/REPL/docs/src/index.md contains 10+ examples of atreplinit usage.
        The hook is a public API for customizing REPL initialization.
      impact: "The precompile.jl usage follows established patterns"

  missed_effects: "None identified"

  downstream_impact_assessment:
    compiler_packages:
      - package: "JET.jl"
        impact: "None - does not interact with REPL internals"
      - package: "Enzyme.jl"
        impact: "None - does not interact with REPL internals"
      - package: "GPUCompiler.jl"
        impact: "None - does not interact with REPL internals"

    repl_adjacent_packages:
      - package: "OhMyREPL.jl"
        impact: "Low - uses atreplinit but does not depend on MIState fields"
      - package: "RemoteREPL.jl"
        impact: "Low - might use LineEditREPL but new field is optional"
      - package: "julia-vscode extension"
        impact: "None - uses separate evaluation mechanism"

  risk_assessment_verification:
    original_level: "low"
    verified_level: "low"
    rationale: |
      1. Change is purely additive (new optional fields defaulting to nothing)
      2. No existing behavior is modified unless code explicitly uses new fields
      3. The fix addresses a real race condition that caused CI failures
      4. Well-tested through the precompilation workload
      5. No impact on compiler, codegen, or type inference

  conclusion: |
    The original analysis is accurate and comprehensive. Minor line number
    corrections were made to ensure precise references. The PR correctly
    fixes issue #60239 by replacing fragile string-based prompt detection
    with proper event-based synchronization. The change is safe and has
    no impact on downstream compiler tooling.
