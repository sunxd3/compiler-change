schema_version: "1.0"
pr:
  number: 60198
  title: "JuliaSyntax tokenize.jl:  don‘t hardcode unicode ops range"
  url: "https://github.com/JuliaLang/julia/pull/60198"
  author: "pthariensflame"
  labels:
    - "parser"
  merged_at: "2025-11-22T04:18:46Z"
  merge_commit_sha: "9b7f64d6d0b73560d253745dd218a557aa901727"
  diff_url: "https://github.com/JuliaLang/julia/pull/60198.diff"
scope:
  files_touched:
    - "JuliaSyntax/src/julia/tokenize.jl"
  components:
    - "JuliaSyntax"
  pipeline_stages:
    - "Parsing"
analysis:
  intent:
    summary: "Use the JuliaSyntax BEGIN_UNICODE_OPS/END_UNICODE_OPS token range instead of a hardcoded Unicode operator span when deciding which operators can take suffixes."
    issue_links:
      - "https://github.com/JuliaLang/JuliaSyntax.jl/pull/404"
  direct_changes:
    - summary: "optakessuffix now checks the BEGIN_UNICODE_OPS/END_UNICODE_OPS token range rather than a literal Unicode codepoint span, keeping suffix eligibility aligned with the operator kind table."
      component: "JuliaSyntax tokenization"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/julia/tokenize.jl"
          loc: "153-177"
          url: "https://github.com/JuliaLang/julia/blob/9b7f64d6d0b73560d253745dd218a557aa901727/JuliaSyntax/src/julia/tokenize.jl#L153-L177"
          snippet: |
            function optakessuffix(k)
                (K"BEGIN_OPS" <= k <= K"END_OPS") &&
                !(
                    k == K"..." ||
                    K"BEGIN_ASSIGNMENTS" <= k <= K"END_ASSIGNMENTS" ||
                    k == K"?"   ||
                    k == K"<:"  ||
                    k == K">:"  ||
                    k == K"&&"  ||
                    k == K"||"  ||
                    k == K"in"  ||
                    k == K"isa" ||
                    k == K"≔"   ||
                    k == K"⩴"   ||
                    k == K":"   ||
                    k == K".."  ||
                    k == K"$"   ||
                    k == K"::"  ||
                    k == K"where" ||
                    k == K"."   ||
                    k == K"!"   ||
                    k == K".'"  ||
                    k == K"->"  ||
                    K"BEGIN_UNICODE_OPS" <= k <= K"END_UNICODE_OPS"
                )
            end
        - source: "code"
          path: "JuliaSyntax/src/julia/tokenize.jl"
          loc: "153-177"
          url: "https://github.com/JuliaLang/julia/blob/9af9b15844705c0d82fcf3ba4878e5e0e2983982/JuliaSyntax/src/julia/tokenize.jl#L153-L177"
          snippet: |
            function optakessuffix(k)
                (K"BEGIN_OPS" <= k <= K"END_OPS") &&
                !(
                    k == K"..." ||
                    K"BEGIN_ASSIGNMENTS" <= k <= K"END_ASSIGNMENTS" ||
                    k == K"?"   ||
                    k == K"<:"  ||
                    k == K">:"  ||
                    k == K"&&"  ||
                    k == K"||"  ||
                    k == K"in"  ||
                    k == K"isa" ||
                    k == K"≔"   ||
                    k == K"⩴"   ||
                    k == K":"   ||
                    k == K".."  ||
                    k == K"$"   ||
                    k == K"::"  ||
                    k == K"where" ||
                    k == K"."   ||
                    k == K"!"   ||
                    k == K".'"  ||
                    k == K"->"  ||
                    K"¬" <= k <= K"∜"
                )
            end
    - summary: "Tokenizer tests already assert that suffixed operators round-trip through tokenization, providing a concrete behavior baseline for this change."
      component: "JuliaSyntax tests"
      evidence:
        - source: "test"
          path: "JuliaSyntax/test/tokenize.jl"
          loc: "883-892"
          url: "https://github.com/JuliaLang/julia/blob/9b7f64d6d0b73560d253745dd218a557aa901727/JuliaSyntax/test/tokenize.jl#L883-L892"
          snippet: |
            @testset "suffixed op" begin
                s = "+¹"
                @test is_operator(tok(s, 1).kind)
                @test untokenize(collect(tokenize(s))[1], s) == s
            end
  secondary_effects:
    - effect: "When the BEGIN_UNICODE_OPS/END_UNICODE_OPS list is extended in kinds.jl, optakessuffix will automatically treat new Unicode operator kinds as suffix-capable without needing another hardcoded span update."
      mechanism: |
        optakessuffix(k) uses BEGIN_UNICODE_OPS/END_UNICODE_OPS [tokenize.jl:153-176]
          -> emit(l, kind) sets RawToken suffix when optakessuffix(kind) is true [tokenize.jl:430-439]
          -> parser predicates like is_plain_equals() branch on is_suffixed(token) [parser.jl:225-231]
      downstream_surfaces:
        - "JuliaSyntax tokenization / parse flags"
      likelihood: "medium"
      impact: "low"
  compatibility:
    internal_api: []
    behavioral: []
  performance:
    compile_time: []
    runtime: []
  risk:
    level: "low"
    rationale:
      - "The change replaces a hardcoded Unicode operator range with existing token kind sentinels, so it is unlikely to affect current operator classification."
  open_questions: []
  recommendations:
    - "If the BEGIN_UNICODE_OPS list changes in the future, consider adding or updating tokenizer tests that exercise suffixed operators in the new range."
