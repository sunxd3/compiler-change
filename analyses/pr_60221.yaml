schema_version: "1.0"
pr:
  number: 60221
  title: "JuliaSyntax: fix anonymous function parsing"
  url: "https://github.com/JuliaLang/julia/pull/60221"
  author: "IanButterworth"
  labels:
    - "parser"
    - "bugfix"
  merged_at: "2025-12-19T12:34:45Z"
  merge_commit_sha: "6e246b21c8f834390e8e911fef9a0c844a7d970e"
  diff_url: "https://github.com/JuliaLang/julia/pull/60221.diff"
scope:
  files_touched:
    - "JuliaSyntax/src/julia/parser.jl"
    - "JuliaSyntax/test/parser.jl"
  components:
    - "JuliaSyntax"
  pipeline_stages:
    - "Parsing"
analysis:
  intent:
    summary: "Fix parsing ambiguity where a newline after a parenthesized function name/argument list was incorrectly treated as a continuation for a call or property access, ensuring anonymous function signatures parse correctly."
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/60202"
  direct_changes:
    - summary: "When parsing a function signature that starts with parentheses, explicitly detect whether a newline immediately follows the closing `)` and avoid skipping it when deciding if the construct is a call or an anonymous-function parameter list."
      component: "JuliaSyntax parser"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/julia/parser.jl"
          loc: "2211-2244"
          url: "https://github.com/JuliaLang/julia/blob/6e246b21c8f834390e8e911fef9a0c844a7d970e/JuliaSyntax/src/julia/parser.jl#L2211-L2244"
          snippet: |
            # When an initial parenthesis is present, we need to distinguish
            # between
            # * The function name in parens, followed by (args...)
            # * An anonymous function argument list in parens
            # * The whole function declaration, in parens
            bump(ps, TRIVIA_FLAG)
            is_empty_tuple = peek(ps, skip_newlines=true) == K")"
            opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
                _parsed_call = was_eventually_call(ps)
                _maybe_grouping_parens = !had_commas && !had_splat && num_semis == 0 && num_subexprs == 1
                # Check if there's a newline between `)` and the next `(` or `.`.
                # We need to find where `)` is and check what immediately follows it.
                # If peek(1, skip_newlines=false) is `)`, we're directly before it.
                # Otherwise there's whitespace/newline before `)`.
                next_token_pos = if peek(ps, 1, skip_newlines=false) == K")"
                    # Directly before ), token after ) is at 2
                    2
                else
                    # There's whitespace before ), so ) is at 2
                    # and what follows ) is at 3
                    3
                end
                token_after_paren = peek(ps, next_token_pos, skip_newlines=false)
                # If token_after_paren is a newline, this is an anonymous function
                has_newline_after_paren = _maybe_grouping_parens && token_after_paren == K"NewlineWs"
                # Get the next significant token to determine if we need to parse a call
                next_kind = peek(ps, 2, skip_newlines=_maybe_grouping_parens && !has_newline_after_paren)
                _needs_parse_call = next_kind âˆˆ KSet"( ."
                _is_anon_func = (!_needs_parse_call && !_parsed_call) || had_commas
                return (needs_parameters      = _is_anon_func,
                        is_anon_func          = _is_anon_func,
                        parsed_call           = _parsed_call,
                        needs_parse_call      = _needs_parse_call,
                        maybe_grouping_parens = _maybe_grouping_parens)
            end
    - summary: "Add parser tests that lock in the corrected behavior for anonymous functions when a newline appears between the closing parameter paren and the function body or a following empty tuple expression."
      component: "JuliaSyntax tests"
      evidence:
        - source: "test"
          path: "JuliaSyntax/test/parser.jl"
          loc: "613-616"
          url: "https://github.com/JuliaLang/julia/blob/6e246b21c8f834390e8e911fef9a0c844a7d970e/JuliaSyntax/test/parser.jl#L613-L616"
          snippet: |
            "function (x) body end"=>  "(function (tuple-p x) (block body))"
            "function (x)\n    body\nend"=>  "(function (tuple-p x) (block body))"
            "function (x)\n() end" =>  "(function (tuple-p x) (block (tuple-p)))"
            "function (x,y) end"   =>  "(function (tuple-p x y) (block))"
  secondary_effects:
    - effect: "Anonymous function signatures are favored when a newline directly follows a parenthesized head, preventing accidental parsing as a call or property access continuation."
      mechanism: |
        parse_resword() dispatches to parse_function_signature() for `function`  [parser.jl:1977-1981]
          -> parse_function_signature() uses parse_brackets() to inspect the parenthesized head  [parser.jl:2211-2244]
          -> token_after_paren == K"NewlineWs" gates skip_newlines=false when peeking the next token  [parser.jl:2233-2237]
          -> _needs_parse_call becomes false, so _is_anon_func becomes true  [parser.jl:2238-2240]
      downstream_surfaces:
        - "JuliaSyntax parse trees for function definitions"
        - "Macro tooling or formatters that depend on JuliaSyntax AST shape"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "JuliaSyntax parser decisions in parse_function_signature"
        change: "Now treats a newline immediately after a parenthesized head as evidence for anonymous-function parameters, altering the emitted AST for those inputs."
        affected_tools:
          - tool: "JuliaSyntax consumers"
            usage: "Downstream tools that rely on JuliaSyntax AST output for formatting or linting will observe different trees for `function (x)\n...` constructs."
    behavioral:
      - change: "`function (x)\n() end` and similar newline-separated forms parse as anonymous-function definitions with the expected body, rather than being interpreted as a call continuation."
        risk: "low"
  performance:
    compile_time:
      - impact: "ESTIMATED: a couple of extra peek operations per function signature with parenthesized heads; expected negligible cost."
    runtime: []
  risk:
    level: "low"
    rationale:
      - "Change is confined to JuliaSyntax parsing of function signatures and guarded by new tests."
      - "No changes to lowering, inference, or codegen stages."
  open_questions:
    - "Should comments or other trivia between `)` and the following token be treated like newlines for this ambiguity resolution?"
  recommendations:
    - "Downstream parser consumers should add or update tests for newline-separated anonymous function signatures to reflect the new AST shape."
