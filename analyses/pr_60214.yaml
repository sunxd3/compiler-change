schema_version: "1.0"
pr:
  number: 60214
  title: "Finish PR: inference: fix the ptrfree field check"
  url: "https://github.com/JuliaLang/julia/pull/60214"
  author: "MasonProtter"
  labels: []
  merged_at: "2025-11-24T18:22:57Z"
  merge_commit_sha: "08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f"
  diff_url: "https://github.com/JuliaLang/julia/pull/60214.diff"
scope:
  files_touched:
    - "Compiler/src/abstractinterpretation.jl"
    - "Compiler/src/tfuncs.jl"
    - "Compiler/test/effects.jl"
  components:
    - "Compiler/src/abstractinterpretation.jl"
    - "Compiler/src/tfuncs.jl"
    - "Compiler/test/effects.jl"
  pipeline_stages:
    - "TypeInference"
    - "Effects"
analysis:
  intent:
    summary: "Make the pointer-free field check in inference robust to types without a layout to avoid incorrect consistency effects during allocation inference."
    issue_links:
      - "https://github.com/JuliaLang/julia/pull/57550"
  direct_changes:
    - summary: "`is_field_pointerfree` now asserts `dt.layout` is a `Ptr{Cvoid}` before comparing against `C_NULL`, guarding layout-less `DataType`s prior to indexing `DataTypeFieldDesc`."
      component: "Compiler/src/abstractinterpretation.jl"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "3082-3086"
          url: "https://github.com/JuliaLang/julia/blob/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler/src/abstractinterpretation.jl#L3082-L3086"
          snippet: |
            function is_field_pointerfree(dt::DataType, fidx::Int)
                dt.layout::Ptr{Cvoid} == C_NULL && return false
                DataTypeFieldDesc(dt)[fidx].isptr && return false
                ft = fieldtype(dt, fidx)
                return ft isa DataType && datatype_pointerfree(ft)
            end
    - summary: "Allocation effect consistency still depends on whether any uninitialized field is pointer-free, using `is_field_pointerfree` during `:new` evaluation."
      component: "Compiler/src/abstractinterpretation.jl"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "3089-3103"
          url: "https://github.com/JuliaLang/julia/blob/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler/src/abstractinterpretation.jl#L3089-L3103"
          snippet: |
            function abstract_eval_new(interp::AbstractInterpreter, e::Expr, sstate::StatementState,
                                       sv::AbsIntState)
                ð•ƒáµ¢ = typeinf_lattice(interp)
                rt, _... = instanceof_tfunc(abstract_eval_value(interp, e.args[1], sstate, sv), true)
                ut = unwrap_unionall(rt)
                exct = Union{ErrorException,TypeError}
                if isa(ut, DataType) && !isabstracttype(ut)
                    ismutable = ismutabletype(ut)
                    fcount = datatype_fieldcount(ut)
                    nargs = length(e.args) - 1
                    has_any_uninitialized = fcount === nothing || (fcount > nargs &&
                        any(i::Int->is_field_pointerfree(ut, i), (nargs+1):fcount))
                    if has_any_uninitialized
                        # allocation with undefined field is inconsistent always
                        consistent = ALWAYS_FALSE
                    elseif ismutable
                        # mutable allocation isn't `:consistent`, but we still have a chance that
                        # return type information later refines the `:consistent`-cy of the method
                        consistent = CONSISTENT_IF_NOTRETURNED
                    else
                        consistent = ALWAYS_TRUE # immutable allocation is consistent
                    end
    - summary: "Effects tests cover pointer-free field inference by checking that a nested `Maybe{Some{Base.RefValue{Int}}}` allocation is still considered consistent."
      component: "Compiler/test/effects.jl"
      evidence:
        - source: "test"
          path: "Compiler/test/effects.jl"
          loc: "263-271"
          url: "https://github.com/JuliaLang/julia/blob/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler/test/effects.jl#L263-L271"
          snippet: |
            @test Base.infer_effects() do
                Maybe{String}()
            end |> Compiler.is_consistent
            @test Base.infer_effects() do
                Maybe{String}()[]
            end |> Compiler.is_consistent
            @test Base.infer_effects() do
                Maybe{Some{Base.RefValue{Int}}}()
            end |> Compiler.is_consistent
  secondary_effects:
    - effect: "Prevents `abstract_eval_new` from attempting to index `DataTypeFieldDesc` on layout-less `DataType`s, avoiding `UndefRefError` during effect inference for `:new` expressions."
      mechanism: |
        abstract_eval_statement_expr(..., e::Expr)  [abstractinterpretation.jl:3435-3442]
          -> abstract_eval_new(...)  [abstractinterpretation.jl:3089-3103]
            computes has_any_uninitialized using is_field_pointerfree
          -> is_field_pointerfree(dt, fidx)  [abstractinterpretation.jl:3082-3086]
            checks dt.layout::Ptr{Cvoid} == C_NULL
          -> DataTypeFieldDesc(dt)  [base/runtime_internals.jl:747-752]
            would throw UndefRefError when dt.layout == C_NULL
      downstream_surfaces:
        - "Core.Compiler effect inference (`Compiler.is_consistent`)"
        - "Allocation consistency decisions for `:new`"
      likelihood: "medium"
      impact: "low"
  compatibility:
    internal_api: []
    behavioral:
      - change: "Effect inference no longer risks a layout-related error when evaluating `:new` on types without a layout; instead it treats such fields as not pointer-free."
        evidence:
          - source: "code"
            path: "Compiler/src/abstractinterpretation.jl"
            loc: "3082-3086"
            url: "https://github.com/JuliaLang/julia/blob/08c3853539a6ee69cb0ff32c85c19fad3c6f7b9f/Compiler/src/abstractinterpretation.jl#L3082-L3086"
            snippet: |
              function is_field_pointerfree(dt::DataType, fidx::Int)
                  dt.layout::Ptr{Cvoid} == C_NULL && return false
                  DataTypeFieldDesc(dt)[fidx].isptr && return false
                  ft = fieldtype(dt, fidx)
                  return ft isa DataType && datatype_pointerfree(ft)
              end
  performance:
    compile_time:
      - impact: "ESTIMATED: negligible; a single type assertion and early exit before `DataTypeFieldDesc` indexing."
    runtime:
      - impact: "No runtime effect; logic is confined to inference-time consistency checks."
  risk:
    level: "low"
    rationale:
      - "Change is localized to inference-time pointer-free checks and only adds a stricter layout guard."
  open_questions: []
  recommendations:
    - "Consider adding a targeted test that exercises a layout-less `DataType` to confirm the guard avoids `UndefRefError` during effect inference."
