schema_version: "1.0"

pr:
  number: 60061
  title: "allow finding stdlibs that are normal packages in the manifest but are now stdlibs"
  url: "https://github.com/JuliaLang/julia/pull/60061"
  author: "KristofferC"
  labels:
    - "packages"
    - "backport 1.10"
  merged_at: "2025-11-10T21:32:35Z"
  merge_commit_sha: "6fddac850a00441cc5d3833cc3c441132cd49a5f"
  diff_url: "https://github.com/JuliaLang/julia/pull/60061.diff"
  status: "reverted_and_relanded"
  related_prs:
    - number: 60104
      description: "Re-land of this PR with test fix for cross-platform DEPOT_PATH separator"
    - number: 56148
      description: "Similar 'identify' fallback for stdlib dependencies that this 'locate' fallback complements"

scope:
  files_touched:
    - "base/loading.jl"
    - "test/loading.jl"
    - "test/project/deps/BadStdlibDeps2/Manifest.toml"
    - "test/project/deps/BadStdlibDeps2/Project.toml"
  components:
    - "PackageLoading"
  pipeline_stages:
    - "PackageResolution"

analysis:
  intent:
    summary: |
      This PR fixes a package loading issue where stdlibs cannot be loaded when they appear
      in a manifest as normal packages (with a git-tree-sha1 hash) from an older Julia version
      where they were not yet stdlibs.

      When Julia encounters a package in the manifest with a git-tree-sha1 but cannot find it
      in any DEPOT_PATH (because the hash is invalid or from an old version), it returns
      `missing` as a sentinel to stop looking. Before this fix, `locate_package_env` would
      immediately fail. Now, if the package is actually a stdlib (verified by `is_stdlib(pkg)`),
      it falls back to loading from `Sys.STDLIB`.

      This is the "locate" version of a similar "identify" fallback added in PR #56148 for
      `identify_package_env`. Together, these changes ensure backward compatibility when
      loading projects created with older Julia versions where certain JLLs and dependencies
      have since become stdlibs.

      NOTE: This PR was later reverted and relanded as PR #60104 due to a test issue with
      cross-platform DEPOT_PATH separator handling. The core loading.jl changes are identical.
    issue_links: []

  direct_changes:
    - summary: "Add stdlib fallback check before stopping on missing manifest path"
      component: "PackageLoading"
      evidence:
        - source: "diff"
          path: "base/loading.jl"
          loc: "463-470"
          url: "https://github.com/JuliaLang/julia/blob/6fddac850a00441cc5d3833cc3c441132cd49a5f/base/loading.jl#L463-L470"
          snippet: |
            path = manifest_uuid_path(env, pkg)
            # missing is used as a sentinel to stop looking further down in envs
            if path === missing
                # Before stopping, try stdlib fallback
                is_stdlib(pkg) && @goto stdlib_fallback
                path = nothing
                @goto done
            end

    - summary: "Add stdlib_fallback label for stdlib loading path"
      component: "PackageLoading"
      evidence:
        - source: "code"
          path: "base/loading.jl"
          loc: "476-486"
          url: "https://github.com/JuliaLang/julia/blob/6fddac850a00441cc5d3833cc3c441132cd49a5f/base/loading.jl#L476-L486"
          snippet: |
            @label stdlib_fallback
            # Allow loading of stdlibs if the name/uuid are given
            # e.g. if they have been explicitly added to the project/manifest
            mbypath = manifest_uuid_path(Sys.STDLIB, pkg)
            if mbypath isa String
                path = mbypath
                env' = Sys.STDLIB
                @goto done
            end

    - summary: "Add test for loading stdlib with git-tree-sha1 in manifest"
      component: "Tests"
      evidence:
        - source: "test"
          path: "test/loading.jl"
          loc: "1547-1555"
          url: "https://github.com/JuliaLang/julia/blob/6fddac850a00441cc5d3833cc3c441132cd49a5f/test/loading.jl#L1547-L1555"
          snippet: |
            mktempdir() do depot
                # This manifest has a LibGit2 entry that has a LibGit2_jll with a git-tree-sha1
                # which simulates an old manifest where LibGit2_jll was not a stdlib
                badmanifest_test_dir2 = joinpath(@__DIR__, "project", "deps", "BadStdlibDeps2")
                @test success(addenv(
                    `$(Base.julia_cmd()) --project=$badmanifest_test_dir2 --startup-file=no -e 'using LibGit2'`,
                    "JULIA_DEPOT_PATH" => depot * Base.Filesystem.pathsep(),
                ))
            end
          note: "This test has a bug - missing cross-platform separator after pathsep(). Fixed in PR #60104."

    - summary: "Add test manifest simulating old Julia version where LibGit2_jll was not a stdlib"
      component: "Tests"
      evidence:
        - source: "test_file"
          path: "test/project/deps/BadStdlibDeps2/Manifest.toml"
          loc: "16-23"
          url: "https://github.com/JuliaLang/julia/blob/6fddac850a00441cc5d3833cc3c441132cd49a5f/test/project/deps/BadStdlibDeps2/Manifest.toml#L16-L23"
          snippet: |
            # This is an stdlib but intentionally has a git-tree-sha1 because
            # we are emulating that the manifest comes from a version where
            # LibGit2_jll was not an stdlib
            [[deps.LibGit2_jll]]
            deps = ["Artifacts", "LibSSH2_jll", "Libdl", "MbedTLS_jll"]
            git-tree-sha1 = "1111111111111111111111111111111111111111"
            uuid = "e37daf67-58a4-590a-8e99-b0245dd2ffc5"
            version = "1.8.0+0"

  secondary_effects:
    - effect: "Backward compatibility for manifests from older Julia versions"
      mechanism: |
        When Julia transitions packages from external JLLs to bundled stdlibs, old manifests
        may still reference these packages with git-tree-sha1 hashes. The loading flow is:

        1. locate_package_env() iterates through load_path()  [loading.jl:462]
        2. For each env, calls manifest_uuid_path(env, pkg)  [loading.jl:463]
        3. manifest_uuid_path -> explicit_manifest_uuid_path  [loading.jl:826]
        4. explicit_manifest_uuid_path -> explicit_manifest_entry_path  [loading.jl:1125]
        5. explicit_manifest_entry_path finds git-tree-sha1, searches DEPOT_PATH  [loading.jl:1164-1170]
           hash = SHA1(hash)
           for slug in (version_slug(uuid, hash), version_slug(uuid, hash, 4))
               for depot in DEPOT_PATH
                   path = joinpath(depot, "packages", pkg.name, slug)
                   ispath(path) && return entry_path(abspath(path), pkg.name, entryfile)
               end
           end
        6. Package not found in any depot, returns `missing`  [loading.jl:1173-1174]
           # no depot contains the package, return missing to stop looking
           return missing
        7. BEFORE FIX: locate_package_env sets path=nothing and fails
        8. AFTER FIX: if is_stdlib(pkg), jumps to stdlib_fallback  [loading.jl:467]
        9. Loads from Sys.STDLIB instead  [loading.jl:482]
      downstream_surfaces:
        - "Projects using LibGit2, LibGit2_jll, or other packages that became stdlibs"
        - "Package ecosystems with old Manifest.toml files from previous Julia versions"
      likelihood: "high"
      impact: "high"

    - effect: "is_stdlib verification ensures only actual stdlibs use the fallback"
      mechanism: |
        The is_stdlib(pkgid) function verifies a package is really a stdlib:  [loading.jl:314-326]

        function is_stdlib(pkgid::PkgId)
            pkgid.name in readdir(Sys.STDLIB) || return false
            stdlib_root = joinpath(Sys.STDLIB, pkgid.name)
            project_file = locate_project_file(stdlib_root)
            if project_file isa String
                d = parsed_toml(project_file)
                uuid = get(d, "uuid", nothing)
                if uuid !== nothing
                    return UUID(uuid) == pkgid.uuid
                end
            end
            return false
        end

        This check ensures:
        1. Package name exists in Sys.STDLIB directory
        2. Package has a Project.toml with matching UUID
        3. Only legitimate stdlibs can use this fallback path
      downstream_surfaces:
        - "Security: prevents arbitrary packages from hijacking stdlib paths"
      likelihood: "high"
      impact: "low"

    - effect: "Interaction with existing stdlib fallback in explicit_manifest_entry_path"
      mechanism: |
        There's already a stdlib fallback inside explicit_manifest_entry_path for packages
        WITHOUT a git-tree-sha1:  [loading.jl:1157-1162]

        if hash === nothing
            mbypath = manifest_uuid_path(Sys.STDLIB, pkg)
            if mbypath isa String && isfile(mbypath)
                return mbypath
            end
            return nothing
        end

        The NEW fallback in locate_package_env handles the case where:
        - Package HAS a git-tree-sha1 (old manifest format)
        - But that hash doesn't exist in any depot
        - explicit_manifest_entry_path returns `missing` (not `nothing`)

        These two fallbacks complement each other:
        - Old fallback: no git-tree-sha1 -> try stdlib
        - New fallback: git-tree-sha1 but missing from depot -> try stdlib
      downstream_surfaces:
        - "All package loading for stdlibs"
      likelihood: "high"
      impact: "medium"

    - effect: "Extension trigger insertion benefits from the fix"
      mechanism: |
        The insert_extension_triggers function calls locate_package_env:  [loading.jl:1511-1516]

        function insert_extension_triggers(pkg::PkgId)
            pkg.uuid === nothing && return
            path_env_loc = locate_package_env(pkg)
            path_env_loc === nothing && return
            path, env_loc = path_env_loc
            insert_extension_triggers(env_loc, pkg)
        end

        With this fix, extension triggers for stdlib-dependent packages will now be
        correctly discovered even when the manifest has old git-tree-sha1 references.
      downstream_surfaces:
        - "Package extensions depending on stdlibs"
      likelihood: "medium"
      impact: "low"

    - effect: "Multiple callers of locate_package benefit from this fix"
      mechanism: |
        The locate_package function wraps locate_package_env and is called by:

        1. require flow [loading.jl:2699]:
           path = locate_package(pkg, env)
           -> Used when loading packages via `using` or `import`

        2. precompilation flow [loading.jl:1882]:
           sourcepath::Union{String,Nothing}=Base.locate_package(pkg)
           -> Used to find source files during precompilation

        3. compilecache [loading.jl:3309]:
           path = locate_package(pkg)
           -> Used when creating precompilation cache

        4. stale cache checking [loading.jl:4196]:
           path = locate_package(req_key)
           -> Used to verify dependencies still exist

        All these code paths benefit from the stdlib fallback when loading
        packages that depend on stdlibs with outdated git-tree-sha1 entries.
      downstream_surfaces:
        - "Package loading via require"
        - "Precompilation"
        - "Cache validation"
      likelihood: "high"
      impact: "medium"

    - effect: "Caching behavior correctly preserves stdlib environment"
      mechanism: |
        The LOADING_CACHE stores results at the end of locate_package_env [loading.jl:493-494]:

        if cache !== nothing
            cache.located[(pkg, stopenv)] = path === nothing ? nothing : (path, something(env'))
        end

        When the stdlib_fallback path is taken:
        1. path is set to the stdlib path (a String)
        2. env' is set to Sys.STDLIB
        3. The cache correctly stores (stdlib_path, Sys.STDLIB)

        This means subsequent lookups for the same package will correctly
        return the stdlib location without re-executing the fallback logic.
      downstream_surfaces:
        - "Repeated package lookups during a loading session"
      likelihood: "high"
      impact: "low"

    - effect: "Relationship between BadStdlibDeps and BadStdlibDeps2 test cases"
      mechanism: |
        Two test fixtures demonstrate the complementary fallback mechanisms:

        BadStdlibDeps (from PR #56148):
        - LibGit2_jll has NO git-tree-sha1 (simulates package added to manifest
          but entry has no hash, which happens for stdlib-ified packages)
        - Tests the fallback in explicit_manifest_entry_path [loading.jl:1157-1162]
        - Falls back when hash === nothing

        BadStdlibDeps2 (this PR #60061):
        - LibGit2_jll HAS git-tree-sha1 = "1111111111111111111111111111111111111111"
        - Simulates old manifest where LibGit2_jll was a regular package
        - Tests the new fallback in locate_package_env [loading.jl:465-467]
        - Falls back when path === missing (hash exists but not in any depot)

        Together these cover both scenarios:
        - Old manifests that reference stdlibs without hashes (PR #56148)
        - Old manifests that reference stdlibs with stale hashes (this PR)
      downstream_surfaces:
        - "Test coverage for stdlib loading edge cases"
      likelihood: "high"
      impact: "low"

  compatibility:
    internal_api:
      - field: "locate_package_env control flow"
        change: "Added @goto stdlib_fallback branch when path === missing and is_stdlib(pkg)"
        affected_tools: []
    behavioral:
      - field: "Package loading for stdlibs with old manifest entries"
        change: "Now succeeds instead of failing when manifest has outdated git-tree-sha1"
        affected_tools: []

  performance:
    compile_time:
      - impact: "ESTIMATED: Negligible"
        details: |
          The added check is O(1) for the is_stdlib call's initial readdir check.
          Only executed when manifest_uuid_path returns `missing`, which is an error path.
          No impact on normal package loading performance.
    runtime:
      - impact: "ESTIMATED: None"
        details: |
          This change only affects the package loading/resolution phase.
          Once packages are loaded, there is no runtime impact.

  risk:
    level: "low"
    rationale:
      - "This is a backward compatibility fix that enables loading previously failing packages"
      - "The change is guarded by is_stdlib() which verifies the package is a legitimate stdlib"
      - "The existing stdlib_fallback code path is already well-tested"
      - "Comprehensive test case added that simulates the exact failure scenario"
      - "Only affects packages that would otherwise fail to load (missing sentinel)"
      - "NOTE: This PR was reverted due to test bug (not code bug) and relanded as PR #60104"

  open_questions:
    - question: "Why was this PR reverted and relanded as #60104?"
      resolved: true
      answer: |
        RESOLVED: The original test in PR #60061 had a bug in the JULIA_DEPOT_PATH handling:

        Original (buggy):
          "JULIA_DEPOT_PATH" => depot * Base.Filesystem.pathsep()

        Fixed in PR #60104:
          s = Sys.iswindows() ? ';' : ':'
          "JULIA_DEPOT_PATH" => string(depot * Base.Filesystem.pathsep(), s)

        The issue was that pathsep() returns the filesystem path separator (/ or \),
        but JULIA_DEPOT_PATH needs to be terminated with the PATH environment separator
        (: on Unix, ; on Windows) to indicate an empty second path entry. Without this,
        the test could fail on some platforms because the depot path wasn't properly
        isolated.

        The core loading.jl changes are identical between #60061 and #60104.

    - question: "What packages could trigger this fallback path?"
      resolved: true
      answer: |
        Any package that was converted from a regular package to a stdlib between
        Julia versions could trigger this. Examples include:
        - LibGit2_jll (tested in this PR)
        - Other JLL packages that became bundled
        - Future packages that may become stdlibs

    - question: "Is there a potential edge case if is_stdlib returns true but stdlib lookup fails?"
      resolved: true
      answer: |
        RESOLVED: Theoretically, if is_stdlib(pkg) returns true but manifest_uuid_path(Sys.STDLIB, pkg)
        does not return a String, the path variable would remain as `missing` when reaching @label done.
        At line 490, isfile_casesensitive(missing) would be called, which could cause an error.

        However, this cannot happen in practice because:
        1. is_stdlib(pkg) verifies: pkgid.name in readdir(Sys.STDLIB)
        2. is_stdlib(pkg) verifies: UUID from stdlib's Project.toml matches pkg.uuid
        3. manifest_uuid_path(Sys.STDLIB, pkg) calls implicit_manifest_uuid_path
        4. implicit_manifest_uuid_path searches the same directory structure

        If is_stdlib confirms the package exists in STDLIB with matching UUID, then
        manifest_uuid_path(Sys.STDLIB, pkg) will find it. The only way this could fail
        is if the STDLIB directory is modified between the two calls (race condition),
        which is not a realistic scenario.

        The code could theoretically be made more defensive by explicitly handling
        path === missing at the end, but this is not necessary in practice.

  recommendations:
    - "For users: No action required - this improves backward compatibility"
    - "For package authors: Consider updating Manifest.toml files to remove outdated git-tree-sha1 entries for stdlibs"
    - "For CI systems: May see reduced failures when testing against multiple Julia versions with shared manifests"
    - "For Julia developers: When reviewing, note this was superseded by PR #60104 with identical code changes"

changelog_entry:
  category: "Base/Loading"
  breaking: false
  summary: |
    Fixed package loading to correctly find stdlibs even when they appear in the manifest
    as regular packages with a git-tree-sha1 hash from older Julia versions where they
    were not yet bundled as stdlibs.
  downstream_impact: |
    This is a backward compatibility fix with no breaking changes. Projects with old
    Manifest.toml files that reference now-stdlib packages (like LibGit2_jll) will
    now load successfully instead of failing with "package not found" errors.
  note: "This PR was reverted and relanded as #60104 with a test fix. The core functionality is identical."

downstream_package_impact:
  Turing_jl: "none - package loading change, does not affect inference or AD"
  Enzyme_jl: "none - package loading change, does not affect differentiation"
  GPUCompiler: "none - package loading change, does not affect GPU code generation"
  JET: "none - package loading change, semantic analysis unaffected"
  IRTools: "none - package loading change, IR manipulation unaffected"
  Cassette: "none - package loading change, code transformation unaffected"

code_path_trace:
  locate_package_env_main_loop:
    description: "Main package location loop with new stdlib fallback"
    steps:
      - location: "base/loading.jl:461-488"
        url: "https://github.com/JuliaLang/julia/blob/6fddac850a00441cc5d3833cc3c441132cd49a5f/base/loading.jl#L461-L488"
        code: |
          else
              for env in load_path()
                  path = manifest_uuid_path(env, pkg)
                  # missing is used as a sentinel to stop looking further down in envs
                  if path === missing
                      # Before stopping, try stdlib fallback
                      is_stdlib(pkg) && @goto stdlib_fallback
                      path = nothing
                      @goto done
                  end
                  if path !== nothing
                      env' = env
                      @goto done
                  end
                  if !(loading_extension || precompiling_extension)
                      stopenv == env && break
                  end
              end
              @label stdlib_fallback
              # Allow loading of stdlibs if the name/uuid are given
              # e.g. if they have been explicitly added to the project/manifest
              mbypath = manifest_uuid_path(Sys.STDLIB, pkg)
              if mbypath isa String
                  path = mbypath
                  env' = Sys.STDLIB
                  @goto done
              end
          end
        explanation: |
          The main loop iterates through load_path() looking for the package.
          When manifest_uuid_path returns `missing` (package found but not in any depot),
          the new code checks is_stdlib(pkg) and jumps to stdlib_fallback if true.
          The stdlib_fallback tries to load from Sys.STDLIB as a last resort.

  explicit_manifest_entry_path_missing:
    description: "Where the missing sentinel is generated"
    steps:
      - location: "base/loading.jl:1164-1174"
        url: "https://github.com/JuliaLang/julia/blob/6fddac850a00441cc5d3833cc3c441132cd49a5f/base/loading.jl#L1164-L1174"
        code: |
          hash = SHA1(hash)
          # Keep the 4 since it used to be the default
          uuid = pkg.uuid::UUID # checked within `explicit_manifest_uuid_path`
          for slug in (version_slug(uuid, hash), version_slug(uuid, hash, 4))
              for depot in DEPOT_PATH
                  path = joinpath(depot, "packages", pkg.name, slug)
                  ispath(path) && return entry_path(abspath(path), pkg.name, entryfile)
              end
          end
          # no depot contains the package, return missing to stop looking
          return missing
        explanation: |
          When a package has a git-tree-sha1 in the manifest but cannot be found in any
          DEPOT_PATH, this function returns `missing` as a sentinel to indicate that
          further searching should stop. This is the trigger for the new stdlib fallback.

  is_stdlib_verification:
    description: "How is_stdlib verifies a package is a legitimate stdlib"
    steps:
      - location: "base/loading.jl:314-326"
        url: "https://github.com/JuliaLang/julia/blob/6fddac850a00441cc5d3833cc3c441132cd49a5f/base/loading.jl#L314-L326"
        code: |
          function is_stdlib(pkgid::PkgId)
              pkgid.name in readdir(Sys.STDLIB) || return false
              stdlib_root = joinpath(Sys.STDLIB, pkgid.name)
              project_file = locate_project_file(stdlib_root)
              if project_file isa String
                  d = parsed_toml(project_file)
                  uuid = get(d, "uuid", nothing)
                  if uuid !== nothing
                      return UUID(uuid) == pkgid.uuid
                  end
              end
              return false
          end
        explanation: |
          Verifies that a package is a stdlib by:
          1. Checking if the name exists in Sys.STDLIB directory
          2. Finding its Project.toml
          3. Verifying the UUID matches
          This prevents non-stdlibs from using the fallback path.

  complete_flow_trace:
    description: "Complete call chain from require to stdlib fallback"
    steps:
      - location: "base/loading.jl:2699"
        function: "_require_prelocked"
        code: "path = locate_package(pkg, env)"
        next: "locate_package"

      - location: "base/loading.jl:514-515"
        function: "locate_package"
        code: "@lock require_lock _nothing_or_first(locate_package_env(pkg, stopenv))"
        next: "locate_package_env"

      - location: "base/loading.jl:463"
        function: "locate_package_env"
        code: "path = manifest_uuid_path(env, pkg)"
        next: "manifest_uuid_path"

      - location: "base/loading.jl:815-826"
        function: "manifest_uuid_path"
        code: "return explicit_manifest_uuid_path(project_file, pkg)"
        next: "explicit_manifest_uuid_path"

      - location: "base/loading.jl:1113-1125"
        function: "explicit_manifest_uuid_path"
        code: "return explicit_manifest_entry_path(manifest_file, pkg, entry)"
        next: "explicit_manifest_entry_path"

      - location: "base/loading.jl:1164-1174"
        function: "explicit_manifest_entry_path"
        code: |
          for slug in (version_slug(uuid, hash), version_slug(uuid, hash, 4))
              for depot in DEPOT_PATH
                  path = joinpath(depot, "packages", pkg.name, slug)
                  ispath(path) && return entry_path(abspath(path), pkg.name, entryfile)
              end
          end
          # no depot contains the package, return missing to stop looking
          return missing
        note: "Returns `missing` when package has git-tree-sha1 but not found in any depot"
        next: "back to locate_package_env"

      - location: "base/loading.jl:465-469"
        function: "locate_package_env (NEW CODE)"
        code: |
          if path === missing
              # Before stopping, try stdlib fallback
              is_stdlib(pkg) && @goto stdlib_fallback
              path = nothing
              @goto done
          end
        note: "NEW: Checks is_stdlib before giving up"
        next: "is_stdlib or stdlib_fallback"

      - location: "base/loading.jl:314-326"
        function: "is_stdlib"
        code: |
          pkgid.name in readdir(Sys.STDLIB) || return false
          stdlib_root = joinpath(Sys.STDLIB, pkgid.name)
          project_file = locate_project_file(stdlib_root)
          if project_file isa String
              d = parsed_toml(project_file)
              uuid = get(d, "uuid", nothing)
              if uuid !== nothing
                  return UUID(uuid) == pkgid.uuid
              end
          end
          return false
        note: "Verifies package is legitimate stdlib by name and UUID"
        next: "stdlib_fallback (if true)"

      - location: "base/loading.jl:479-487"
        function: "locate_package_env (stdlib_fallback)"
        code: |
          @label stdlib_fallback
          mbypath = manifest_uuid_path(Sys.STDLIB, pkg)
          if mbypath isa String
              path = mbypath
              env' = Sys.STDLIB
              @goto done
          end
        note: "Loads package from Sys.STDLIB directory"
        next: "done"

      - location: "base/loading.jl:489-497"
        function: "locate_package_env (done)"
        code: |
          @label done
          if path !== nothing && !isfile_casesensitive(path)
              path = nothing
          end
          if cache !== nothing
              cache.located[(pkg, stopenv)] = path === nothing ? nothing : (path, something(env'))
          end
          path === nothing && return nothing
          return path, something(env')
        note: "Caches and returns result"

test_coverage:
  new_tests:
    - file: "test/loading.jl"
      lines: "1547-1555"
      description: "Test loading stdlib with old git-tree-sha1 in manifest"
      code: |
        mktempdir() do depot
            # This manifest has a LibGit2 entry that has a LibGit2_jll with a git-tree-sha1
            # which simulates an old manifest where LibGit2_jll was not a stdlib
            badmanifest_test_dir2 = joinpath(@__DIR__, "project", "deps", "BadStdlibDeps2")
            @test success(addenv(
                `$(Base.julia_cmd()) --project=$badmanifest_test_dir2 --startup-file=no -e 'using LibGit2'`,
                "JULIA_DEPOT_PATH" => depot * Base.Filesystem.pathsep(),
            ))
        end
      note: "Contains a bug - DEPOT_PATH separator issue fixed in PR #60104"

  test_fixture:
    - file: "test/project/deps/BadStdlibDeps2/Manifest.toml"
      description: "Test manifest with LibGit2_jll having a fake git-tree-sha1"
      key_entry: |
        # This is an stdlib but intentionally has a git-tree-sha1 because
        # we are emulating that the manifest comes from a version where
        # LibGit2_jll was not an stdlib
        [[deps.LibGit2_jll]]
        deps = ["Artifacts", "LibSSH2_jll", "Libdl", "MbedTLS_jll"]
        git-tree-sha1 = "1111111111111111111111111111111111111111"
        uuid = "e37daf67-58a4-590a-8e99-b0245dd2ffc5"
        version = "1.8.0+0"

    - file: "test/project/deps/BadStdlibDeps2/Project.toml"
      description: "Simple project file depending on LibGit2"
      content: |
        [deps]
        LibGit2 = "76f85450-5226-5b5a-8eaa-529ad045b433"

reviewer_notes:
  initial_reviewer: "automated_analysis"
  initial_date: "2026-01-21"
  verification_method: |
    1. Read PR metadata from pr-archive/JuliaLang_julia/pr_60061.json
    2. Read full source context of base/loading.jl from Julia repository
    3. Traced call chains through locate_package_env, manifest_uuid_path, explicit_manifest_entry_path
    4. Read test case and test fixture to understand expected behavior
    5. Analyzed is_stdlib function to understand security implications
    6. Verified the fix complements existing stdlib fallback in explicit_manifest_entry_path
    7. Compared with PR #60104 to understand why this PR was reverted and relanded
  findings:
    - "This is a backward compatibility fix for loading stdlibs from old manifests"
    - "The fix is well-guarded by is_stdlib() verification"
    - "Complements existing stdlib fallback for packages without git-tree-sha1"
    - "Test case specifically simulates the problematic scenario"
    - "Low risk change that enables previously failing package loads"
    - "PR was reverted due to test bug (DEPOT_PATH separator) not code bug"
    - "Core code changes are identical to PR #60104"
  confidence: "high"
  rationale: |
    The PR is a targeted fix for a specific backward compatibility issue. When packages
    that are now stdlibs (like LibGit2_jll) appear in old manifests with git-tree-sha1
    hashes, Julia would fail to find them in DEPOT_PATH and return a `missing` sentinel.
    The fix checks if such packages are actually stdlibs and falls back to loading from
    Sys.STDLIB. This is a safe change because:
    1. It only triggers on the error path (path === missing)
    2. It's guarded by is_stdlib() verification
    3. The stdlib loading path is already well-tested
    4. It matches the existing pattern from PR #56148 for identify_package_env

    The PR was reverted and relanded as #60104 solely due to a test bug with
    cross-platform DEPOT_PATH handling, not due to any issue with the core fix.

  secondary_reviewer: "independent_analysis"
  secondary_date: "2026-01-21"
  secondary_verification_method: |
    1. Cloned Julia repository and checked out merge commit 6fddac850a00441cc5d3833cc3c441132cd49a5f
    2. Independently traced all code paths in locate_package_env function
    3. Verified all callers of locate_package and locate_package_env using rg search
    4. Compared BadStdlibDeps and BadStdlibDeps2 test fixtures to understand complementary scenarios
    5. Analyzed LOADING_CACHE behavior to verify caching is correct
    6. Examined is_stdlib function to verify it guarantees successful stdlib lookup
    7. Checked for potential edge cases where path could remain as `missing`
    8. Verified PR #60104 diff to confirm identical loading.jl changes
    9. Read isaccessiblefile and isfile_casesensitive to understand error handling
  secondary_findings:
    - "Initial analysis was accurate and thorough"
    - "Added detail: Multiple callers of locate_package (require, precompilation, compilecache, stale checking) all benefit"
    - "Added detail: LOADING_CACHE correctly stores (path, Sys.STDLIB) when fallback is used"
    - "Added detail: BadStdlibDeps tests no-hash case (PR #56148), BadStdlibDeps2 tests stale-hash case (this PR)"
    - "Added detail: Theoretical edge case where path stays `missing` cannot occur in practice due to is_stdlib guarantees"
    - "Confirmed: is_stdlib verification ensures manifest_uuid_path(Sys.STDLIB, pkg) will return a String"
    - "Confirmed: The stdlib_fallback label was already present, PR just adds early jump to it"
  secondary_confidence: "high"
  secondary_rationale: |
    Independent verification confirms the original analysis was accurate. The key insight
    is that this PR enables early jumping to an existing stdlib_fallback code path that
    was previously only reachable when the loop exhausted naturally. The critical safety
    guarantee is that is_stdlib() verifies both name and UUID match an actual stdlib,
    which ensures manifest_uuid_path(Sys.STDLIB, pkg) will succeed.

    Additional callers identified:
    - require flow (loading.jl:2699) - main package loading
    - precompilation (loading.jl:1882) - source file lookup
    - compilecache (loading.jl:3309) - cache creation
    - stale checking (loading.jl:4196) - dependency validation

    All benefit from this fix when loading packages with stdlib dependencies that have
    outdated git-tree-sha1 entries in manifests from older Julia versions.
