schema_version: "1.0"

pr:
  number: 59862
  title: "Bonus backports to 1.12.1"
  url: "https://github.com/JuliaLang/julia/pull/59862"
  diff_url: "https://github.com/JuliaLang/julia/pull/59862.diff"
  author: "KristofferC"
  labels:
    - "release"
  created_at: "2025-10-16T09:00:49Z"
  merged_at: "2025-10-17T08:59:48Z"
  merge_commit_sha: "87a07e7387e848cecfb8892eb38ea173dd81add3"
  base_branch: "release-1.12"

scope:
  files_touched:
    - "stdlib/Markdown/src/Julia/interp.jl"
    - "stdlib/Markdown/test/runtests.jl"
    - "stdlib/REPL/src/REPLCompletions.jl"
    - "stdlib/REPL/src/precompile.jl"
    - "stdlib/REPL/test/replcompletions.jl"
  components:
    - "Markdown"
    - "REPL"
    - "REPLCompletions"
    - "Precompile"
  pipeline_stages: []

analysis:
  intent:
    summary: |
      Backport PR containing three bug fixes for Julia 1.12.1 release:
      1. #59806 - Markdown: fix string interpolation in Footnote and Admonition blocks
      2. #59692 - Remove restrictions on kwarg tab completion for Type{T} constructors
      3. #59850 - Reinstate PrecompileTools-esque caching for REPL precompilation
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/59783"
      - "https://github.com/JuliaLang/julia/issues/59244"
    backported_prs:
      - number: 59806
        title: "Markdown: fix string interpolation"
        cherry_pick_sha: "20c787d"
      - number: 59692
        title: "Remove restrictions on kwarg tab completion"
        cherry_pick_sha: "9cddfda"
      - number: 59850
        title: "Reinstate PrecompileTools-esque caching for REPL"
        cherry_pick_sha: "ecfec85"

  direct_changes:
    - summary: "Add Footnote and Admonition to toexpr method generation list"
      component: "Markdown"
      backport_of: 59806
      evidence:
        - source: "diff"
          path: "stdlib/Markdown/src/Julia/interp.jl"
          loc: "49"
          url: "https://github.com/JuliaLang/julia/blob/87a07e7387e848cecfb8892eb38ea173dd81add3/stdlib/Markdown/src/Julia/interp.jl#L49"
          snippet: |
            # BEFORE:
            for T in Any[MD, Paragraph, Header, Link, Bold, Italic]
                @eval function toexpr(md::$T)
                    Expr(:call, typeof(md), $(map(x->:(toexpr(md.$x)), fieldnames(Base.unwrap_unionall(T)))...))
                end
            end

            # AFTER (Footnote and Admonition added):
            for T in Any[MD, Paragraph, Header, Link, Bold, Italic, Footnote, Admonition]
                @eval function toexpr(md::$T)
                    Expr(:call, typeof(md), $(map(x->:(toexpr(md.$x)), fieldnames(Base.unwrap_unionall(T)))...))
                end
            end

    - summary: "Remove isconcretetype guard from complete_keyword_argument!"
      component: "REPLCompletions"
      backport_of: 59692
      evidence:
        - source: "diff"
          path: "stdlib/REPL/src/REPLCompletions.jl"
          loc: "905-908"
          url: "https://github.com/JuliaLang/julia/blob/87a07e7387e848cecfb8892eb38ea173dd81add3/stdlib/REPL/src/REPLCompletions.jl#L905-L908"
          snippet: |
            # REMOVED CODE (6 lines deleted):
            # Limit kwarg completions to cases when function is concretely known; looking up
            # matching methods for abstract functions - particularly `Any` or `Function` - can
            # take many seconds to run over the thousands of possible methods. Note that
            # isabstracttype would return naively return true for common constructor calls
            # like Array, but the REPL's introspection here may know their Type{T}.
            isconcretetype(funct) || return false

            # After deletion, line 907 now directly calls:
            complete_methods!(methods, funct, Any[Vararg{Any}], kwargs_ex, -1, arg_pos == :kwargs)

    - summary: "Wrap REPL precompilation workload with jl_tag_newly_inferred_enable/disable"
      component: "REPL Precompile"
      backport_of: 59850
      evidence:
        - source: "diff"
          path: "stdlib/REPL/src/precompile.jl"
          loc: "192-206"
          url: "https://github.com/JuliaLang/julia/blob/87a07e7387e848cecfb8892eb38ea173dd81add3/stdlib/REPL/src/precompile.jl#L192-L206"
          snippet: |
            let
                if Base.generating_output() && Base.JLOptions().use_pkgimages != 0
                    # Bare-bones PrecompileTools.jl
                    # Do we need latestworld-if-toplevel here
                    ccall(:jl_tag_newly_inferred_enable, Cvoid, ())
                    try
                        repl_workload()
                        precompile(Tuple{typeof(Base.setindex!), Base.Dict{Any, Any}, Any, Int})
                        precompile(Tuple{typeof(Base.delete!), Base.Set{Any}, String})
                        precompile(Tuple{typeof(Base.:(==)), Char, String})
                    finally
                        ccall(:jl_tag_newly_inferred_disable, Cvoid, ())
                    end
                end
            end

    - summary: "Add test for Markdown interpolation in footnotes and admonitions"
      component: "Markdown tests"
      backport_of: 59806
      evidence:
        - source: "diff"
          path: "stdlib/Markdown/test/runtests.jl"
          loc: "505-527"
          url: "https://github.com/JuliaLang/julia/blob/87a07e7387e848cecfb8892eb38ea173dd81add3/stdlib/Markdown/test/runtests.jl#L505-L527"
          snippet: |
            # JuliaLang/julia#59783
            let x = 1,
                result = md"""
                $x

                [^1]: $x

                !!! note
                $x
                """,
                expected = """
                1

                [^1]: 1

                !!! note



                1
                """
                @test plain(result) == expected
            end

    - summary: "Add comprehensive tests for @kwdef type kwarg completion"
      component: "REPLCompletions tests"
      backport_of: 59692
      evidence:
        - source: "diff"
          path: "stdlib/REPL/test/replcompletions.jl"
          loc: "2694-2738"
          url: "https://github.com/JuliaLang/julia/blob/87a07e7387e848cecfb8892eb38ea173dd81add3/stdlib/REPL/test/replcompletions.jl#L2694-L2738"
          snippet: |
            @kwdef struct T59244
                asdf = 1
                qwer = 2
            end
            @kwdef struct S59244{T}
                asdf::T = 1
                qwer::T = 2
            end
            @testset "kwarg completion of types" begin
                s = "T59244(as"
                a, b, c = completions(s, lastindex(s), @__MODULE__, #= shift =# false)
                @test REPLCompletions.KeywordArgumentCompletion("asdf") in a

                s = "T59244(; qw"
                a, b, c = completions(s, lastindex(s), @__MODULE__, #= shift =# false)
                @test REPLCompletions.KeywordArgumentCompletion("qwer") in a
                @test REPLCompletions.KeywordArgumentCompletion("qwer") == only(a)

                s = "S59244(as"
                a, b, c = completions(s, lastindex(s), @__MODULE__, #= shift =# false)
                @test REPLCompletions.KeywordArgumentCompletion("asdf") in a

                s = "S59244{Int}(as"
                a, b, c = completions(s, lastindex(s), @__MODULE__, #= shift =# false)
                @test REPLCompletions.KeywordArgumentCompletion("asdf") in a
            end

  pipeline_impact: []

  secondary_effects:
    - effect: "Markdown interpolation now works in Footnote and Admonition blocks"
      mechanism: |
        The toexpr function chain for Markdown interpolation:

        1. md"..." macro invokes mdexpr() [Markdown.jl:74-77]:
           function mdexpr(s, flavor = :julia)
               md = parse(s, flavor = Symbol(flavor))
               esc(toexpr(md))
           end

        2. toexpr() converts the Markdown AST to Julia Expr for evaluation [interp.jl:44-61]
           - toexpr(x) = x  # fallback for primitives
           - toexpr(xs::Vector{Any}) -> Expr(:call, getindex, Any, mapany(toexpr, xs)...)
           - For struct types: Expr(:call, typeof(md), toexpr(md.field1), toexpr(md.field2), ...)

        Previously, Footnote and Admonition were NOT in the toexpr generation loop, causing:
        - toexpr(::Footnote) to fall through to toexpr(x) = x
        - The entire Footnote struct was returned as-is (as a literal)
        - Nested interpolations were NOT recursively converted to Expr
        - At runtime, the literal struct couldn't substitute the interpolated variable

        After adding Footnote and Admonition to the list [interp.jl:49]:
        - for T in Any[MD, Paragraph, Header, Link, Bold, Italic, Footnote, Admonition]
        - toexpr(::Footnote) now generates:
            Expr(:call, Footnote, toexpr(md.id), toexpr(md.text))
        - Recursively converts all nested content including interpolated expressions

        Footnote struct [block.jl:127-130]:
          mutable struct Footnote <: MarkdownElement
              id::String
              text  # Can contain nested Markdown with interpolations
          end

        Admonition struct [block.jl:191-195]:
          mutable struct Admonition <: MarkdownElement
              category::String
              title::String
              content::Vector  # Can contain nested Markdown with interpolations
          end
      downstream_surfaces:
        - "md\"\" string macro with interpolations in footnotes"
        - "md\"\" string macro with interpolations in admonitions (!!! blocks)"
        - "Documentation generation using Markdown interpolation"
      likelihood: "high"
      impact: "medium"

    - effect: "Kwarg completion now works for @kwdef struct constructors (Type{T})"
      mechanism: |
        Call chain for kwarg completion (verified at merge commit):

        completions(string, pos, context_module, shift)  [REPLCompletions.jl:998]
          -> complete_keyword_argument!(suggestions, e, s, context_module, arg_pos)  [line 1100]
          -> _complete_methods(ex_org, context_module, shift)  [line 699-714]
             -> repl_eval_ex(ex_org.args[1], context_module)  [line 710]
                Returns Const(Type{T}) for calls like T59244(...)
             -> CC.widenconst(funct) => Type{T59244}  [line 712]
          -> (REMOVED) isconcretetype(funct) || return false
             isconcretetype(Type{T}) == false, previously blocked completion
          -> complete_methods!(methods, funct, Any[Vararg{Any}], kwargs_ex, -1, ...)  [line 908]
             Now always called, enabling method lookup

        Result: Base.kwarg_decl(method) extracts kwarg names from @kwdef constructors
      downstream_surfaces:
        - "REPL tab completion for @kwdef struct constructors"
        - "IDE integrations using REPLCompletions"
      likelihood: "high"
      impact: "medium"

    - effect: "REPL precompilation now properly caches newly inferred methods"
      mechanism: |
        Full call chain for jl_tag_newly_inferred mechanism:

        1. ENABLE TAGGING [precompile.jl:196]:
           ccall(:jl_tag_newly_inferred_enable, Cvoid, ())
             -> jl_atomic_fetch_add(&jl_tag_newly_inferred_enabled, 1)  [staticdata_utils.c:96]

        2. DURING WORKLOAD - When type inference creates a new CodeInstance:
           InternalCodeCache.setindex!(cache, ci, mi)  [Compiler/src/cicache.jl:14-21]
             -> ccall(:jl_push_newly_inferred, Cvoid, (Any,), ci)  [cicache.jl:18]
             -> jl_push_newly_inferred(ci)  [staticdata_utils.c:117-132]
                - Checks: tag_newly_inferred = jl_atomic_load_relaxed(&jl_tag_newly_inferred_enabled)
                - If enabled, marks MI: jl_atomic_store_relaxed(&mi->flags, miflags | JL_MI_FLAGS_MASK_PRECOMPILED)
                - Appends to array: jl_array_ptr_set(newly_inferred, end, ci)

        3. DISABLE TAGGING [precompile.jl:203]:
           ccall(:jl_tag_newly_inferred_disable, Cvoid, ())
             -> jl_atomic_fetch_add(&jl_tag_newly_inferred_enabled, -1)  [staticdata_utils.c:103]

        4. DURING SERIALIZATION:
           jl_prepare_serialization_data(mod_array, newly_inferred, ...)  [staticdata.c:3015]
             -> queue_external_cis(newly_inferred, query_cache)  [staticdata.c:3025]
             -> Tagged CodeInstances are included in .ji cache files

        This is a "bare-bones PrecompileTools.jl" implementation:
        - PrecompileTools.jl uses the same jl_tag_newly_inferred mechanism
        - The REPL workload (repl_workload()) exercises REPL functionality
        - Methods compiled during this workload are now marked for sysimage caching
        - This reduces first-time latency (TTFX) when using REPL features

        Without this wrapping:
        - Methods compiled during repl_workload() were NOT tagged for caching
        - Each Julia session had to recompile these methods on first use
        - Users experienced higher latency when first using REPL features
      downstream_surfaces:
        - "Julia startup time / TTFX for REPL features"
        - "Sysimage generation with REPL stdlib"
        - "PrecompileTools.jl compatibility (uses same mechanism)"
      likelihood: "high"
      impact: "medium"

  compatibility:
    internal_api: []
    behavioral:
      - summary: "Markdown interpolation in footnotes/admonitions now works"
        evidence:
          - source: "test"
            path: "stdlib/Markdown/test/runtests.jl"
            loc: "505-527"
            snippet: |
              # Issue #59783: Interpolation within @md_str in admonitions/footnotes

              BEFORE (Julia 1.12.0):
              let x = 1
                  result = md"""
                  [^1]: $x
                  """
                  plain(result)  # Did NOT contain "1", interpolation failed
              end

              AFTER (with this backport):
              let x = 1
                  result = md"""
                  [^1]: $x
                  """
                  plain(result)  # Contains "[^1]: 1", interpolation works
              end

      - summary: "Tab completion provides kwarg suggestions for @kwdef constructors"
        evidence:
          - source: "issue"
            path: "GitHub Issue #59244"
            snippet: |
              BEFORE (Julia 1.12.0):
              julia> @kwdef struct Test
                         first = 2
                     end
              julia> Test(; fi<TAB>
              # Shows global completions: fieldcount, fieldname, fill...

              AFTER (with this backport):
              julia> Test(; fi<TAB>
              julia> Test(; first=
              # Correctly suggests keyword argument from @kwdef

  performance:
    compile_time:
      - summary: "REPL precompilation caching reduces startup latency"
        evidence:
          - source: "pr"
            path: "PR #59850"
            snippet: |
              The PR description notes:
              "REPL precompile scripts runs a workload and might thus encounter code in
              other standard libraries that needs to be precompiled."

              By wrapping with jl_tag_newly_inferred_enable/disable:
              - Methods compiled during REPL workload are cached
              - First use of REPL features in new sessions is faster
              - ESTIMATED: Reduces TTFX by caching O(100s) of method compilations
    runtime: []

  tests:
    changed_files:
      - "stdlib/Markdown/test/runtests.jl"
      - "stdlib/REPL/test/replcompletions.jl"
    new_behavior_assertions:
      - description: "Markdown interpolation works in footnotes and admonitions"
        evidence: |
          let x = 1, result = md"""$x\n[^1]: $x\n!!! note\n$x\n"""
              @test plain(result) == "1\n\n[^1]: 1\n\n!!! note\n\n\n\n1\n"
          end
      - description: "T59244(as... completes to asdf="
        evidence: |
          @test REPLCompletions.KeywordArgumentCompletion("asdf") in a
      - description: "Parametric types S59244{T} also get kwarg completion"
        evidence: |
          s = "S59244{Int}(as"
          @test REPLCompletions.KeywordArgumentCompletion("asdf") in a

  risk:
    level: "low"
    rationale:
      - "All changes are in stdlib (Markdown, REPL), not compiler core"
      - "Backport to stable release branch with minimal, targeted fixes"
      - "Each bundled fix addresses a specific user-reported bug"
      - "No changes to type inference, lowering, or code generation"
      - "No changes to OpaqueClosure, generated functions, or world age"
      - "Tests explicitly verify the fixed behaviors"

  open_questions:
    - question: "Does BlockQuote have the same interpolation bug?"
      analysis: |
        Independent review identified that BlockQuote has a similar structure to Footnote/Admonition:

        mutable struct BlockQuote <: MarkdownElement
            content  # Can contain nested Markdown with interpolations
        end

        BlockQuote is NOT in the toexpr generation loop [interp.jl:49], so it falls through to
        toexpr(x) = x. This means interpolation inside blockquotes (> quoted text) may also be
        broken. However, no test case was added for this scenario.

        Potentially affected code pattern:
          let x = 1
              md"> $x"  # BlockQuote with interpolation - may not work
          end

        Recommend filing a follow-up issue if this is confirmed.
    - question: "Are there other Markdown element types missing toexpr methods?"
      analysis: |
        Complete analysis of MarkdownElement types vs toexpr coverage:

        WITH toexpr method (in loop or explicit):
        - MD, Paragraph, Header, Link, Bold, Italic, Footnote, Admonition [loop at interp.jl:49]
        - Table [explicit method at interp.jl:55-57]
        - List [explicit method at interp.jl:59-61]

        WITHOUT toexpr method (fall through to toexpr(x) = x):
        - Code (fields: language::String, code::String) - OK, no nested content
        - BlockQuote (fields: content) - POTENTIAL ISSUE, has nested content
        - HorizontalRule (no fields) - OK, no content
        - Image (fields: url::String, alt::String) - OK, no nested content
        - LineBreak (no fields) - OK, no content
        - LaTeX (fields: formula::String) - OK, no nested content

        Only BlockQuote appears to have potential interpolation issues.
    - "Should jl_tag_newly_inferred be exposed as a public Julia API?"

  recommendations:
    - "No action required for downstream compiler packages"
    - "This PR has zero impact on JET, Enzyme, or GPUCompiler"
    - "Documentation generators using md\"\" may see improved interpolation behavior"

classification:
  type: "backport"
  compiler_relevant: false
  breaking_change: false
  requires_downstream_action: false

notes: |
  This PR is a backport bundle containing three bug fixes for Julia 1.12.1:

  1. Markdown interpolation fix (#59806):
     - Issue: $x interpolation didn't work inside [^1]: footnotes or !!! admonitions
     - Cause: Footnote and Admonition types lacked toexpr method generation
     - Fix: Add these types to the @eval loop that generates toexpr methods
     - The toexpr function recursively converts Markdown AST to Expr for evaluation
     - Without it, interpolated expressions were not substituted

  2. Kwarg completion fix (#59692):
     - Issue: Tab completion for @kwdef struct constructors showed global symbols
     - Cause: isconcretetype(Type{T}) returns false, blocking kwarg extraction
     - Fix: Remove the isconcretetype guard entirely
     - Type constructors now get proper kwarg completion via Base.kwarg_decl
     - See analyses/pr_59692.yaml for detailed analysis of this change

  3. REPL precompilation caching (#59850):
     - Issue: Methods compiled during REPL workload were not cached
     - Cause: Missing jl_tag_newly_inferred_enable/disable wrapping
     - Fix: Wrap repl_workload() with the tagging ccalls
     - This is a minimal PrecompileTools-style caching mechanism
     - Reduces Julia startup latency for REPL features

  rg search for callers/consumers:
  $ rg "toexpr" julia/stdlib/Markdown/
  src/Julia/interp.jl:44:toexpr(x) = x
  src/Julia/interp.jl:46:toexpr(xs::Union{...}) = Expr(:call, ...)
  src/Julia/interp.jl:49:for T in Any[MD, Paragraph, Header, Link, Bold, Italic, Footnote, Admonition]
  src/Julia/interp.jl:55:function toexpr(md::Table)
  src/Julia/interp.jl:59:function toexpr(md::List)

  $ rg "jl_tag_newly_inferred" julia/
  src/staticdata_utils.c:89:static _Atomic(uint8_t) jl_tag_newly_inferred_enabled = 0;
  src/staticdata_utils.c:94:JL_DLLEXPORT void jl_tag_newly_inferred_enable(void)
  src/staticdata_utils.c:101:JL_DLLEXPORT void jl_tag_newly_inferred_disable(void)
  stdlib/REPL/src/precompile.jl:196:        ccall(:jl_tag_newly_inferred_enable, ...)
  stdlib/REPL/src/precompile.jl:203:            ccall(:jl_tag_newly_inferred_disable, ...)

  This backport PR is safe and has no impact on compiler internals or downstream
  compiler-focused packages. It only affects stdlib components (Markdown, REPL).

reviewer_notes:
  primary_reviewer: "Automated analysis via analyze-julia-compiler-pr skill"
  primary_review_date: "2026-01-22"
  methodology: |
    1. Fetched PR metadata from pr-archive/JuliaLang_julia/pr_59862.json
    2. Cloned Julia repo and checked out merge commit 87a07e7387e848cecfb8892eb38ea173dd81add3
    3. Fetched details of backported PRs (#59692, #59806, #59850) via WebFetch
    4. Read full source files at modified locations
    5. Traced call chains using rg searches
    6. Cross-referenced with existing analysis (pr_59692.yaml)
  findings:
    verified:
      - "This is a backport bundle to release-1.12 containing 3 separate fixes"
      - "Markdown fix adds Footnote and Admonition to toexpr generation loop"
      - "REPLCompletions fix removes isconcretetype guard (same as PR #59692)"
      - "Precompile fix wraps workload with jl_tag_newly_inferred ccalls"
      - "All changes are in stdlib, no compiler core modifications"
    cross_references:
      - "PR #59692 analysis available at analyses/pr_59692.yaml"
      - "The kwarg completion changes are identical between #59692 and #59862"
  confidence: "high"

secondary_review:
  reviewer: "Independent review via PR analysis reviewer skill"
  review_date: "2026-01-22"
  methodology: |
    1. Read existing analysis to understand first analyst's findings
    2. Checked out merge commit 87a07e7387e848cecfb8892eb38ea173dd81add3
    3. Independent code examination of all modified files
    4. Traced jl_tag_newly_inferred mechanism through full call chain
    5. Analyzed all MarkdownElement types to identify potential gaps
    6. Verified kwarg completion call chain with precise file:line references
  additional_findings:
    - finding: "BlockQuote may have the same interpolation bug"
      evidence: |
        BlockQuote struct has a 'content' field similar to Footnote.text and Admonition.content,
        but BlockQuote is NOT in the toexpr generation loop [interp.jl:49]. This means:
        - toexpr(::BlockQuote) falls through to toexpr(x) = x
        - Nested interpolations inside blockquotes may not be processed
        - No test case was added for blockquote interpolation
      recommendation: "Consider filing follow-up issue to verify and fix if needed"
    - finding: "Complete MarkdownElement coverage analysis"
      evidence: |
        Identified all 13 MarkdownElement types:
        - 10 have proper toexpr coverage (via loop, explicit method, or no nested content)
        - BlockQuote is the only type with nested content that lacks toexpr method
        - Code, HorizontalRule, Image, LineBreak, LaTeX all have primitive fields only
    - finding: "jl_tag_newly_inferred full call chain traced"
      evidence: |
        Extended the mechanism trace to include:
        - Entry point: InternalCodeCache.setindex! [Compiler/src/cicache.jl:18]
        - Flag check: jl_atomic_load_relaxed(&jl_tag_newly_inferred_enabled) [staticdata_utils.c:121]
        - MI marking: JL_MI_FLAGS_MASK_PRECOMPILED flag [staticdata_utils.c:125]
        - Serialization: jl_prepare_serialization_data -> queue_external_cis [staticdata.c:3015-3025]
  enhancements_made:
    - "Added detailed mdexpr call chain showing Markdown.jl:74-77 entry point"
    - "Added complete jl_tag_newly_inferred mechanism trace including Compiler/src/cicache.jl"
    - "Added MarkdownElement coverage analysis in open_questions"
    - "Added BlockQuote potential issue to open_questions"
  agreement_with_primary:
    - "All direct changes correctly identified"
    - "Risk level appropriately assessed as low"
    - "Correct identification that this is stdlib-only, no compiler core impact"
    - "Correct assessment that downstream compiler packages are unaffected"
  confidence: "high"
