schema_version: "1.0"
pr:
  number: 59853
  title: "REPL, styling, bracket match: Use a UInt32 for offset"
  url: "https://github.com/JuliaLang/julia/pull/59853"
  author: "KristofferC"
  labels: []
  merged_at: "2025-10-16T08:57:45Z"
  merge_commit_sha: "c175ce04b7342f41537c88efd958b0a2150750ff"
  diff_url: "https://github.com/JuliaLang/julia/pull/59853.diff"

scope:
  files_touched:
    - "stdlib/REPL/src/StylingPasses.jl"
  components:
    - "REPL"
  pipeline_stages:
    - "None (REPL UI only)"

analysis:
  intent:
    summary: |
      Fix a MethodError on 32-bit Julia builds where the REPL bracket matching feature
      (EnclosingParenHighlightPass) threw a silent exception because walk_tree expected
      an Int offset but JuliaSyntax.span returns UInt32.
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/59851"
    rationale: |
      On 64-bit systems, Int (Int64) can hold UInt32 values with implicit conversion,
      so the type mismatch was harmless. On 32-bit systems, Int is Int32, and the
      UInt32 returned by JuliaSyntax.span caused a method dispatch failure when
      calling the recursive walk_tree function.

      The error was "silent" because EnclosingParenHighlightPass catches exceptions
      and logs them with @error maxlog=1, then returns an unstyled AnnotatedString.
      This means users would only see the error once in logs, and bracket highlighting
      would simply not work on 32-bit systems.

  direct_changes:
    - summary: "Changed walk_tree offset parameter from Int to UInt32"
      component: "REPL.StylingPasses"
      evidence:
        - source: "diff"
          path: "stdlib/REPL/src/StylingPasses.jl"
          loc: "127"
          url: "https://github.com/JuliaLang/julia/blob/c175ce04b7342f41537c88efd958b0a2150750ff/stdlib/REPL/src/StylingPasses.jl#L127"
          snippet: |
            # Before:
            walk_tree(ast, content, 0) do node, offset
            # After:
            walk_tree(ast, content, UInt32(0)) do node, offset

        - source: "diff"
          path: "stdlib/REPL/src/StylingPasses.jl"
          loc: "154"
          url: "https://github.com/JuliaLang/julia/blob/c175ce04b7342f41537c88efd958b0a2150750ff/stdlib/REPL/src/StylingPasses.jl#L154"
          snippet: |
            # Before:
            function walk_tree(f::Function, node, content::String, offset::Int)
            # After:
            function walk_tree(f::Function, node, content::String, offset::UInt32)

    - summary: "walk_tree recursively adds JuliaSyntax.span (UInt32) to offset"
      component: "REPL.StylingPasses"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/StylingPasses.jl"
          loc: "154-163"
          url: "https://github.com/JuliaLang/julia/blob/c175ce04b7342f41537c88efd958b0a2150750ff/stdlib/REPL/src/StylingPasses.jl#L154-L163"
          snippet: |
            function walk_tree(f::Function, node, content::String, offset::UInt32)
                f(node, offset)

                if JuliaSyntax.numchildren(node) > 0
                    for child in JuliaSyntax.children(node)
                        walk_tree(f, child, content, offset)
                        offset += JuliaSyntax.span(child)  # span returns UInt32
                    end
                end
            end

    - summary: "Error catching mechanism in EnclosingParenHighlightPass made failure silent"
      component: "REPL.StylingPasses"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/StylingPasses.jl"
          loc: "89-110"
          url: "https://github.com/JuliaLang/julia/blob/c175ce04b7342f41537c88efd958b0a2150750ff/stdlib/REPL/src/StylingPasses.jl#L89-L110"
          snippet: |
            function (pass::EnclosingParenHighlightPass)(input::String, context::StylingContext)
                result = AnnotatedString(input)

                if isempty(input) || context.cursor_pos < 1
                    return result
                end

                try
                    ast = JuliaSyntax.parseall(JuliaSyntax.GreenNode, input; ignore_errors=true)
                    paren_pairs = find_enclosing_parens(input, ast, context.cursor_pos)

                    for (open_pos, close_pos) in paren_pairs
                        annotate!(result, open_pos:open_pos, :face, pass.face)
                        annotate!(result, close_pos:close_pos, :face, pass.face)
                    end
                catch e
                    e isa InterruptException && rethrow()
                    @error "Error in EnclosingParenHighlightPass" exception=(e, catch_backtrace()) maxlog=1
                end

                return result
            end

    - summary: "JuliaSyntax.span returns UInt32 by design (external package bundled at build time)"
      component: "JuliaSyntax"
      evidence:
        - source: "reference"
          path: "external: JuliaSyntax.jl/src/core/parse_stream.jl"
          loc: "132"
          url: "https://github.com/JuliaLang/JuliaSyntax.jl/blob/99e975a726a82994de3f8e961e6fa8d39aed0d37/src/core/parse_stream.jl#L132"
          note: |
            JuliaSyntax is bundled into Julia at build time. The span property is defined
            as UInt32 in the external JuliaSyntax.jl repository. This PR body explicitly
            links to this location as the source of the UInt32 return type.

  secondary_effects:
    - effect: "None - change is completely isolated to REPL UI"
      mechanism: |
        Complete call chain from REPL initialization to walk_tree:

        REPL.jl:1335-1337 - julia_prompt initialization:
          styling_passes = StylingPasses.StylingPass[
              StylingPasses.SyntaxHighlightPass(),
              StylingPasses.EnclosingParenHighlightPass()
          ]

        -> LineEdit.jl imports StylingPasses:
          using ..REPL.StylingPasses: StylingPass, ..., EnclosingParenHighlightPass, ...

        -> When user types, apply_styling_passes() calls each pass [StylingPasses.jl:44-51]

        -> EnclosingParenHighlightPass.__call__() [StylingPasses.jl:89]
            -> find_enclosing_parens() [StylingPasses.jl:123]
            -> walk_tree() [StylingPasses.jl:154]

        walk_tree is a private function only called from find_enclosing_parens.
        No other code paths lead to this function.
      downstream_surfaces: []
      likelihood: "low"
      impact: "low"

  compatibility:
    internal_api: []
    behavioral:
      - component: "REPL bracket highlighting"
        change: "No longer throws silent MethodError on 32-bit systems"
        impact: "positive"
        details: |
          On 32-bit Windows CI builds, the MethodError was being logged once with:
            @error "Error in EnclosingParenHighlightPass" exception=(e, catch_backtrace()) maxlog=1
          After the fix, bracket matching works correctly on all platforms.

  performance:
    compile_time: []
    runtime:
      - description: |
          No performance impact. The change is type-consistent: UInt32 arithmetic
          is used throughout instead of potential mixed Int32/UInt32 conversions.
          The offset variable is only used for simple addition operations.
        impact: "neutral"
        confidence: "high"

  risk:
    level: "low"
    rationale:
      - "Simple type annotation change to match JuliaSyntax API"
      - "Limited scope: only affects REPL bracket highlighting visual feature"
      - "Bug fix with no behavioral changes for correctly working systems"
      - "No compiler pipeline or code generation changes"
      - "Error was caught by robust try-catch in EnclosingParenHighlightPass"

  downstream_impact:
    affected_packages: []
    notes: |
      This PR has zero impact on downstream packages like JET, Enzyme,
      or GPUCompiler. The change is entirely within the REPL's visual
      styling subsystem which provides bracket matching highlighting.

      No compiler internals, type inference, or code generation are affected.

      The StylingPasses module is only used by REPL for visual input decoration:
        - SyntaxHighlightPass: syntax coloring of keywords, literals, etc.
        - RegionHighlightPass: highlighting selected text regions
        - EnclosingParenHighlightPass: bold/underline matching brackets

  open_questions: []

  recommendations:
    - "No action needed for downstream package maintainers"
    - "This is a standard bug fix for 32-bit architecture compatibility"

  testing:
    existing_tests:
      - path: "stdlib/REPL/test/repl.jl"
        loc: "2033-2055"
        url: "https://github.com/JuliaLang/julia/blob/c175ce04b7342f41537c88efd958b0a2150750ff/stdlib/REPL/test/repl.jl#L2033-L2055"
        description: "Tests that StylingPasses are properly registered in REPL prompts"
        snippet: |
          @testset "Syntax highlighting" begin
              using StyledStrings
              using REPL.StylingPasses

              # ... face configuration ...

              fake_repl(options = REPL.Options(confirm_exit=false, style_input=true)) do stdin_write, stdout_read, repl
                  repl.interface = REPL.setup_interface(repl)
                  julia_prompt = repl.interface.modes[1]
                  shell_mode = repl.interface.modes[3]

                  # Julia prompt should have syntax highlighting passes
                  @test length(julia_prompt.styling_passes) == 2
                  @test any(p -> p isa StylingPasses.SyntaxHighlightPass, julia_prompt.styling_passes)
                  @test any(p -> p isa StylingPasses.EnclosingParenHighlightPass, julia_prompt.styling_passes)

                  # Shell mode should not have syntax highlighting passes
                  @test length(shell_mode.styling_passes) == 0
                  # ...
              end
          end
    notes: |
      The bug was originally caught via 32-bit Windows CI builds which showed silent
      MethodError exceptions in the logs. The fix resolves the type mismatch without
      requiring new tests since the functional behavior is unchanged - the feature
      either works (64-bit, and now 32-bit with fix) or fails silently (32-bit before fix).

      The existing tests verify that EnclosingParenHighlightPass is registered but do
      not directly exercise the walk_tree function with 32-bit integer constraints.
      However, the fix is straightforward enough that code review is sufficient.

reviewer_notes: |
  Independent review confirmed:
  - All code paths traced correctly
  - Call chain from REPL.jl initialization verified
  - Test line numbers corrected (2033-2055, not 1925-1940)
  - JuliaSyntax reference clarified as external bundled package
  - Error-catching mechanism documented to explain "silent" failure mode
  - No additional secondary effects discovered
  - Analysis is complete and accurate for this simple type-fix PR
