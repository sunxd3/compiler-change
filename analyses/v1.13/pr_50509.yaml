schema_version: "1.0"
pr:
  number: 50509
  title: "speed-up `randperm` by using our current `rand(1:n)`"
  url: "https://github.com/JuliaLang/julia/pull/50509"
  author: "rfourquet"
  labels:
    - "performance"
    - "randomness"
  merged_at: "2025-10-26T00:37:01Z"
  merge_commit_sha: "b6ff22a3f02387db68e5dd8c2db7897898b8ff07"
  diff_url: "https://github.com/JuliaLang/julia/pull/50509.diff"

scope:
  files_touched:
    - "stdlib/Random/src/misc.jl"
  components:
    - "Random stdlib"
  pipeline_stages: []

analysis:
  intent:
    summary: |
      Simplifies and speeds up `randperm`, `randcycle`, and `shuffle` functions
      by replacing a custom "Less Than Masked 52 bits" (ltm52) range sampler with
      the standard `rand(rng, 1:n)` which uses the "Nearly Division Less" (NDL)
      algorithm. The NDL algorithm was added in Julia 1.5 and is generally faster
      than the old custom approach for array lengths < 2^20.

      Issue #57771 revealed that `shuffle!` was approximately 2x slower than a
      naive Fisher-Yates implementation. Investigation showed the ltm52 optimization
      had become counterproductive with newer Xoshiro RNG (was designed for MersenneTwister).
      Benchmarks in the issue showed:
        - 10 elements: 17.3 ns optimized vs 45.8 ns current (2.6x faster)
        - 10,000 elements: 12.4 us vs 47.9 us (3.9x faster)
        - 10,000,000 elements: 93.3 ms vs 157.6 ms (1.7x faster)
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/57771"

  direct_changes:
    - summary: "Remove ltm52 helper function for custom range sampling"
      component: "Random stdlib"
      evidence:
        - source: "diff"
          path: "stdlib/Random/src/misc.jl"
          loc: "176-181 (old)"
          url: "https://github.com/JuliaLang/julia/pull/50509/files#diff-removed"
          snippet: |
            # REMOVED CODE:
            ## rand Less Than Masked 52 bits (helper function)

            "Return a sampler generating a random `Int` (masked with `mask`) in ``[0, n)``, when `n <= 2^52`."
            ltm52(n::Int, mask::Int=nextpow(2, n)-1) = LessThan(n-1, Masked(mask, UInt52Raw(Int)))

    - summary: "Simplify shuffle! to use standard rand(1:i)"
      component: "Random stdlib"
      evidence:
        - source: "code"
          path: "stdlib/Random/src/misc.jl"
          loc: "227-235"
          url: "https://github.com/JuliaLang/julia/blob/b6ff22a3f02387db68e5dd8c2db7897898b8ff07/stdlib/Random/src/misc.jl#L227-L235"
          snippet: |
            function shuffle!(rng::AbstractRNG, a::AbstractArray)
                # keep it consistent with `randperm!` and `randcycle!` if possible
                require_one_based_indexing(a)
                @inbounds for i = 2:length(a)
                    j = rand(rng, 1:i)
                    a[i], a[j] = a[j], a[i]
                end
                return a
            end

    - summary: "Simplify randperm! to use standard rand(1:i)"
      component: "Random stdlib"
      evidence:
        - source: "code"
          path: "stdlib/Random/src/misc.jl"
          loc: "339-353"
          url: "https://github.com/JuliaLang/julia/blob/b6ff22a3f02387db68e5dd8c2db7897898b8ff07/stdlib/Random/src/misc.jl#L339-L353"
          snippet: |
            function randperm!(rng::AbstractRNG, a::AbstractArray{<:Integer})
                # keep it consistent with `shuffle!` and `randcycle!` if possible
                Base.require_one_based_indexing(a)
                n = length(a)
                n == 0 && return a
                a[1] = 1
                @inbounds for i = 2:n
                    j = rand(rng, 1:i)
                    if i != j # a[i] is undef (and could be #undef)
                        a[i] = a[j]
                    end
                    a[j] = i
                end
                return a
            end

    - summary: "Simplify randcycle! to use standard rand(1:i-1)"
      component: "Random stdlib"
      evidence:
        - source: "code"
          path: "stdlib/Random/src/misc.jl"
          loc: "420-433"
          url: "https://github.com/JuliaLang/julia/blob/b6ff22a3f02387db68e5dd8c2db7897898b8ff07/stdlib/Random/src/misc.jl#L420-L433"
          snippet: |
            function randcycle!(rng::AbstractRNG, a::AbstractArray{<:Integer})
                # keep it consistent with `shuffle!` and `randperm!` if possible
                Base.require_one_based_indexing(a)
                n = length(a)
                n == 0 && return a
                a[1] = 1
                # Sattolo's algorithm:
                @inbounds for i = 2:n
                    j = rand(rng, 1:i-1)
                    a[i] = a[j]
                    a[j] = i
                end
                return a
            end

    - summary: "Remove 2^52 length constraint"
      component: "Random stdlib"
      evidence:
        - source: "diff"
          path: "stdlib/Random/src/misc.jl"
          loc: "removed from shuffle!, randperm!, randcycle!"
          url: "https://github.com/JuliaLang/julia/pull/50509/files"
          snippet: |
            # REMOVED - previously in shuffle!, randperm!, randcycle!:
            @assert n <= Int64(2)^52

    - summary: "Remove mask tracking logic"
      component: "Random stdlib"
      evidence:
        - source: "diff"
          path: "stdlib/Random/src/misc.jl"
          loc: "removed from shuffle!, randperm!, randcycle!"
          url: "https://github.com/JuliaLang/julia/pull/50509/files"
          snippet: |
            # REMOVED - previously tracked mask for ltm52:
            mask = 3
            j = 1 + rand(r, ltm52(i, mask))
            i == 1 + mask && (mask = 2 * mask + 1)

    - summary: "NTuple shuffle indirectly improved via randperm!"
      component: "Random stdlib"
      evidence:
        - source: "code"
          path: "stdlib/Random/src/misc.jl"
          loc: "181-206"
          url: "https://github.com/JuliaLang/julia/blob/b6ff22a3f02387db68e5dd8c2db7897898b8ff07/stdlib/Random/src/misc.jl#L181-L206"
          snippet: |
            function shuffle(rng::AbstractRNG, tup::NTuple{N}) where {N}
                @inline let
                    Ind = if N <= typemax(UInt8)
                        UInt8
                    elseif N <= typemax(UInt16)
                        UInt16
                    else
                        UInt
                    end
                    mem = @inbounds randperm!(rng, Memory{Ind}(undef, N))  # <-- uses optimized randperm!
                    function closure(i::Int)
                        @inbounds tup[mem[i]]
                    end
                    ntuple(closure, Val{N}())
                end
            end

  secondary_effects:
    - effect: "Slight change in random number sequence"
      mechanism: |
        The NDL (Nearly Division Less) algorithm consumes entropy differently than
        the old ltm52 (masked rejection sampling) approach. For the same RNG seed,
        the sequence of random permutations will differ. This is reflected in the
        updated doctest examples which now use Xoshiro(0) instead of Xoshiro(123).
      downstream_surfaces:
        - "Test suites using hardcoded RNG seeds"
        - "Reproducibility of random permutations across Julia versions"
      likelihood: "high"
      impact: "low"

    - effect: "Performance profile changes based on array size"
      mechanism: |
        According to the PR author's benchmarks:
        - For array lengths < 2^20: new version is faster
        - For array lengths > 2^22: new version is slightly slower

        The NDL algorithm (generation.jl:362-395) implementation:
          struct SamplerRangeNDL{U<:Unsigned,T} <: Sampler{T}
              a::T  # first element of the range
              s::U  # range length or zero for full range
          end

          function rand(rng::AbstractRNG, sp::SamplerRangeNDL{U,T}) where {U,T}
              s = sp.s
              x = widen(rand(rng, U))
              m = x * s
              r::T = (m % U) < s ? rand_unlikely(rng, s, m) % T :
                     iszero(s)   ? x % T :
                                   (m >> (8*sizeof(U))) % T
              r + sp.a
          end

        The old ltm52 created nested sampler objects:
          LessThan(n-1, Masked(mask, UInt52Raw(Int)))
        This had overhead from object allocation and mask tracking each iteration.

        Reference: https://arxiv.org/abs/1805.10941 (algorithm 5)
      downstream_surfaces:
        - "Large-scale permutation benchmarks"
        - "Applications using very large arrays (> 4 million elements)"
      likelihood: "high"
      impact: "low"

    - effect: "Removal of 2^52 length restriction"
      mechanism: |
        Previously: @assert n <= Int64(2)^52
        Now: No explicit length restriction

        The NDL sampler works for any valid range, removing this artificial constraint.
        Arrays larger than 2^52 elements are extremely rare in practice.
      downstream_surfaces:
        - "Theoretical support for larger arrays"
      likelihood: "low"
      impact: "low"

    - effect: "Better inlining behavior"
      mechanism: |
        The new code uses `rand(rng, 1:i)` which the compiler can inline effectively.
        Investigation in issue #57771 showed that manual inlining was necessary for
        acceptable performance with the old code. The simplified loop structure:

          @inbounds for i = 2:length(a)
              j = rand(rng, 1:i)
              a[i], a[j] = a[j], a[i]
          end

        Is more amenable to LLVM optimization compared to the old version with mask
        tracking and sampler object construction on each iteration.
      downstream_surfaces:
        - "JIT compilation of permutation functions"
      likelihood: "medium"
      impact: "low"

  compatibility:
    internal_api:
      - field: "ltm52 helper function"
        change: "Removed entirely - was internal/undocumented"
        affected_tools: []
        impact: "none"
        rationale: "ltm52 was an internal helper, not part of public API"

    behavioral:
      - area: "Random sequence reproducibility"
        change: "Different random sequences for same seed"
        impact: "low"
        rationale: |
          Julia does not guarantee identical random sequences across versions.
          The Random stdlib documentation explicitly notes this.

  performance:
    compile_time:
      - description: "No compile-time impact"
        impact: "none"
        rationale: "stdlib code change only, no compiler modifications"

    runtime:
      - description: "Faster for typical array sizes (< 2^20)"
        impact: "positive"
        measurement: "MEASURED"
        rationale: |
          PR author's benchmarks show speedups for array lengths < 2^20.
          The NDL algorithm avoids the overhead of mask tracking and uses
          more efficient arithmetic.

      - description: "Slightly slower for very large arrays (> 2^22)"
        impact: "minor negative"
        measurement: "MEASURED"
        rationale: |
          For very large arrays, the old masked rejection approach had an
          advantage when ranges were close to powers of 2. This regression
          is minor and affects uncommon use cases.

  downstream_package_impact:
    - package: "General downstream users"
      impact: "minimal"
      rationale: |
        This change affects only the Random stdlib and does not touch any
        compiler internals. Downstream packages that use randperm, shuffle,
        or randcycle may see:
        1. Different random sequences for the same seed (expected behavior)
        2. Performance improvements for typical array sizes

        No API changes, no compiler changes, no type inference changes.

    - package: "Turing.jl, Enzyme.jl, GPUCompiler, JET"
      impact: "none"
      rationale: |
        These packages interact with compiler internals (type inference,
        IR manipulation, effect analysis). This PR modifies only the Random
        stdlib and has no intersection with compiler functionality.

  risk:
    level: "low"
    rationale:
      - "stdlib-only change with no compiler modifications"
      - "Well-tested NDL algorithm already in use for other range sampling"
      - "Extensive benchmarking by PR author showing mostly positive results"
      - "Julia explicitly does not guarantee reproducible random sequences across versions"
      - "No public API changes"

  open_questions: []

  recommendations:
    - "No action needed for downstream compiler-related packages"
    - "Users relying on reproducible random permutations should save outputs or use a stable random library if exact reproducibility across Julia versions is critical"

  notes:
    not_compiler_pr: |
      This PR is a stdlib performance optimization in the Random module.
      It does NOT affect:
      - Type inference (abstractinterpretation.jl)
      - SSA IR or optimization passes
      - Codegen or runtime behavior of compiled code
      - OpaqueClosure or generated functions
      - World age or method invalidation
      - Any compiler internal APIs

      The PR was likely included in a compiler PR list due to label-based
      filtering, but it is purely a Random stdlib change.

  independent_review:
    reviewer: "second_pass"
    date: "2026-01-21"
    findings:
      - "Original analysis correctly identifies this as a non-compiler PR"
      - "Added detailed context from issue #57771 showing 2-4x slowdown motivating fix"
      - "Added NTuple shuffle (line 181-206) which indirectly benefits via randperm!"
      - "Added complete NDL algorithm implementation from generation.jl:362-395"
      - "Added secondary effect about better inlining behavior"
      - "Verified ltm52 function is fully removed from codebase via rg search"
    verification:
      - "Checked out merge commit b6ff22a3f02387db68e5dd8c2db7897898b8ff07"
      - "Confirmed misc.jl line numbers in evidence match actual code"
      - "Confirmed SamplerRangeNDL implementation at generation.jl:362-395"
      - "Verified no other uses of ltm52 remain in codebase"
    assessment: |
      The original analysis is accurate and comprehensive. Enhancements added:
      1. More detailed issue context with benchmark numbers
      2. NTuple shuffle relationship to randperm!
      3. Complete NDL algorithm implementation code
      4. Inlining behavior secondary effect
      The risk assessment of "low" is correct - this is a stdlib-only change
      with no compiler impact.
