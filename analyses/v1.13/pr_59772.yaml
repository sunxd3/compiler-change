schema_version: "1.0"

pr:
  number: 59772
  title: "Avoid method instance normalization for opaque closure methods"
  url: "https://github.com/JuliaLang/julia/pull/59772"
  diff_url: "https://github.com/JuliaLang/julia/pull/59772.diff"
  author: "serenity4"
  labels: []
  merged_at: "2025-10-07T15:38:19Z"
  merge_commit_sha: "07b856c0dc1d75b7b5a5bbf451b93a0105385583"
  pr_body: |
    Fixes #59222.

    This issue was caused by a mismatch with `jl_new_opaque_closure_from_code_info_in_world`
    filling in the unnormalized method instance, and `new_opaque_closure` getting its
    `spec_ptr` from the normalized one via `jl_compile_method_internal`.

    For example, `g(xs...)` specialized as `g(:a, :b)` resulted in a different method
    instance than the corresponding normalized one:
    - Tuple{Tuple{typeof(Main.g)}, Symbol, Symbol} # unnormalized
    - Tuple{Tuple{typeof(Main.g)}, Symbol, Vararg{Symbol}} # normalized

    The fix is a single-line change to avoid normalization for opaque closure methods.

scope:
  files_touched:
    - "src/gf.c"
    - "test/opaque_closure.jl"
  components:
    - "Runtime"
    - "CodeGeneration"
    - "OpaqueClosure"
  pipeline_stages:
    - "Compilation"
    - "Codegen"
  is_compiler_change: true
  category: "OpaqueClosure bug fix"

analysis:
  intent:
    summary: |
      Fix a segmentation fault when constructing OpaqueClosure from IRCode with variadic
      arguments. The bug was caused by a mismatch between the method instance used to store
      inferred code and the one used to retrieve the compiled spec_ptr. The fix ensures
      opaque closure methods skip signature normalization entirely.
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/59222"

  bug_description:
    problem: |
      When creating an OpaqueClosure from IRCode with variadic arguments, a segfault
      occurred on Julia 1.12. The root cause was that jl_new_opaque_closure_from_code_info_in_world
      stores inferred code using an unnormalized method instance signature, but
      jl_compile_method_internal (called via new_opaque_closure) would normalize the
      signature before compilation, resulting in a different method instance. This caused
      the spec_ptr to be fetched from the wrong (normalized) CodeInstance, which had no
      compiled code, leading to undefined behavior.
    normalization_explanation: |
      Signature normalization "widens" specialized vararg types to their generic form.
      For a vararg method `g(xs...)` called as `g(:a, :b)`:
      - Unnormalized (specialized): Tuple{Tuple{typeof(g)}, Symbol, Symbol}
      - Normalized (widened):       Tuple{Tuple{typeof(g)}, Symbol, Vararg{Symbol}}

      The normalization is performed by jl_normalize_to_compilable_sig() which calls
      jl_compilation_sig() to compute the widened signature. For regular methods, this
      allows sharing compiled code across specializations. But for opaque closures,
      this caused a mismatch between stored and retrieved CodeInstances.
    example_before_fix: |
      # Minimal reproduction from issue #59222:
      g(xs...) = 1
      ir = Base.code_ircode_by_type(Tuple{Tuple{typeof(g)}, Symbol, Symbol})[1][1]
      ir.argtypes[1] = Tuple{typeof(g)}
      oc = Core.OpaqueClosure(ir, g; isva=true, do_compile=true)
      oc(:a, :b)  # SEGFAULT on Julia 1.12
    example_after_fix: |
      g(xs...) = 1
      ir = Base.code_ircode_by_type(Tuple{Tuple{typeof(g)}, Symbol, Symbol})[1][1]
      ir.argtypes[1] = Tuple{typeof(g)}
      oc = Core.OpaqueClosure(ir, g; isva=true, do_compile=true)
      oc(:a, :b)  # Returns 1 correctly

  direct_changes:
    - summary: "Skip method instance normalization for opaque closure methods"
      component: "src/gf.c"
      change_type: "modification"
      evidence:
        - source: "code"
          path: "src/gf.c"
          loc: "3809-3824"
          url: "https://github.com/JuliaLang/julia/blob/07b856c0dc1d75b7b5a5bbf451b93a0105385583/src/gf.c#L3809-L3824"
          snippet: |
            jl_method_instance_t *jl_normalize_to_compilable_mi(jl_method_instance_t *mi JL_PROPAGATES_ROOT)
            {
                jl_method_t *def = mi->def.method;
                if (!jl_is_method(def) || !jl_is_datatype(mi->specTypes) || def->is_for_opaque_closure)
                    return mi;
                jl_value_t *compilationsig = jl_normalize_to_compilable_sig((jl_datatype_t*)mi->specTypes, mi->sparam_vals, def, 1);
                if (compilationsig == jl_nothing || jl_egal(compilationsig, mi->specTypes))
                    return mi;
                jl_svec_t *env = NULL;
                JL_GC_PUSH2(&compilationsig, &env);
                jl_value_t *ti = jl_type_intersection_env((jl_value_t*)compilationsig, (jl_value_t*)def->sig, &env);
                assert(ti != jl_bottom_type); (void)ti;
                mi = jl_specializations_get_linfo(def, (jl_value_t*)compilationsig, env);
                JL_GC_POP();
                return mi;
            }
          explanation: |
            Added `|| def->is_for_opaque_closure` check to the early-return condition at line 3812.
            When the method is_for_opaque_closure, skip all normalization and return
            the original method instance unchanged. This ensures the same unnormalized
            method instance is used throughout the opaque closure creation pipeline.

        - source: "diff"
          path: "src/gf.c"
          loc: "3812"
          url: "https://github.com/JuliaLang/julia/pull/59772/files"
          diff: |
            -    if (!jl_is_method(def) || !jl_is_datatype(mi->specTypes))
            +    if (!jl_is_method(def) || !jl_is_datatype(mi->specTypes) || def->is_for_opaque_closure)

    - summary: "Add regression tests for vararg OpaqueClosure construction from IRCode"
      component: "test/opaque_closure.jl"
      change_type: "addition"
      evidence:
        - source: "test"
          path: "test/opaque_closure.jl"
          loc: "301-313"
          url: "https://github.com/JuliaLang/julia/blob/07b856c0dc1d75b7b5a5bbf451b93a0105385583/test/opaque_closure.jl#L301-L313"
          snippet: |
            # with manually constructed IRCode, without round-trip to CodeInfo
            f59222(xs...) = length(xs)
            ir = Base.code_ircode_by_type(Tuple{typeof(f59222), Symbol, Symbol})[1][1]
            ir.argtypes[1] = Tuple{}
            let oc = OpaqueClosure(ir; isva=true)
                @test oc(:a, :b) == 2
            end
            ir = Base.code_ircode_by_type(Tuple{typeof(f59222), Symbol, Vararg{Symbol}})[1][1]
            ir.argtypes[1] = Tuple{}
            let oc = OpaqueClosure(ir; isva=true)
                @test oc(:a) == 1
                @test oc(:a, :b, :c) == 3
            end
          explanation: |
            Tests both specialized (Symbol, Symbol) and vararg (Symbol, Vararg{Symbol})
            signatures to ensure OpaqueClosure construction from IRCode works correctly.
            These tests specifically cover the case that was crashing before the fix.

  secondary_effects:
    - effect: "Vararg specializations now preserved in OpaqueClosure method instances"
      mechanism: |
        The fix ensures consistency between two code paths that must use the same MethodInstance:

        PATH 1 - CodeInstance storage (jl_new_opaque_closure_from_code_info_in_world):
          jl_new_opaque_closure_from_code_info_in_world() [opaque_closure.c:147]
            -> jl_make_opaque_closure_method() [opaque_closure.c:156]
               sets m->is_for_opaque_closure = 1 [method.c:1102]
            -> jl_specializations_get_linfo(meth, sigtype, ...) [opaque_closure.c:164]
               returns mi with UNNORMALIZED specTypes
            -> jl_new_codeinst(mi, ...) [opaque_closure.c:168]
               stores CodeInstance at unnormalized mi

        PATH 2 - Compilation and spec_ptr retrieval (new_opaque_closure):
          new_opaque_closure() [opaque_closure.c:30]
            -> jl_specializations_get_linfo(source, sigtype, ...) [opaque_closure.c:55]
            -> jl_compile_method_internal(mi, world) [opaque_closure.c:66]
               -> jl_normalize_to_compilable_mi(mi) [gf.c:3506]
                  NOW: returns mi unchanged (def->is_for_opaque_closure check at line 3812)
                  BEFORE: could return different mi2 with normalized specTypes

        Without the fix, PATH 2 would look up a normalized mi that has no CodeInstance,
        causing spec_ptr to be NULL or pointing to invalid memory -> segfault.
      downstream_surfaces:
        - "OpaqueClosure construction from IRCode"
        - "OpaqueClosure compilation pipeline"
      likelihood: "high"
      impact: "high"

    - effect: "OpaqueClosure vararg dispatch behavior preserved"
      mechanism: |
        For opaque closures with isva=true, the exact specialization signature is now
        preserved through compilation. This means:
        - Specialized call like oc(:a, :b) uses Tuple{Symbol, Symbol}
        - Generic vararg call uses Tuple{Symbol, Vararg{Symbol}}
        Both now work correctly without interfering with each other.
      downstream_surfaces:
        - "Runtime method dispatch for OpaqueClosure"
      likelihood: "medium"
      impact: "medium"

    - effect: "Potential interaction with inlining of opaque closures"
      mechanism: |
        The inliner and const-prop have special handling for opaque closures:

        const_prop_methodinstance_heuristic [abstractinterpretation.jl:1213-1222]:
          if method.is_for_opaque_closure
              # Not inlining an opaque closure can be very expensive, so be generous
              # with the const-prop-ability. It is quite possible that we can't infer
              # anything at all without const-propping, so the inlining check below
              # isn't particularly helpful here.
              return true
          end

        ir_prepare_inlining! [ssair/inlining.jl:342-347]:
          if def.is_for_opaque_closure
              # Replace the first argument by a load of the capture environment
              argexprs[1] = insert_node!(
                  NewInstruction(Expr(:call, GlobalRef(Core, :getfield), argexprs[1], QuoteNode(:captures)),
                  ir.argtypes[1], topline))
          end

        Now that method instances remain unnormalized, the specTypes field preserves
        the exact signature, which may affect specialization matching in the inliner.
      downstream_surfaces:
        - "Compiler inlining decisions"
        - "Constant propagation for OpaqueClosure"
      likelihood: "low"
      impact: "low"
      explanation: |
        The inliner already handles opaque closures specially. The change to normalization
        is unlikely to affect inlining behavior since the inliner uses the method instance
        as-is and doesn't rely on normalization.

    - effect: "Codegen paths properly handle unnormalized opaque closure signatures"
      mechanism: |
        Multiple codegen paths check is_for_opaque_closure for special handling:

        emit_call_specfun_other [codegen.cpp:5163]:
          bool is_opaque_closure = jl_is_method(mi->def.value) && mi->def.method->is_for_opaque_closure;
          return emit_call_specfun_other(ctx, is_opaque_closure, mi->specTypes, ...);

        get_specsig_function [codegen.cpp:6264-6267]:
          bool is_opaque_closure = jl_is_method(mi->def.value) && mi->def.method->is_for_opaque_closure;
          assert(is_opaque_closure);
          jl_returninfo_t returninfo = get_specsig_function(..., mi->specTypes, rettype, is_opaque_closure);

        These paths use mi->specTypes directly. The fix ensures specTypes contains the
        expected unnormalized signature throughout the entire compilation pipeline.
      downstream_surfaces:
        - "LLVM codegen for OpaqueClosure"
        - "specsig generation"
      likelihood: "high"
      impact: "medium"

  call_chain_analysis:
    - name: "OpaqueClosure creation from CodeInfo - full pipeline"
      chain: |
        jl_new_opaque_closure_from_code_info_in_world() [opaque_closure.c:147]
          |
          +-> jl_make_opaque_closure_method(mod, ..., nargs, ..., ci, isva, isinferred) [opaque_closure.c:156]
          |     |
          |     +-> jl_new_method_uninit(module) [method.c:1097]
          |     +-> m->is_for_opaque_closure = 1 [method.c:1102]  // KEY: marks method as OC
          |     +-> m->isva = isva [method.c:1101]
          |
          +-> sigtype = jl_argtype_with_function_type(argslotty, argt) [opaque_closure.c:163]
          |
          +-> mi = jl_specializations_get_linfo(meth, sigtype, jl_emptysvec) [opaque_closure.c:164]
          |     // Returns mi with unnormalized specTypes (e.g., Tuple{Symbol, Symbol})
          |
          +-> inst = jl_new_codeinst(mi, ...) [opaque_closure.c:168]
          |     // Stores CodeInstance at unnormalized mi
          |
          +-> jl_mi_cache_insert(mi, inst) [opaque_closure.c:170]
          |
          +-> new_opaque_closure(argt, ..., meth, env, do_compile, world) [opaque_closure.c:173]
                |
                +-> mi = jl_specializations_get_linfo(source, sigtype, jl_emptysvec) [opaque_closure.c:55]
                |     // Must return same mi as above!
                |
                +-> ci = jl_compile_method_internal(mi, world) [opaque_closure.c:66]
                      |
                      +-> mi2 = jl_normalize_to_compilable_mi(mi) [gf.c:3506]
                      |     |
                      |     +-> checks def->is_for_opaque_closure [gf.c:3812]
                      |     +-> returns mi unchanged (FIX!)
                      |     // BEFORE FIX: would return different normalized mi2
                      |
                      +-> if (mi2 != mi) compile mi2 instead  // SKIPPED for OC
                      +-> proceeds to compile original mi

    - name: "Method instance normalization bypass"
      chain: |
        jl_compile_method_internal(mi, world) [gf.c:3497]
          |
          +-> codeinst = jl_method_compiled(mi, world) [gf.c:3500]
          |     // Quick check for already compiled
          |
          +-> mi2 = jl_normalize_to_compilable_mi(mi) [gf.c:3506]
          |     |
          |     +-> def = mi->def.method [gf.c:3811]
          |     +-> if def->is_for_opaque_closure: return mi [gf.c:3812] // FIX
          |     |
          |     // For regular methods (not OC), continues:
          |     +-> compilationsig = jl_normalize_to_compilable_sig(...) [gf.c:3814]
          |     |     // Widens Tuple{A,B} -> Tuple{A,Vararg{B}} for varargs
          |     +-> mi = jl_specializations_get_linfo(def, compilationsig, env) [gf.c:3821]
          |     +-> return normalized mi
          |
          +-> if (mi2 != mi) { ... } [gf.c:3507-3545]
          |     // For OC: mi2 == mi, so this block is skipped
          |     // Compile mi2, copy results to mi
          |
          +-> proceed with original mi compilation

  compatibility:
    internal_api:
      - field: "jl_method_t.is_for_opaque_closure"
        change: "Now checked in jl_normalize_to_compilable_mi to skip normalization"
        locations:
          - "src/gf.c:3812 - normalization bypass (new)"
          - "src/method.c:1102 - set to 1 for OC methods"
          - "src/codegen.cpp:5163,5179,6264,6850 - codegen special handling"
          - "Compiler/src/abstractinterpretation.jl:1216 - generous const-prop"
          - "Compiler/src/ssair/inlining.jl:342 - capture extraction"
          - "Compiler/src/validation.jl:225 - OC signature validation"
        affected_tools:
          - tool: "Enzyme.jl"
            usage: "May construct OpaqueClosure from custom IRCode for AD"
            impact: "Positive - fixes potential crashes with vararg closures"
          - tool: "GPUCompiler.jl"
            usage: "Uses OpaqueClosure for GPU kernel compilation"
            impact: "Positive - more consistent method instance handling"
          - tool: "Diffractor.jl"
            usage: "Uses OpaqueClosure for forward-mode AD"
            impact: "Positive - fixes vararg differentiation scenarios"

    behavioral:
      - area: "OpaqueClosure vararg handling"
        change: "Vararg signatures no longer normalized during compilation"
        impact: "Bug fix - previously caused segfaults"
        migration: "None required - purely a correctness fix"

  performance:
    compile_time:
      - description: "Marginal improvement by avoiding unnecessary normalization"
        impact: "Negligible"
        estimated: |
          ESTIMATED: <0.1% improvement in OpaqueClosure compilation
          The normalization involves type intersection and method specialization
          lookup, which are now skipped for OC methods. However, OC compilation
          is typically not a hot path in most applications.

    runtime:
      - description: "No runtime performance change"
        impact: "None"
        explanation: |
          The fix only affects the compilation path. Once compiled, the OpaqueClosure
          executes identically. The fix ensures the correct spec_ptr is used, which
          was causing crashes before (not performance issues).

  risk:
    level: "low"
    rationale:
      - "Single-line change with clear, narrow scope"
      - "Adds a check that causes early return in specific case"
      - "is_for_opaque_closure flag is well-established in the codebase (30+ usage sites)"
      - "Change aligns opaque closures with their design intent (no normalization needed)"
      - "Comprehensive regression tests added"
      - "Fix reviewed and merged within hours, indicating straightforward correctness"
      - "The flag is already checked in codegen, inlining, and const-prop paths"

  test_coverage:
    added_tests:
      - description: "OpaqueClosure from specialized vararg IRCode"
        file: "test/opaque_closure.jl"
        loc: "301-307"
        url: "https://github.com/JuliaLang/julia/blob/07b856c0dc1d75b7b5a5bbf451b93a0105385583/test/opaque_closure.jl#L301-L307"
        behavior_locked: |
          Creating OpaqueClosure from IRCode with specialized vararg signature
          (Symbol, Symbol) must work correctly and return proper results.
          f59222(xs...) = length(xs)
          ir = Base.code_ircode_by_type(Tuple{typeof(f59222), Symbol, Symbol})[1][1]
          ir.argtypes[1] = Tuple{}
          oc = OpaqueClosure(ir; isva=true)
          oc(:a, :b) == 2  # Must return 2, not segfault
      - description: "OpaqueClosure from generic vararg IRCode"
        file: "test/opaque_closure.jl"
        loc: "308-313"
        url: "https://github.com/JuliaLang/julia/blob/07b856c0dc1d75b7b5a5bbf451b93a0105385583/test/opaque_closure.jl#L308-L313"
        behavior_locked: |
          Creating OpaqueClosure from IRCode with generic vararg signature
          (Symbol, Vararg{Symbol}) must work correctly with varying argument counts.
          ir = Base.code_ircode_by_type(Tuple{typeof(f59222), Symbol, Vararg{Symbol}})[1][1]
          oc = OpaqueClosure(ir; isva=true)
          oc(:a) == 1      # Single arg
          oc(:a, :b, :c) == 3  # Multiple args

  open_questions: []

  recommendations:
    - |
      Downstream packages using OpaqueClosure with variadic arguments (Enzyme.jl,
      Diffractor.jl, GPUCompiler.jl) should upgrade to Julia versions containing this
      fix to avoid potential segfaults when constructing closures from IRCode.
    - |
      When constructing OpaqueClosure from custom IRCode, always ensure the argtypes
      match the intended signature. The fix ensures consistent handling, but proper
      setup of ir.argtypes is still required.
    - |
      This fix is particularly important for AD packages that synthesize closures
      from optimized IR with specialized argument types.

downstream_impact:
  enzyme:
    relevance: "medium"
    explanation: |
      Enzyme.jl creates OpaqueClosure instances for automatic differentiation. If any
      AD rules involve vararg functions, this fix prevents potential crashes during
      closure compilation. Enzyme uses Core.OpaqueClosure for creating differentiation
      rules and pullback functions.

  gpucompiler:
    relevance: "low"
    explanation: |
      GPUCompiler uses OpaqueClosure for kernel abstraction. While it may benefit from
      the fix, GPU kernels rarely use variadic arguments in the same way as CPU code.

  jet:
    relevance: "low"
    explanation: |
      JET.jl analyzes code statically and may inspect OpaqueClosure method instances.
      This fix doesn't change the analysis API, only ensures correct runtime behavior.


  turing:
    relevance: "low"
    explanation: |
      Turing.jl uses probabilistic programming constructs that may internally use
      OpaqueClosure, but is unlikely to be directly affected by vararg edge cases.

  diffractor:
    relevance: "medium"
    explanation: |
      Diffractor.jl uses OpaqueClosure extensively for forward-mode AD. If any
      differentiated functions have variadic arguments, this fix ensures correct
      behavior when constructing the closure from optimized IR.

reviewer_notes:
  independent_verification:
    - "Verified the fix location at gf.c:3812 adds is_for_opaque_closure check"
    - "Traced full call chain from jl_new_opaque_closure_from_code_info_in_world through compilation"
    - "Confirmed is_for_opaque_closure is set at method.c:1102 in jl_make_opaque_closure_method"
    - "Verified 30+ existing usage sites of is_for_opaque_closure across codegen, inlining, validation"
    - "Confirmed normalization function jl_normalize_to_compilable_sig widens vararg types"
  additional_insights:
    - |
      The bug manifests specifically when using Base.code_ircode_by_type to get IRCode
      with a specialized signature (like Tuple{Symbol, Symbol}), then constructing an
      OpaqueClosure. The IRCode has the unnormalized types in ir.argtypes.
    - |
      The precompile tracing path at gf.c:3342 already skips opaque closures with the
      comment "OpaqueClosure methods cannot be looked up by their types, so are
      incompatible with precompile(...)". This aligns with the design intent that
      OC methods should not be normalized or generalized.
    - |
      The validation code at validation.jl:225-226 enforces that OC methods must have
      sig == Tuple (the broadest signature), which is consistent with the fix - OC
      methods don't participate in normal method table dispatch and shouldn't have
      their specializations normalized.
