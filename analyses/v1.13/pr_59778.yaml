schema_version: "1.0"

pr:
  number: 59778
  title: "add syntax highlighting to the REPL input"
  url: "https://github.com/JuliaLang/julia/pull/59778"
  author: "KristofferC"
  labels:
    - "REPL"
  created_at: "2025-10-08T14:10:10Z"
  merged_at: "2025-10-14T19:46:38Z"
  merge_commit_sha: "f821b82e40c19972e464c96cf5dc1e2395917566"
  diff_url: "https://github.com/JuliaLang/julia/pull/59778.diff"

scope:
  files_touched:
    - "NEWS.md"
    - "contrib/generate_precompile.jl"
    - "stdlib/REPL/docs/src/index.md"
    - "stdlib/REPL/src/LineEdit.jl"
    - "stdlib/REPL/src/REPL.jl"
    - "stdlib/REPL/src/StylingPasses.jl"
    - "stdlib/REPL/src/options.jl"
    - "stdlib/REPL/test/repl.jl"
  components:
    - "Other"
  pipeline_stages: []

analysis:
  intent:
    summary: |
      This PR adds syntax highlighting to the Julia REPL input as you type. Previously,
      syntax highlighting was only available through the external OhMyREPL.jl package.
      With StyledStrings and JuliaSyntaxHighlighting now available as stdlibs, first-class
      support is provided without needing external packages that touch REPL internals.

      The implementation includes:
      1. Syntax highlighting for Julia code (keywords, strings, numbers, types, etc.)
      2. Bracket/parenthesis matching that highlights the enclosing parens at cursor position
      3. A configurable styling passes framework for extensibility
      4. A new `style_input` option (default: true) to enable/disable highlighting

      This brings Julia's REPL to feature parity with Python's new REPL (3.13+) which
      ships with syntax highlighting by default.
    issue_links: []
    quoted_from_pr: |
      Python now ships their default REPL with syntax highlighting, and I find it
      unacceptable that the default Python REPL should be (in some cases) better
      than ours. It has long been possible to get syntax highlighting from the
      external OhMyREPL package, but now, since we have StyledStrings +
      JuliaSyntaxHighlighting as stdlibs, it seems kind of a waste not to use
      those for this.

  direct_changes:
    - summary: "New StylingPasses.jl module providing a framework for REPL input styling"
      component: "REPL.StylingPasses"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/StylingPasses.jl"
          loc: "1-165"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L1-L165"
          snippet: |
            module StylingPasses

            using StyledStrings
            using StyledStrings: Face
            using JuliaSyntaxHighlighting
            import Base: AnnotatedString, annotate!, annotations, JuliaSyntax

            export StylingPass, StylingContext, SyntaxHighlightPass, RegionHighlightPass,
                   EnclosingParenHighlightPass, apply_styling_passes, merge_annotations

            # Context information passed to all styling passes
            struct StylingContext
                cursor_pos::Int
                region_start::Int
                region_stop::Int
            end

            abstract type StylingPass end

            function apply_styling_passes(input::String, passes::Vector{StylingPass}, context::StylingContext)
                if isempty(passes)
                    return AnnotatedString(input)
                end

                # Parse once and share AST across all passes
                ast = JuliaSyntax.parseall(JuliaSyntax.GreenNode, input; ignore_errors=true)

                results = [apply_style(pass, input, ast, context) for pass in passes]
                return merge_annotations(results)
            end

    - summary: "SyntaxHighlightPass delegates to JuliaSyntaxHighlighting.highlight"
      component: "REPL.StylingPasses"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/StylingPasses.jl"
          loc: "56-66"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L56-L66"
          snippet: |
            # Applies Julia syntax highlighting
            struct SyntaxHighlightPass <: StylingPass end

            function (::SyntaxHighlightPass)(input::String, ast, ::StylingContext)
                try
                    return JuliaSyntaxHighlighting.highlight(input, ast)
                catch e
                    @error "Error in SyntaxHighlightPass" exception=(e, catch_backtrace()) maxlog=1
                    return AnnotatedString(input)
                end
            end

    - summary: "EnclosingParenHighlightPass highlights brackets surrounding cursor"
      component: "REPL.StylingPasses"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/StylingPasses.jl"
          loc: "84-110"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L84-L110"
          snippet: |
            # Applies bold styling to parentheses that enclose the cursor position
            struct EnclosingParenHighlightPass <: StylingPass
                face::Face
            end

            EnclosingParenHighlightPass() = EnclosingParenHighlightPass(Face(weight=:bold, underline=true))

            function (pass::EnclosingParenHighlightPass)(input::String, ast, context::StylingContext)
                result = AnnotatedString(input)

                if isempty(input) || context.cursor_pos < 1
                    return result
                end

                try
                    paren_pairs = find_enclosing_parens(input, ast, context.cursor_pos)

                    for (open_pos, close_pos) in paren_pairs
                        annotate!(result, open_pos:open_pos, :face, pass.face)
                        annotate!(result, close_pos:close_pos, :face, pass.face)
                    end
                catch e
                    @error "Error in EnclosingParenHighlightPass" exception=(e, catch_backtrace()) maxlog=1
                end

                return result
            end

    - summary: "New style_input option in REPL.Options (default: true)"
      component: "REPL.Options"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/options.jl"
          loc: "32-55"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/options.jl#L32-L55"
          snippet: |
            mutable struct Options
                # ... other fields ...
                hint_tab_completes::Bool
                auto_insert_closing_bracket::Bool
                style_input::Bool # enable syntax highlighting for input
                # default IOContext settings at the REPL
                iocontext::Dict{Symbol,Any}
            end

            Options(;
                    # ... other defaults ...
                    hint_tab_completes = true,
                    auto_insert_closing_bracket = true,
                    style_input = true,
                    iocontext = Dict{Symbol,Any}()) = ...

    - summary: "Prompt struct gains styling_passes field for configurable passes"
      component: "REPL.LineEdit"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/LineEdit.jl"
          loc: "62-66"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/LineEdit.jl#L62-L66"
          snippet: |
            mutable struct Prompt <: TextInterface
                # ... other fields ...
                hist::HistoryProvider
                sticky::Bool
                styling_passes::Vector{StylingPass}  # Styling passes to apply to input
            end

    - summary: "refresh_multi_line integrates styling passes into display loop"
      component: "REPL.LineEdit"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/LineEdit.jl"
          loc: "633-657"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/LineEdit.jl#L633-L657"
          snippet: |
            styled_buffer = AnnotatedString("")
            if buf.size > 0 && buf.size <= max_highlight_size
                full_input = String(buf.data[1:buf.size])
                if !isempty(full_input)
                    passes = StylingPass[]
                    context = StylingContext(buf_pos, regstart, regstop)

                    # Add prompt-specific styling passes if the prompt has them and styling is enabled
                    enable_style_input = prompt_obj === nothing ? false :
                        (isdefined(prompt_obj, :repl) && prompt_obj.repl !== nothing ?
                            prompt_obj.repl.options.style_input : false)

                    if enable_style_input && prompt_obj !== nothing
                        append!(passes, prompt_obj.styling_passes)
                    end

                    if region_active
                        push!(passes, RegionHighlightPass())
                    end

                    if !isempty(passes)
                        styled_buffer = apply_styling_passes(full_input, passes, context)
                    end
                end
            end

    - summary: "Julia prompt configured with SyntaxHighlightPass and EnclosingParenHighlightPass"
      component: "REPL"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/REPL.jl"
          loc: "1295-1301"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/REPL.jl#L1295-L1301"
          snippet: |
            julia_prompt = Prompt(contextual_prompt(repl, JULIA_PROMPT),
                # ... other args ...
                repl = repl,
                complete = replc,
                on_enter = return_callback,
                styling_passes = StylingPasses.StylingPass[
                    StylingPasses.SyntaxHighlightPass(),
                    StylingPasses.EnclosingParenHighlightPass()
                ])

    - summary: "Fast path disabled when syntax highlighting is enabled"
      component: "REPL.LineEdit"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/LineEdit.jl"
          loc: "1049-1051"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/LineEdit.jl#L1049-L1051"
          snippet: |
            # Disable fast path when syntax highlighting is enabled
            use_fast_path = offset + textwidth(str) <= w && !(after == 0 && delayup) && !options(s).style_input
            if use_fast_path

    - summary: "max_highlight_size constant limits highlighting to 10KB inputs"
      component: "REPL.LineEdit"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/LineEdit.jl"
          loc: "575"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/LineEdit.jl#L575"
          snippet: |
            max_highlight_size::Int = 10000 # bytes

  secondary_effects:
    - effect: "JuliaSyntax parser invoked on every keypress when highlighting is enabled"
      mechanism: |
        refresh_multi_line() in LineEdit.jl [lines 633-657]
          -> apply_styling_passes(full_input, passes, context) [StylingPasses.jl:44]
            -> JuliaSyntax.parseall(JuliaSyntax.GreenNode, input; ignore_errors=true) [StylingPasses.jl:50]
            -> For each pass: pass(input, ast, context)

        The parsing is done with ignore_errors=true to handle incomplete input gracefully.
        The AST is parsed once and shared across all passes to avoid redundant parsing.

        Performance consideration: JuliaSyntax.parseall is called on every refresh,
        which happens on every keypress. For typical REPL inputs (<1KB), this is
        negligible. For very large inputs (>10KB), highlighting is disabled entirely.
      downstream_surfaces:
        - "REPL responsiveness during typing"
        - "CPU usage while typing in REPL"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/StylingPasses.jl"
          loc: "44-54"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L44-L54"
          snippet: |
            function apply_styling_passes(input::String, passes::Vector{StylingPass}, context::StylingContext)
                if isempty(passes)
                    return AnnotatedString(input)
                end

                # Parse once and share AST across all passes
                ast = JuliaSyntax.parseall(JuliaSyntax.GreenNode, input; ignore_errors=true)

                results = [apply_style(pass, input, ast, context) for pass in passes]
                return merge_annotations(results)
            end

    - effect: "Shell mode and other non-Julia modes do not have syntax highlighting"
      mechanism: |
        Only the main Julia prompt is configured with styling passes.
        Shell mode, help mode, and pkg mode have empty styling_passes vectors.

        In REPL.jl setup_interface():
          - julia_prompt: styling_passes = [SyntaxHighlightPass(), EnclosingParenHighlightPass()]
          - help_mode: styling_passes = [] (default empty)
          - shell_mode: styling_passes = [] (default empty)
          - pkg_mode: styling_passes = [] (default empty)

        The History/prompt.jl module also explicitly passes an empty vector:
          styling_passes = REPL.StylingPasses.StylingPass[]
      downstream_surfaces:
        - "Users expecting highlighting in shell mode"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/History/prompt.jl"
          loc: "66-77"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/History/prompt.jl#L66-L77"
          snippet: |
            prompt = REPL.LineEdit.Prompt(
                PROMPT_TEXT,
                prefix, "\e[0m",
                "", "", "",
                select_keymap(events),
                nothing,
                REPL.LatexCompletions(),
                _ -> true,
                () -> nothing,
                REPL.LineEdit.EmptyHistoryProvider(),
                false,
                REPL.StylingPasses.StylingPass[]) # styling_passes - empty

    - effect: "Fast path optimization disabled when highlighting is enabled"
      mechanism: |
        edit_insert() in LineEdit.jl has a fast path that avoids full screen refresh
        when appending characters at the end of a line. This fast path is explicitly
        disabled when style_input is enabled:

        use_fast_path = offset + textwidth(str) <= w &&
                        !(after == 0 && delayup) &&
                        !options(s).style_input  # <-- disables if highlighting on

        This is necessary because highlighting requires re-rendering the entire line
        with updated syntax colors. The fast path only writes the new character,
        which would leave it unhighlighted.
      downstream_surfaces:
        - "REPL typing performance when appending to end of line"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/LineEdit.jl"
          loc: "1044-1056"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/LineEdit.jl#L1044-L1056"
          snippet: |
            offset = s.ias.curs_row == 1 || s.indent < 0 ?
                sizeof(prompt_string(s.p.prompt)::String) : s.indent
            offset += position(buf) - beginofline(buf)
            spinner = '\0'
            delayup = !eof(buf) || old_wait
            # Disable fast path when syntax highlighting is enabled
            use_fast_path = offset + textwidth(str) <= w && !(after == 0 && delayup) && !options(s).style_input
            if use_fast_path
                # Avoid full update when appending characters to the end
                # and an update of curs_row isn't necessary
                write(termbuf, str)
                spinner = ' '

    - effect: "Region highlighting now uses AnnotatedString faces instead of raw ANSI codes"
      mechanism: |
        Previously, region highlighting (for text selection) used raw ANSI escape codes:
          lwrite = lwrite[1:i] * Base.text_colors[:reverse] * lwrite[nextind(lwrite, i):end]

        Now it uses the RegionHighlightPass which annotates with Face(inverse=true):
          annotate!(result, region_range, :face, Face(inverse=true))

        This is more consistent with the StyledStrings framework and allows proper
        merging of multiple styling annotations.
      downstream_surfaces:
        - "Visual appearance of selected text regions"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/StylingPasses.jl"
          loc: "68-82"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L68-L82"
          snippet: |
            # Applies inverse video styling to the selected region
            struct RegionHighlightPass <: StylingPass end

            function (::RegionHighlightPass)(input::String, ::Any, context::StylingContext)
                result = AnnotatedString(input)

                if context.region_start > 0 && context.region_stop >= context.region_start
                    # Add inverse face to the region
                    # Region positions are 1-based byte positions
                    region_range = context.region_start:context.region_stop
                    annotate!(result, region_range, :face, Face(inverse=true))
                end

                return result
            end

    - effect: "JuliaSyntaxHighlighting stdlib dependency added to REPL"
      mechanism: |
        REPL now depends on JuliaSyntaxHighlighting stdlib for the actual highlighting.
        This dependency was added to:
        - stdlib/REPL/Project.toml
        - stdlib/Manifest.toml

        JuliaSyntaxHighlighting provides:
        - highlight(input::String) -> AnnotatedString
        - highlight(input::String, ast) -> AnnotatedString (used here)
        - Customizable face definitions via TOML config
      downstream_surfaces:
        - "REPL load time"
        - "REPL memory usage"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "stdlib/REPL/Project.toml"
          loc: "9"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/Project.toml#L9"
          snippet: |
            JuliaSyntaxHighlighting = "ac6e5ff7-fb65-4e79-a425-ec3bc9c03011"

    - effect: "Error handling in passes prevents crashes from malformed input"
      mechanism: |
        Both SyntaxHighlightPass and EnclosingParenHighlightPass wrap their core
        logic in try-catch blocks, logging errors at most once and returning
        plain unhighlighted text on failure:

        try
            return JuliaSyntaxHighlighting.highlight(input, ast)
        catch e
            @error "Error in SyntaxHighlightPass" exception=(e, catch_backtrace()) maxlog=1
            return AnnotatedString(input)
        end

        This ensures the REPL remains usable even if highlighting fails for
        some edge case input.

        NOTE: InterruptException is NOT explicitly re-thrown, which means Ctrl-C
        during highlighting would be caught and logged rather than interrupting.
        In practice this is unlikely to be an issue since JuliaSyntax parsing
        is very fast and doesn't check for interrupts.
      downstream_surfaces:
        - "REPL stability with unusual input"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/StylingPasses.jl"
          loc: "59-66"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L59-L66"
          snippet: |
            function (::SyntaxHighlightPass)(input::String, ast, ::StylingContext)
                try
                    return JuliaSyntaxHighlighting.highlight(input, ast)
                catch e
                    @error "Error in SyntaxHighlightPass" exception=(e, catch_backtrace()) maxlog=1
                    return AnnotatedString(input)
                end
            end

    - effect: "merge_annotations creates duplicate annotations from first source"
      mechanism: |
        The merge_annotations function copies the first AnnotatedString's annotations
        via the constructor, then iterates over ALL sources including the first one,
        adding all annotations again:

        result = AnnotatedString(annotated_strings[1])  # Copies first string's annotations
        for source in annotated_strings                 # Includes first string!
            for ann in annotations(source)
                annotate!(result, ann.region, ann.label, ann.value)  # Duplicates first's annotations
            end
        end

        This creates duplicate annotations from the first source. The StyledStrings
        system likely handles this gracefully (duplicate annotations may merge or
        be ignored), but it is technically inefficient.
      downstream_surfaces:
        - "Memory usage with multiple passes"
        - "Potential subtle rendering differences if duplicates are handled unexpectedly"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/StylingPasses.jl"
          loc: "26-38"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L26-L38"
          snippet: |
            function merge_annotations(annotated_strings::Vector{<:AnnotatedString})
                isempty(annotated_strings) && return AnnotatedString("")

                result = AnnotatedString(annotated_strings[1])

                for source in annotated_strings
                    for ann in annotations(source)
                        annotate!(result, ann.region, ann.label, ann.value)
                    end
                end

                return result
            end

    - effect: "PrefixSearchState gets styling from parent prompt"
      mechanism: |
        When doing prefix history search (triggered by up/down arrows after typing),
        the code extracts styling passes from the parent prompt:

        prompt_obj = nothing
        if prompt isa PromptState
            prompt_obj = prompt.p
        elseif prompt isa PrefixSearchState
            if isdefined(prompt, :parent) && prompt.parent isa Prompt
                prompt_obj = prompt.parent
            end
        end

        This allows highlighting to work during prefix history search. However,
        interactive reverse-i-search (Ctrl-R) uses a different state type
        and does NOT have this handling, so highlighting is not applied during
        reverse-i-search.
      downstream_surfaces:
        - "User experience during history navigation"
      likelihood: "medium"
      impact: "low"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/LineEdit.jl"
          loc: "623-631"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/LineEdit.jl#L623-L631"
          snippet: |
            # Get the styling passes from the prompt
            prompt_obj = nothing
            if prompt isa PromptState
                prompt_obj = prompt.p
            elseif prompt isa PrefixSearchState
                if isdefined(prompt, :parent) && prompt.parent isa Prompt
                    prompt_obj = prompt.parent
                end
            end

    - effect: "AST tree walk for paren matching is O(n) per keypress"
      mechanism: |
        The EnclosingParenHighlightPass walks the entire AST tree to find all
        paren/bracket/curly tokens. The walk_tree function recurses through
        all children:

        function walk_tree(f::Function, node, content::String, offset::UInt32)
            f(node, offset)
            if JuliaSyntax.numchildren(node) > 0
                for child in JuliaSyntax.children(node)
                    walk_tree(f, child, content, offset)
                    offset += JuliaSyntax.span(child)
                end
            end
        end

        This is O(n) where n is the number of AST nodes. For typical REPL inputs
        this is fast, but could be noticeable for very deeply nested expressions.
        Combined with the JuliaSyntax.parseall call, each keypress requires:
        1. Full parse of input string
        2. Full AST walk for syntax highlighting (in JuliaSyntaxHighlighting)
        3. Full AST walk for paren matching
      downstream_surfaces:
        - "REPL latency on complex expressions"
      likelihood: "medium"
      impact: "low"
      evidence:
        - source: "code"
          path: "stdlib/REPL/src/StylingPasses.jl"
          loc: "154-163"
          url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L154-L163"
          snippet: |
            function walk_tree(f::Function, node, content::String, offset::UInt32)
                f(node, offset)

                if JuliaSyntax.numchildren(node) > 0
                    for child in JuliaSyntax.children(node)
                        walk_tree(f, child, content, offset)
                        offset += JuliaSyntax.span(child)
                    end
                end
            end

  compatibility:
    public_api:
      - summary: "New REPL.Options field: style_input (Bool, default true)"
        evidence:
          - source: "code"
            path: "stdlib/REPL/src/options.jl"
            loc: "32"
            url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/options.jl#L32"
            snippet: |
              style_input::Bool # enable syntax highlighting for input
      - summary: "New Prompt field: styling_passes (Vector{StylingPass})"
        evidence:
          - source: "code"
            path: "stdlib/REPL/src/LineEdit.jl"
            loc: "65"
            url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/LineEdit.jl#L65"
            snippet: |
              styling_passes::Vector{StylingPass}  # Styling passes to apply to input
    internal_api:
      - summary: "New module REPL.StylingPasses with exported types and functions"
        evidence:
          - source: "code"
            path: "stdlib/REPL/src/StylingPasses.jl"
            loc: "12-13"
            url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L12-L13"
            snippet: |
              export StylingPass, StylingContext, SyntaxHighlightPass, RegionHighlightPass,
                     EnclosingParenHighlightPass, apply_styling_passes, merge_annotations
    behavioral:
      - summary: "REPL input is now colored by default; disable with repl.options.style_input = false"
        evidence:
          - source: "diff"
            path: "stdlib/REPL/docs/src/index.md"
            loc: "536-542"
            url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/docs/src/index.md#L536-L542"
            snippet: |
              ## Syntax Highlighting

              The REPL provides syntax highlighting for input as you type.
              Syntax highlighting is enabled by default but can be disabled in your `~/.julia/config/startup.jl`:

              ```julia
              atreplinit() do repl
                  repl.options.style_input = false
              end
              ```

  performance:
    compile_time:
      - summary: "ESTIMATED: Slight increase in REPL precompilation time"
        evidence:
          - source: "diff"
            path: "contrib/generate_precompile.jl"
            loc: "44"
            url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/contrib/generate_precompile.jl#L44"
            snippet: |
              precompile(Tuple{typeof(Base.isempty), Base.AnnotatedString{String}}
    runtime:
      - summary: "ESTIMATED: Minor overhead per keypress for syntax parsing and highlighting"
        evidence:
          - source: "code"
            path: "stdlib/REPL/src/StylingPasses.jl"
            loc: "50"
            url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L50"
            snippet: |
              ast = JuliaSyntax.parseall(JuliaSyntax.GreenNode, input; ignore_errors=true)
      - summary: "Inputs >10KB skip highlighting to bound worst-case overhead"
        evidence:
          - source: "code"
            path: "stdlib/REPL/src/LineEdit.jl"
            loc: "575"
            url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/LineEdit.jl#L575"
            snippet: |
              max_highlight_size::Int = 10000 # bytes

  tests:
    changed_files:
      - "stdlib/REPL/test/repl.jl"
    new_behavior_assertions:
      - "Julia prompt has two styling passes (SyntaxHighlightPass, EnclosingParenHighlightPass)"
      - "Shell mode has zero styling passes"
      - "Keyword 'function' receives ANSI escape codes when highlighted"
      - "Unicode identifiers are preserved during highlighting"
      - "Multi-line input has keywords highlighted"
      - "Bracket highlighting adds bold/underline codes near cursor"
      - "style_input=false disables syntax highlighting"
    coverage_gaps:
      - "No explicit test for max_highlight_size boundary (10KB inputs)"
      - "No test for RegionHighlightPass (region selection highlighting)"
      - "No performance regression tests for typing latency"
      - "No test for PrefixSearchState code path (prefix history search with styling)"
      - "No test for deeply nested parentheses performance"

  risk:
    level: "low"
    rationale:
      - "Feature is opt-out (default on) but easily disabled via startup.jl"
      - "Error handling prevents crashes from malformed input"
      - "Large inputs (>10KB) automatically skip highlighting"
      - "No changes to compiler, type inference, or codegen"
      - "Uses existing well-tested stdlibs (JuliaSyntax, JuliaSyntaxHighlighting, StyledStrings)"
      - "Author (KristofferC) is core Julia developer with deep REPL knowledge"
      - "PR received 25 positive reactions (18 hearts, 7 rockets)"

  open_questions:
    - question: "Does highlighting noticeably slow down typing on slow machines?"
      resolved: false
      answer: |
        No benchmarks provided in PR. JuliaSyntax is designed to be fast, and typical
        REPL inputs are small (<1KB). The 10KB limit provides a safety bound.
        OhMyREPL has provided similar functionality without reported performance issues.

    - question: "Can users customize which passes are applied?"
      resolved: true
      answer: |
        Not directly via API. The styling_passes vector is set at prompt creation.
        Users can disable all highlighting via style_input=false, or customize
        colors via faces.toml configuration file.

    - question: "Why not highlight shell mode, help mode, etc.?"
      resolved: true
      answer: |
        Shell mode uses bash syntax, not Julia syntax. Help mode uses markdown.
        JuliaSyntaxHighlighting is specifically for Julia code. Future PRs could
        add appropriate highlighters for other modes.

    - question: "Does merge_annotations produce duplicate annotations?"
      resolved: false
      answer: |
        Yes, the implementation copies the first string's annotations via
        AnnotatedString(annotated_strings[1]), then loops over ALL strings
        including the first, adding all annotations again. This creates
        duplicates from the first source. Testing would be needed to verify
        whether StyledStrings handles duplicates gracefully (likely yes).

    - question: "Why is reverse-i-search (Ctrl-R) not styled?"
      resolved: true
      answer: |
        The refresh_multi_line function for SearchState (reverse-i-search) has
        its own implementation that doesn't extract styling passes. Only
        PromptState and PrefixSearchState are handled in the main refresh path.
        This appears to be by design since the search prompt has different
        visual requirements.

  recommendations:
    - "No action required for most users - highlighting improves REPL experience"
    - "Users who prefer plain text can add repl.options.style_input = false to startup.jl"
    - "Users can customize colors via ~/.julia/config/faces.toml"
    - "Package developers using REPL internals should note new Prompt.styling_passes field"
    - "OhMyREPL users may want to compare behavior and decide which to use"

changelog_entry:
  category: "REPL"
  breaking: false
  summary: |
    The Julia REPL now provides syntax highlighting for input as you type.
    Keywords, strings, numbers, comments, and other syntax elements are
    colored based on a customizable theme. Additionally, parentheses,
    brackets, and braces surrounding the cursor position are highlighted.
    Highlighting can be disabled with `repl.options.style_input = false`
    in startup.jl.
  downstream_impact: |
    Users see colored REPL input by default. No API changes affect most packages.
    Packages that directly manipulate REPL Prompt objects should note the new
    styling_passes field.

downstream_package_impact:
  Turing_jl: "none - REPL feature does not affect package functionality"
  Enzyme_jl: "none - REPL feature does not affect differentiation"
  GPUCompiler: "none - REPL feature does not affect GPU compilation"
  JET: "none - REPL feature does not affect static analysis"
  IRTools: "none - REPL feature does not affect IR manipulation"
  Cassette: "none - REPL feature does not affect code transformation"
  OhMyREPL: |
    potential overlap - OhMyREPL provides similar syntax highlighting functionality.
    Users may choose to use built-in highlighting instead of OhMyREPL, or use OhMyREPL
    for its additional features (bracket pair matching, prompt customization, etc.)
    that go beyond what this PR provides.

code_path_trace:
  highlighting_on_keypress:
    description: "How syntax highlighting is applied when user types"
    steps:
      - location: "stdlib/REPL/src/LineEdit.jl:1043-1056"
        url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/LineEdit.jl#L1043-L1056"
        code: |
          function edit_insert(s::PromptState, c::StringLike)
              # ... buffer manipulation ...
              use_fast_path = offset + textwidth(str) <= w &&
                              !(after == 0 && delayup) &&
                              !options(s).style_input  # Fast path disabled if highlighting
              if use_fast_path
                  write(termbuf, str)  # Just write char directly
              else
                  refresh_multi_line(s)  # Full refresh with highlighting
        explanation: "Character insertion triggers full refresh when highlighting enabled"

      - location: "stdlib/REPL/src/LineEdit.jl:577-590"
        url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/LineEdit.jl#L577-L590"
        code: |
          function refresh_multi_line(s::PromptState; kw...)
              # ... timer handling ...
              r = refresh_multi_line(terminal(s), s; kw...)
              maybe_show_hint(s)
              return r
          end
        explanation: "PromptState refresh_multi_line delegates to terminal-based version"

      - location: "stdlib/REPL/src/LineEdit.jl:633-657"
        url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/LineEdit.jl#L633-L657"
        code: |
          styled_buffer = AnnotatedString("")
          if buf.size > 0 && buf.size <= max_highlight_size
              full_input = String(buf.data[1:buf.size])
              if !isempty(full_input)
                  passes = StylingPass[]
                  context = StylingContext(buf_pos, regstart, regstop)

                  enable_style_input = prompt_obj === nothing ? false :
                      (isdefined(prompt_obj, :repl) && prompt_obj.repl !== nothing ?
                          prompt_obj.repl.options.style_input : false)

                  if enable_style_input && prompt_obj !== nothing
                      append!(passes, prompt_obj.styling_passes)
                  end
                  if !isempty(passes)
                      styled_buffer = apply_styling_passes(full_input, passes, context)
                  end
              end
          end
        explanation: "refresh_multi_line collects passes and calls apply_styling_passes"

      - location: "stdlib/REPL/src/StylingPasses.jl:44-54"
        url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L44-L54"
        code: |
          function apply_styling_passes(input::String, passes::Vector{StylingPass}, context::StylingContext)
              if isempty(passes)
                  return AnnotatedString(input)
              end
              # Parse once and share AST across all passes
              ast = JuliaSyntax.parseall(JuliaSyntax.GreenNode, input; ignore_errors=true)
              results = [apply_style(pass, input, ast, context) for pass in passes]
              return merge_annotations(results)
          end
        explanation: "Parses input once, applies all passes, merges annotations"

  paren_matching_algorithm:
    description: "How enclosing parentheses are found"
    steps:
      - location: "stdlib/REPL/src/StylingPasses.jl:112-121"
        url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L112-L121"
        code: |
          function paren_type(k)
              if     k == JuliaSyntax.K"(";  1, :paren
              elseif k == JuliaSyntax.K")"; -1, :paren
              elseif k == JuliaSyntax.K"[";  1, :bracket
              elseif k == JuliaSyntax.K"]"; -1, :bracket
              elseif k == JuliaSyntax.K"{";  1, :curly
              elseif k == JuliaSyntax.K"}"; -1, :curly
              else                           0, :none
              end
          end
        explanation: "Classifies tokens as opening (+1), closing (-1), or neither (0)"

      - location: "stdlib/REPL/src/StylingPasses.jl:123-152"
        url: "https://github.com/JuliaLang/julia/blob/f821b82e40c19972e464c96cf5dc1e2395917566/stdlib/REPL/src/StylingPasses.jl#L123-L152"
        code: |
          function find_enclosing_parens(content::String, ast, cursor_pos::Int)
              innermost_pairs = Dict{Symbol,Tuple{Int,Int}}()
              paren_stack = Tuple{Int,Int,Symbol}[]  # (open_pos, depth, type)

              walk_tree(ast, content, UInt32(0)) do node, offset
                  nkind = JuliaSyntax.kind(node)
                  pos = firstindex(content) + offset
                  depthchange, ptype = paren_type(nkind)

                  if ptype != :none
                      if depthchange > 0
                          push!(paren_stack, (pos, length(paren_stack) + 1, ptype))
                      elseif depthchange < 0 && !isempty(paren_stack)
                          open_pos, depth, open_ptype = pop!(paren_stack)
                          if open_ptype == ptype && open_pos <= cursor_pos < pos
                              if !haskey(innermost_pairs, ptype) ||
                                 (pos - open_pos) < (innermost_pairs[ptype][2] - innermost_pairs[ptype][1])
                                  innermost_pairs[ptype] = (open_pos, pos)
                              end
                          end
                      end
                  end
              end
              return collect(values(innermost_pairs))
          end
        explanation: |
          Walks AST to find all paren/bracket/curly tokens.
          Uses a stack to match opening/closing pairs.
          Keeps only innermost pair per type that contains cursor.

test_coverage:
  new_tests:
    - file: "stdlib/REPL/test/repl.jl"
      lines: "2032-2041"
      description: "Tests that syntax highlighting is disabled when style_input=false"
      code: |
        # Test that syntax highlighting can be disabled
        fake_repl(options = REPL.Options(confirm_exit=false, style_input=false)) do stdin_write, stdout_read, repl
            repl.interface = REPL.setup_interface(repl)

            repltask = @async begin
                REPL.run_repl(repl)
            end

            # Even though the prompt has styling passes, they shouldn't be applied
            write(stdin_write, "function")
            s = readuntil(stdout_read, "function", keep=true)
            # With style_input=false, there should be no color codes from syntax highlighting
            @test occursin("function", s)

            write(stdin_write, "\x03")  # Ctrl-C to cancel
            write(stdin_write, '\x04')  # Exit
            Base.wait(repltask)
        end

    - file: "stdlib/REPL/test/repl.jl"
      lines: "1984-2000"
      description: "Tests that Julia prompt has styling passes and they work"
      code: |
        fake_repl(options = REPL.Options(confirm_exit=false, style_input=true)) do stdin_write, stdout_read, repl
            repl.interface = REPL.setup_interface(repl)
            julia_prompt = repl.interface.modes[1]
            shell_mode = repl.interface.modes[3]

            # Julia prompt should have syntax highlighting passes
            @test length(julia_prompt.styling_passes) == 2
            @test any(p -> p isa StylingPasses.SyntaxHighlightPass, julia_prompt.styling_passes)
            @test any(p -> p isa StylingPasses.EnclosingParenHighlightPass, julia_prompt.styling_passes)

            # Shell mode should not have syntax highlighting passes
            @test length(shell_mode.styling_passes) == 0

reviewer_notes:
  initial_reviewer: "automated_analysis"
  initial_date: "2026-01-21"
  verification_method: |
    1. Read PR description and metadata from cached JSON
    2. Examined StylingPasses.jl - new module providing styling framework
    3. Traced call chain from edit_insert -> refresh_multi_line -> apply_styling_passes
    4. Verified JuliaSyntax integration (parseall with ignore_errors=true)
    5. Checked that shell/help modes don't have styling passes
    6. Reviewed test coverage for highlighting behavior
    7. Searched for usages of StylingPass across codebase
  findings:
    - "This is a REPL UI feature, not a compiler change"
    - "Uses JuliaSyntax.parseall for parsing, but only for display purposes"
    - "Error handling ensures REPL stability even if highlighting fails"
    - "10KB limit prevents performance issues on large inputs"
    - "Well-integrated with existing StyledStrings/AnnotatedString infrastructure"
    - "Extensible design allows future passes to be added"
  confidence: "high"
  rationale: |
    The PR is well-scoped to REPL functionality and does not affect the compiler,
    type inference, or code generation. The integration with JuliaSyntax is purely
    for UI rendering. The error handling and size limits provide good safety margins.

  second_review:
    reviewer: "independent_analysis"
    date: "2026-01-21"
    verification_method: |
      1. Read actual source files from Julia repository (not just PR patches)
      2. Compared JSON patch data with current codebase state
      3. Traced prompt_obj extraction code path for all state types
      4. Analyzed merge_annotations function for correctness
      5. Examined walk_tree recursion and complexity
      6. Verified error handling behavior (InterruptException)
      7. Cross-referenced test coverage with code paths
    additional_findings:
      - title: "merge_annotations has duplicate annotation issue"
        description: |
          The function copies first string's annotations via constructor, then
          loops over ALL strings including the first, adding annotations again.
          This creates duplicates. While likely benign, it's suboptimal.
        severity: "minor"
        code_path: "StylingPasses.jl:26-38"
      - title: "InterruptException not re-thrown in error handlers"
        description: |
          The error handling in SyntaxHighlightPass and EnclosingParenHighlightPass
          catches all exceptions including InterruptException. If highlighting
          got stuck, Ctrl-C would be caught rather than interrupting. In practice
          this is unlikely since JuliaSyntax is fast.
        severity: "minor"
        code_path: "StylingPasses.jl:59-66, 98-107"
      - title: "Only PrefixSearchState handled for styling extraction"
        description: |
          The code handles PromptState and PrefixSearchState but not other state
          types. Reverse-i-search (Ctrl-R) uses a different code path with its own
          refresh_multi_line that doesn't apply syntax highlighting.
        severity: "informational"
        code_path: "LineEdit.jl:623-631"
      - title: "AST parsed once and shared across passes (optimization)"
        description: |
          The apply_styling_passes function parses the AST once and passes it to
          all styling passes. This is an important optimization that wasn't fully
          clear from the initial analysis snippets. Each pass receives both the
          input string AND the pre-parsed AST.
        severity: "positive"
        code_path: "StylingPasses.jl:44-54"
      - title: "walk_tree is recursive O(n) AST traversal"
        description: |
          The paren matching performs a full recursive walk of the AST on every
          keypress. Combined with JuliaSyntax parsing and JuliaSyntaxHighlighting's
          own walk, this is three full passes per keypress. Performance is bounded
          by the 10KB limit but could be optimized.
        severity: "informational"
        code_path: "StylingPasses.jl:154-163"
    corrections_to_initial_analysis:
      - "Snippet at line 282-298 showed apply_style without ast parameter; actual code passes ast"
      - "paren_matching_algorithm snippet now shows correct UInt32 offset type"
      - "Added missing test coverage gaps for PrefixSearchState and nested parens"
    confidence: "high"
    rationale: |
      Independent code review confirms the initial analysis is accurate for the core
      functionality. Additional secondary effects identified are all low-impact edge
      cases. The implementation is sound and well-designed. The merge_annotations
      inefficiency and InterruptException handling are minor issues that don't affect
      normal usage. Overall risk assessment remains LOW.
