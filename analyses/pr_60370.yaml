schema_version: "1.0"
pr:
  number: 60370
  title: "Move `SyntaxGraph`/`SyntaxTree` from JuliaLowering to JuliaSyntax"
  url: "https://github.com/JuliaLang/julia/pull/60370"
  author: "mlechu"
  labels:
    - "JuliaLowering"
  merged_at: "2025-12-12T20:51:11Z"
  merge_commit_sha: "f40b11726530f33fef72a8fc62aaf38990139ba5"
  diff_url: "https://github.com/JuliaLang/julia/pull/60370.diff"
scope:
  files_touched:
    - "JuliaLowering/src/JuliaLowering.jl"
    - "JuliaLowering/src/ast.jl"
    - "JuliaLowering/src/compat.jl"
    - "JuliaLowering/src/desugaring.jl"
    - "JuliaSyntax/src/JuliaSyntax.jl"
    - "JuliaSyntax/src/porcelain/syntax_graph.jl"
    - "JuliaSyntax/src/porcelain/syntax_node.jl"
    - "JuliaSyntax/test/runtests.jl"
    - "JuliaSyntax/test/syntax_graph.jl"
    - "JuliaSyntax/test/syntax_node.jl"
  components:
    - "JuliaSyntax"
    - "JuliaLowering"
  pipeline_stages:
    - "Parsing"
    - "ASTDataStructures"
analysis:
  intent:
    summary: "Move the ECS-style SyntaxGraph/SyntaxTree infrastructure and related helpers/tests from JuliaLowering into JuliaSyntax, clarifying the distinction between SyntaxNode and SyntaxTree while keeping JuliaLowering functionality wired through JuliaSyntax."
    issue_links: []
  direct_changes:
    - summary: "Defines SyntaxGraph and SyntaxTree in JuliaSyntax porcelain, documenting SyntaxTree as an unstable ECS-style AST and providing core graph/attribute machinery there."
      component: "JuliaSyntax/porcelain"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
          loc: "1-199"
          url: "https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/src/porcelain/syntax_graph.jl#L1-L199"
          snippet: |
            """
            Directed graph with arbitrary attributes on nodes. Used here for representing
            one or several syntax trees.

            TODO: Global attributes!
            """
            mutable struct SyntaxGraph{Attrs}
                edge_ranges::Vector{UnitRange{Int}}
                edges::Vector{NodeId}
                attributes::Attrs
            end

            SyntaxGraph() = SyntaxGraph{Dict{Symbol,Any}}(Vector{UnitRange{Int}}(),
                                                          Vector{NodeId}(), Dict{Symbol,Any}())

            """
                struct SyntaxTree

            An ECS-style AST used in JuliaLowering.  Unstable, but may eventually replace
            SyntaxNode.
            """
            struct SyntaxTree{GraphType}
                _graph::GraphType
                _id::NodeId
            end
    - summary: "JuliaLowering now imports SyntaxGraph/SyntaxTree and related helpers directly from JuliaSyntax, relying on JuliaSyntax-provided constructors and traversal utilities."
      component: "JuliaLowering"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/JuliaLowering.jl"
          loc: "15-28"
          url: "https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaLowering/src/JuliaLowering.jl#L15-L28"
          snippet: |
            using .JuliaSyntax: highlight, Kind, @KSet_str, is_leaf, children, numchildren,
                head, kind, flags, has_flags, filename, first_byte, last_byte, byte_range,
                sourcefile, source_location, span, sourcetext, is_literal, is_infix_op_call,
                is_postfix_op_call, @isexpr, SyntaxHead, is_syntactic_operator,
                SyntaxGraph, SyntaxTree, SyntaxList, NodeId, SourceRef, SourceAttrType,
                ensure_attributes, ensure_attributes!, delete_attributes, newnode!, hasattr,
                setattr, setattr!, syntax_graph, is_compatible_graph,
                check_compatible_graph, copy_node, copy_ast, provenance, sourceref,
                reparent, makeleaf, makenode, mapchildren, mapleaf, flattened_provenance
        - source: "code"
          path: "JuliaSyntax/src/porcelain/syntax_graph.jl"
          loc: "570-615"
          url: "https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/src/porcelain/syntax_graph.jl#L570-L615"
          snippet: |
            #-------------------------------------------------------------------------------
            # AST creation utilities

            # TODO: "proto", if SyntaxTree, is rarely different from srcref. reorganize to:
            # newnode/newleaf(ctx, srcref, k::Kind[, attrs])
            # makenode/makeleaf(ctx, old::SyntaxTree[, attrs])

            _node_id(graph::SyntaxGraph, ex::SyntaxTree) = (check_compatible_graph(graph, ex); ex._id)

            function makeleaf(graph::SyntaxGraph, srcref, proto::Union{Kind, SyntaxTree})
                id = newnode!(graph)
                ex = SyntaxTree(graph, id)
                copy_attrs!(ex, proto, true)
                ex.source = _unpack_srcref(graph, srcref)
                return ex
            end

            function makenode(ctx, srcref, proto, children, attrs=nothing)
                graph = syntax_graph(ctx)
                ex = isnothing(attrs) ? makeleaf(graph, srcref, proto) :
                    makeleaf(graph, srcref, proto, attrs)
                setchildren!(graph, ex._id, children isa SyntaxList ? children.ids : children)
                return ex
            end
    - summary: "JuliaLowering supplies SyntaxTree-to-Expr conversion hooks by overriding JuliaSyntax leaf/child fixups and routing Base.Expr to JuliaSyntax.to_expr." 
      component: "JuliaLowering/compat"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/compat.jl"
          loc: "591-628"
          url: "https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaLowering/src/compat.jl#L591-L628"
          snippet: |
            function JuliaSyntax._expr_leaf_val(ex::SyntaxTree, _...)
                name = get(ex, :name_val, nothing)
                if !isnothing(name)
                    n = Symbol(name)
                    if kind(ex) === K"Symbol"
                        return QuoteNode(n)
                    elseif hasattr(ex, :scope_layer)
                        Expr(:scope_layer, n, ex.scope_layer)
                    else
                        n
                    end
                else
                    val = get(ex, :value, nothing)
                    if kind(ex) == K"Value" && val isa Expr || val isa LineNumberNode
                        # Expr AST embedded in a SyntaxTree should be quoted rather than
                        # becoming part of the output AST.
                        QuoteNode(val)
                    else
                        val
                    end
                end
            end

            function JuliaSyntax.fixup_Expr_child(::Type{<:SyntaxTree}, head::SyntaxHead,
                                                  @nospecialize(arg), first::Bool)
                isa(arg, Expr) || return arg
                k = kind(head)
                coalesce_dot = k in KSet"call dotcall curly" ||
                               (k == K"quote" && has_flags(head, JuliaSyntax.COLON_QUOTE))
                if @isexpr(arg, :., 1) && arg.args[1] isa Tuple
                    h, a = arg.args[1]::Tuple{SyntaxHead,Any}
                    arg = ((coalesce_dot && first) || is_syntactic_operator(h)) ?
                        Symbol(".", a) : Expr(:., a)
                end
                return arg
            end

            Base.Expr(ex::SyntaxTree) = JuliaSyntax.to_expr(ex)
        - source: "code"
          path: "JuliaSyntax/src/integration/expr.jl"
          loc: "220-261"
          url: "https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/src/integration/expr.jl#L220-L261"
          snippet: |
            _expr_leaf_val(node::SyntaxNode, _...) = node.val
            _expr_leaf_val(cursor::RedTreeCursor, txtbuf::Vector{UInt8}, txtbuf_offset::UInt32) =
                parse_julia_literal(txtbuf, head(cursor), byte_range(cursor) .+ txtbuf_offset)
            # Extended in JuliaLowering to support `node_to_expr(::SyntaxTree, ...)`

            function node_to_expr(cursor, source, txtbuf::Vector{UInt8}, txtbuf_offset::UInt32=UInt32(0))
                if !should_include_node(cursor)
                    return nothing
                end

                nodehead = head(cursor)
                k = kind(cursor)
                srcrange::UnitRange{UInt32} = byte_range(cursor)
                if is_leaf(cursor)
                    if is_error(k)
                        return k == K"error" ?
                            Expr(:error) :
                            Expr(:error, "$(_token_error_descriptions[k]): `$(source[srcrange])`")
                    elseif k == K"VERSION"
                        nv = numeric_flags(flags(nodehead))
                        return VersionNumber(1, nv ÷ 10, nv % 10)
                    else
                        scoped_val = _expr_leaf_val(cursor, txtbuf, txtbuf_offset)
                        val = @isexpr(scoped_val, :scope_layer) ? scoped_val.args[1] : scoped_val
                        if val isa Union{Int128,UInt128,BigInt}
                            str = replace(source[srcrange], '_'=>"")
                            macname = val isa Int128  ? Symbol("@int128_str")  :
                                    val isa UInt128 ? Symbol("@uint128_str") :
                                    Symbol("@big_str")
                            return Expr(:macrocall, GlobalRef(Core, macname), nothing, str)
                        elseif is_identifier(k)
                            val2 = lower_identifier_name(val, k)
                            return @isexpr(scoped_val, :scope_layer) ?
                                Expr(:scope_layer, val2, scoped_val.args[2]) : val2
                        else
                            return scoped_val
                        end
                    end
                end
        - source: "rg"
          path: "rg output"
          loc: "fixup_Expr_child"
          url: "https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/src/integration/expr.jl#L148"
          snippet: |
            JuliaSyntax/src/integration/expr.jl
            148:function fixup_Expr_child(::Type, head::SyntaxHead, @nospecialize(arg), first::Bool)

            JuliaLowering/src/compat.jl
            614:function JuliaSyntax.fixup_Expr_child(::Type{<:SyntaxTree}, head::SyntaxHead,
    - summary: "SyntaxGraph/SyntaxTree tests now live under JuliaSyntax and are only run for VERSION >= v\"1.12\", with parsing/error and copy_ast behavior asserted there."
      component: "JuliaSyntax/tests"
      evidence:
        - source: "test"
          path: "JuliaSyntax/test/runtests.jl"
          loc: "18-24"
          url: "https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/test/runtests.jl#L18-L24"
          snippet: |
            include("parse_stream.jl")
            include("parser.jl")
            include("green_node.jl")
            include("syntax_node.jl")
            if VERSION >= v"1.12"
                include("syntax_graph.jl")
            end
        - source: "test"
          path: "JuliaSyntax/test/syntax_graph.jl"
          loc: "45-101"
          url: "https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/test/syntax_graph.jl#L45-L101"
          snippet: |
            @testset "SyntaxTree parsing" begin
                # Errors should fall through
                @test parsestmt(SyntaxTree, "@"; ignore_errors=true) isa SyntaxTree
                @test parsestmt(SyntaxTree, "@@@"; ignore_errors=true) isa SyntaxTree
                @test parsestmt(SyntaxTree, "(a b c)"; ignore_errors=true) isa SyntaxTree
                @test parsestmt(SyntaxTree, "'a b c'"; ignore_errors=true) isa SyntaxTree
            end

            @testset "SyntaxTree utils" begin
                "For filling required attrs in graphs created by hand"
                function testgraph(edge_ranges, edges, more_attrs...)
                    kinds = Dict(map(i->(i=>K"block"), eachindex(edge_ranges)))
                    sources = Dict(map(i->(i=>LineNumberNode(i)), eachindex(edge_ranges)))
                    SyntaxGraph(
                        edge_ranges,
                        edges,
                        Dict(:kind => kinds, :source => sources, more_attrs...))
                end

                @testset "copy_ast" begin
                    g = testgraph([1:1, 2:2, 0:-1, 3:3, 4:4, 0:-1, 5:5, 6:6, 0:-1],
                                  [2, 3, 5, 6, 8, 9],
                                  :source => Dict(enumerate([
                                      map(i->i+3, 1:6)...
                                      map(LineNumberNode, 7:9)...])))
                    st = SyntaxTree(g, 1)
                    stcopy = copy_ast(g, st)
                    @test length(g.edge_ranges) === 18
                    @test st._id != stcopy._id
                    @test st ≈ stcopy
                    @test st.source !== stcopy.source
                    @test st.source[1] !== stcopy.source[1]
                    @test st.source[1][1] !== stcopy.source[1][1]

                    stcopy2 = copy_ast(g, st; copy_source=false)
                    @test length(g.edge_ranges) === 21
                    @test st._id != stcopy2._id
                    @test st ≈ stcopy2
                    @test st.source === stcopy2.source
                    @test st.source[1] === stcopy2.source[1]
                    @test st.source[1][1] === stcopy2.source[1][1]

                    new_g = ensure_attributes!(SyntaxGraph(); attrdefs(g)...)
                    stcopy3 = copy_ast(new_g, st)
                    @test length(new_g.edge_ranges) === 9
                    @test st ≈ stcopy3

                    new_g = ensure_attributes!(SyntaxGraph(); attrdefs(g)...)
                    @test_throws ErrorException copy_ast(new_g, st; copy_source=false)
                end
            end
  secondary_effects:
    - effect: "Downstream tooling that previously reached for JuliaLowering.SyntaxGraph/SyntaxTree will need to import these definitions from JuliaSyntax (or rely on any re-exports), since the owning module is now JuliaSyntax porcelain."
      mechanism: |
        JuliaLowering loads SyntaxGraph/SyntaxTree utilities from JuliaSyntax  [JuliaLowering.jl:15-23]
          -> SyntaxGraph/SyntaxTree are now defined in JuliaSyntax porcelain  [syntax_graph.jl:1-199]
          -> JuliaSyntax includes syntax_graph.jl only on VERSION >= v"1.12"  [JuliaSyntax.jl:99-105]
      downstream_surfaces:
        - "JuliaLowering internal consumers importing SyntaxGraph/SyntaxTree"
        - "Downstream packages (IRTools/AST tooling) that used JuliaLowering.SyntaxTree"
        - "JuliaSyntax-based parsing utilities when running on 1.12+"
      likelihood: "high"
      impact: "low"
    - effect: "SyntaxTree-to-Expr conversion now hinges on JuliaSyntax.to_expr with SyntaxTree-specific overrides, which can affect how dot calls and scope layers are reconstructed for tooling that converts SyntaxTree back to Expr."
      mechanism: |
        Base.Expr(ex::SyntaxTree) calls JuliaSyntax.to_expr(ex)  [compat.jl:628]
          -> to_expr(...) uses fixup_Expr_child(typeof(node), ...) for wrapper handling  [integration/expr.jl:690-696]
          -> JuliaSyntax.fixup_Expr_child(::Type{<:SyntaxTree}, ...) overrides dot/quote fixups  [compat.jl:614-626]
          -> node_to_expr(...) calls _expr_leaf_val(...) to extract leaf values  [integration/expr.jl:225-245]
          -> JuliaSyntax._expr_leaf_val(::SyntaxTree, ...) overrides symbol/Value handling  [compat.jl:591-611]
      downstream_surfaces:
        - "Macro tools that call Base.Expr(::SyntaxTree)"
        - "JuliaLowering @SyntaxTree macro expansions that round-trip through Expr"
      likelihood: "medium"
      impact: "low"
  compatibility:
    internal_api:
      - field: "JuliaSyntax.SyntaxGraph / JuliaSyntax.SyntaxTree"
        change: "Ownership moved into JuliaSyntax porcelain (loaded conditionally for VERSION >= v\"1.12\"), while JuliaLowering now imports these APIs rather than defining them locally."
        affected_tools:
          - tool: "JuliaLowering"
            usage: "Imports SyntaxGraph/SyntaxTree and AST helpers from JuliaSyntax in JuliaLowering.jl."
          - tool: "Downstream compiler tooling"
            usage: "Packages that imported JuliaLowering.SyntaxTree/SyntaxGraph should update imports to JuliaSyntax or gate on VERSION."
    behavioral:
      - change: "SyntaxTree parsing error tolerance and copy_ast behavior are now validated in JuliaSyntax's test suite (1.12+), preserving existing behavior after the move."
        evidence:
          - source: "test"
            path: "JuliaSyntax/test/syntax_graph.jl"
            loc: "45-101"
            url: "https://github.com/JuliaLang/julia/blob/f40b11726530f33fef72a8fc62aaf38990139ba5/JuliaSyntax/test/syntax_graph.jl#L45-L101"
            snippet: |
              @test parsestmt(SyntaxTree, "@"; ignore_errors=true) isa SyntaxTree
              @test parsestmt(SyntaxTree, "@@@"; ignore_errors=true) isa SyntaxTree
              @test parsestmt(SyntaxTree, "(a b c)"; ignore_errors=true) isa SyntaxTree
              @test parsestmt(SyntaxTree, "'a b c'"; ignore_errors=true) isa SyntaxTree

              stcopy = copy_ast(g, st)
              @test length(g.edge_ranges) === 18
              @test st._id != stcopy._id
  performance:
    compile_time:
      - impact: "ESTIMATED: No material compile-time impact; this PR primarily relocates code without altering algorithms."
    runtime:
      - impact: "ESTIMATED: No runtime performance change expected; behavior is code movement and API re-homing."
  risk:
    level: "low"
    rationale:
      - "Change is mostly code motion and namespace adjustments; functional behavior is locked in by ported tests."
      - "Potential for minor API breakage if downstream tooling imported JuliaLowering.SyntaxGraph/SyntaxTree without updating imports."
  open_questions:
    - "Do any downstream packages depend on JuliaLowering re-exporting SyntaxGraph/SyntaxTree, or should compatibility shims be added?"
    - "Should SyntaxGraph be available in JuliaSyntax for versions earlier than 1.12 to ease backporting?"
  recommendations:
    - "Downstream tooling should import SyntaxGraph/SyntaxTree from JuliaSyntax and guard on VERSION >= v\"1.12\" if needed."
    - "Add release notes highlighting the module move for any external users of SyntaxTree/SyntaxGraph APIs."
