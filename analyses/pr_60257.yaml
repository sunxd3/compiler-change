schema_version: "1.0"
pr:
  number: 60257
  title: "[JuliaLowering] `ccall((lib,sym)...)` and `cfunction` fixes"
  url: "https://github.com/JuliaLang/julia/pull/60257"
  author: "mlechu"
  labels:
    - "compiler:lowering"
  merged_at: "2025-12-01T22:15:13Z"
  merge_commit_sha: "7bc6a0358fcfa739be0fe16d6424d70c967cfa28"
  diff_url: "https://github.com/JuliaLang/julia/pull/60257.diff"
scope:
  files_touched:
    - "JuliaLowering/src/desugaring.jl"
    - "JuliaLowering/src/eval.jl"
    - "JuliaLowering/src/syntax_macros.jl"
    - "JuliaLowering/test/function_calls_ir.jl"
    - "JuliaLowering/test/misc.jl"
    - "JuliaLowering/test/misc_ir.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Lowering"
    - "IR Construction"
analysis:
  intent:
    summary: "Fix lowering for (sym, lib) tuples in ccall/cglobal and align @cfunction handling with Base by quoting non-interpolated callables."
    issue_links:
      - "https://github.com/JuliaLang/JuliaLowering.jl/pull/36"
  direct_changes:
    - summary: "`expand_C_library_symbol` now wraps tuple arguments in `K\"static_eval\"` with per-child expansion, ensuring tuple syntax is preserved for ccall/cglobal library specs."
      component: "JuliaLowering/src/desugaring.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "1725-1733"
          url: "https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/src/desugaring.jl#L1725-L1733"
          snippet: |
            # Expand the (sym,lib) argument to ccall/cglobal
            function expand_C_library_symbol(ctx, ex)
                if kind(ex) == K"tuple"
                    return @ast ctx ex [K"static_eval"(meta=name_hint("function name and library expression"))
                        mapchildren(e->expand_forms_2(ctx,e), ctx, ex)
                    ]
                end
                return expand_forms_2(ctx, ex)
            end
        - source: "test"
          path: "JuliaLowering/test/function_calls_ir.jl"
          loc: "366-374"
          url: "https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/test/function_calls_ir.jl#L366-L374"
          snippet: |
            # ccall with library name as a global var
            ccall((:strlen, libc), Csize_t, (Cstring,), "asdfg")
            #---------------------
            1   TestMod.Cstring
            2   (call top.cconvert %₁ "asdfg")
            3   (call top.unsafe_convert %₁ %₂)
            4   (foreigncall (static_eval (tuple-p :strlen TestMod.libc)) (static_eval TestMod.Csize_t) (static_eval (call core.svec TestMod.Cstring)) 0 :ccall %₃ %₂)
            5   (return %₄)
    - summary: "`_to_lowered_expr` handles `K\"static_eval\"` tuple/function payloads explicitly and treats `K\"cfunction\"` as a normal head for IR construction."
      component: "JuliaLowering/src/eval.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/eval.jl"
          loc: "413-445"
          url: "https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/src/eval.jl#L413-L445"
          snippet: |
            elseif k == K"static_eval"
                @assert numchildren(ex) == 1
                if kind(ex[1]) === K"tuple"
                    # Should just be ccall library spec
                    @assert numchildren(ex[1]) === 2
                    Expr(:tuple, _to_lowered_expr(ex[1][1], stmt_offset),
                         _to_lowered_expr(ex[1][2], stmt_offset))
                elseif kind(ex[1]) === K"function"
                    QuoteNode(Expr(ex))
                else
                    _to_lowered_expr(ex[1], stmt_offset)
                end
            else
                # Allowed forms according to https://docs.julialang.org/en/v1/devdocs/ast/
                #
                # call invoke static_parameter `=` method struct_type abstract_type
                # primitive_type global const new splatnew isdefined
                # enter leave pop_exception inbounds boundscheck loopinfo copyast meta
                # lambda
                head = k == K"call"      ? :call       :
                       k == K"new"       ? :new        :
                       k == K"splatnew"  ? :splatnew   :
                       k == K"="         ? :(=)        :
                       k == K"leave"     ? :leave      :
                       k == K"isdefined" ? :isdefined  :
                       k == K"latestworld"       ? :latestworld       :
                       k == K"pop_exception"     ? :pop_exception     :
                       k == K"captured_local"    ? :captured_local    :
                       k == K"gc_preserve_begin" ? :gc_preserve_begin :
                       k == K"gc_preserve_end"   ? :gc_preserve_end   :
                       k == K"foreigncall"       ? :foreigncall       :
                       k == K"cfunction"         ? :cfunction         :
                       k == K"new_opaque_closure" ? :new_opaque_closure :
                       nothing
        - source: "test"
          path: "JuliaLowering/test/function_calls_ir.jl"
          loc: "519-525"
          url: "https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/test/function_calls_ir.jl#L519-L525"
          snippet: |
            # cglobal special support for (sym, lib) tuple
            cglobal((:sym, lib), Int)
            #---------------------
            1   TestMod.Int
            2   (call core.cglobal (static_eval (tuple-p :sym TestMod.lib)) %₁)
            3   (return %₂)
    - summary: "`@cfunction` now wraps non-interpolated callables in `K\"inert\"` with `CompileHints(:as_Expr, true)` to preserve expression form."
      component: "JuliaLowering/src/syntax_macros.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/syntax_macros.jl"
          loc: "80-110"
          url: "https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/src/syntax_macros.jl#L80-L110"
          snippet: |
            function Base.var"@cfunction"(__context__::MacroContext, callable, return_type, arg_types)
                if kind(arg_types) != K"tuple"
                    throw(MacroExpansionError(arg_types, "@cfunction argument types must be a literal tuple"))
                end
                arg_types_svec = @ast __context__ arg_types [K"call"
                    "svec"::K"core"
                    children(arg_types)...
                ]
                if kind(callable) == K"$"
                    fptr = callable[1]
                    typ = Base.CFunction
                else
                    # Kinda weird semantics here - without `$`, the callable is a top level
                    # expression evaluated within the module where the `@cfunction` is
                    # expanded into.
                    fptr = @ast __context__ callable [K"inert"(
                            meta=CompileHints(:as_Expr, true))
                        callable
                    ]
                    typ = Ptr{Cvoid}
                end
                @ast __context__ __context__.macrocall [K"cfunction"
                    typ::K"Value"
                    fptr
                    [K"static_eval"(meta=name_hint("cfunction return type"))
                        return_type
                    ]
                    [K"static_eval"(meta=name_hint("cfunction argument type"))
                        arg_types_svec
                    ]
                    "ccall"::K"Symbol"
                ]
            end
        - source: "test"
          path: "JuliaLowering/test/misc_ir.jl"
          loc: "354-359"
          url: "https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/test/misc_ir.jl#L354-L359"
          snippet: |
            # @cfunction expansion with global generic function as function argument
            @cfunction(callable, Int, (Int, Float64))
            #---------------------
            1   (cfunction Ptr{Nothing} (inert callable) (static_eval TestMod.Int) (static_eval (call core.svec TestMod.Int TestMod.Float64)) :ccall)
            2   (return %₁)
  secondary_effects:
    - effect: "`ccall`/`cglobal` library tuple specs are emitted as tuple syntax instead of a Core.Tuple call, aligning IR shape with Base and preserving literal tuple intent."
      mechanism: |
        expand_C_library_symbol(ctx, ex) [desugaring.jl:1726-1733]
          returns K"static_eval" over tuple children
        -> expand_ccall emits K"foreigncall" with expand_C_library_symbol(ctx, cfunc_name)
           [desugaring.jl:1840-1845]
        -> _to_lowered_expr handles K"static_eval" tuple payloads as Expr(:tuple)
           [eval.jl:413-419]
        rg results for callers:
          JuliaLowering/src/desugaring.jl:1726:function expand_C_library_symbol(ctx, ex)
          JuliaLowering/src/desugaring.jl:1843:            expand_C_library_symbol(ctx, cfunc_name)
          JuliaLowering/src/desugaring.jl:1908:            expand_C_library_symbol(ctx, ex[2])
      downstream_surfaces:
        - "IR pattern matchers that expect Core.Tuple in foreigncall/cglobal paths"
        - "FFI wrapper generators relying on lowering IR shapes"
      likelihood: "high"
      impact: "medium"
    - effect: "Non-interpolated `@cfunction` callables are now preserved as quoted expressions, improving hygiene and enabling function literal callables in lowering."
      mechanism: |
        @cfunction macro wraps callable in K"inert" with CompileHints(:as_Expr, true)
          [syntax_macros.jl:80-100]
        -> _to_lowered_expr handles K"inert" by emitting QuoteNode(Expr(e1)) when :as_Expr is true
          [eval.jl:369-371]
        -> cfunction IR now carries (inert callable), keeping the expression form
          [misc_ir.jl:354-359]
      downstream_surfaces:
        - "Macro expansions that depend on @cfunction hygiene in nested modules"
        - "Users passing anonymous/quoted functions to @cfunction"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api: []
    behavioral:
      - surface: "Lowered IR for ccall/cglobal with (sym, lib)"
        change: "Static eval now yields tuple syntax (tuple-p) rather than Core.Tuple calls."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/function_calls_ir.jl"
            loc: "366-374"
            url: "https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/test/function_calls_ir.jl#L366-L374"
            snippet: |
              # ccall with library name as a global var
              ccall((:strlen, libc), Csize_t, (Cstring,), "asdfg")
              #---------------------
              1   TestMod.Cstring
              2   (call top.cconvert %₁ "asdfg")
              3   (call top.unsafe_convert %₁ %₂)
              4   (foreigncall (static_eval (tuple-p :strlen TestMod.libc)) (static_eval TestMod.Csize_t) (static_eval (call core.svec TestMod.Cstring)) 0 :ccall %₃ %₂)
              5   (return %₄)
      - surface: "@cfunction name resolution without interpolation"
        change: "Hygiene follows Base behavior; non-interpolated symbol resolves in the expansion module, and quoted function literals are accepted."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/misc.jl"
            loc: "112-139"
            url: "https://github.com/JuliaLang/julia/blob/7bc6a0358fcfa739be0fe16d6424d70c967cfa28/JuliaLowering/test/misc.jl#L112-L139"
            snippet: |
              # Same as above, but non-interpolated symbol.  Arguably this could return 20,
              # but if it should, this is a bug in the macro implementation, not lowering.
              # Match Base for now.
              JuliaLowering.include_string(test_mod, raw"""
              f_ccallable_hygiene() = 10
              
              module Nested
                  f_ccallable_hygiene() = 20
                  macro cfunction_hygiene()
                      :(@cfunction(f_ccallable_hygiene, Int, ()))
                  end
              end
              """)
              cf_hygiene = JuliaLowering.include_string(test_mod, """
              Nested.@cfunction_hygiene
              """)
              @test @ccall($cf_hygiene()::Int) == 10
  performance:
    compile_time:
      - impact: "ESTIMATED: negligible"
        detail: "Tuple handling adds a small branch in _to_lowered_expr for static_eval; no additional passes introduced."
    runtime:
      - impact: "ESTIMATED: none"
        detail: "Changes affect lowering/IR shape but not runtime foreigncall semantics."
  risk:
    level: "low"
    rationale:
      - "Changes are localized to JuliaLowering desugaring and eval paths."
      - "New tests cover ccall/cglobal tuple IR and @cfunction hygiene/quoted callables."
  open_questions: []
  recommendations:
    - "Downstream IR analyzers should accept tuple syntax (tuple-p) for ccall/cglobal library specs instead of matching Core.Tuple calls."
    - "Macro tooling that inspects @cfunction callables should handle inert/quoted expressions (QuoteNode(Expr(...)))."
