schema_version: "1.0"

pr:
  number: 60088
  title: "Call `realpath` before comparing coverage paths"
  url: "https://github.com/JuliaLang/julia/pull/60088"
  author: "Keno"
  labels: []
  created_at: "2025-11-09T19:40:47Z"
  merged_at: "2025-11-11T00:01:49Z"
  merge_commit_sha: "03a9cf6c299ad71d9b53dd987334b53a6c312d6f"
  diff_url: "https://github.com/JuliaLang/julia/pull/60088.diff"
  related_issues:
    - number: 60058
      description: "Original issue where --code-coverage=@path fails with symlinked paths (Pkg testing)"

scope:
  files_touched:
    - "src/codegen.cpp"
    - "src/jlapi.c"
    - "src/julia_internal.h"
  components:
    - "Compiler.Codegen"
    - "Other"
  pipeline_stages:
    - "Codegen"

analysis:
  intent:
    summary: |
      This PR fixes a bug where `--code-coverage=@path` does not work if `path` contains symlinks.
      The issue occurs because the CLI argument is resolved to a realpath (absolute path with symlinks
      resolved), but when inserting coverage instrumentation during codegen, the file paths from debug
      info were compared directly without resolving symlinks first.

      The fix adds a call to `jl_absrealpath` when comparing each file path against the tracked path
      during code generation. While this incurs additional filesystem queries (one realpath call per
      line table entry), it ensures symlinked paths are correctly matched.

      The author notes this is a workaround until a larger overhaul moves coverage filtering to the
      writer side, makes coverage cacheable, and works in the interpreter.
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/60058"
    quoted_from_pr: |
      This commit fixes an issue where `--code-coverage=@path` does not work if `path` has any
      symlinks in it (which happens e.g. when testing `Pkg` in tree - ref #60058). The issue is
      that we call `realpath` on the cli argument, but do not currently call realpath when
      inserting the instrumentation.

  direct_changes:
    - summary: "Export jl_absrealpath function for use in codegen"
      component: "jlapi.c"
      evidence:
        - source: "diff"
          path: "src/jlapi.c"
          loc: "1173"
          url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/jlapi.c#L1173"
          snippet: |
            JL_DLLEXPORT char *jl_absrealpath(const char *in, int nprefix)
            { // compute an absolute realpath location, so that chdir doesn't change the file reference
              // ignores (copies directly over) nprefix characters at the start of abspath
                char *out;
                uv_fs_t req;
                int realpath_ret = uv_fs_realpath(NULL, &req, in + nprefix, NULL);
                if (realpath_ret >= 0) {
                    size_t sz = strlen((char*)(req.ptr)) + 1;
                    out = (char*)malloc_s(sz + nprefix);
                    memcpy(out, in, nprefix);
                    memcpy(out + nprefix, req.ptr, sz);
                    uv_fs_req_cleanup(&req);
                }
                else {
                    uv_fs_req_cleanup(&req);
                    size_t sz = strlen(in + nprefix) + 1;
                    if (jl_isabspath(in + nprefix)) {
                        out = (char*)malloc_s(sz + nprefix);
                        memcpy(out, in, sz + nprefix);
                    }
                    else {
                        size_t path_size = JL_PATH_MAX;
                        char *path = (char*)malloc_s(JL_PATH_MAX);
                        if (uv_cwd(path, &path_size)) {
                            jl_error("fatal error: unexpected error while retrieving current working directory");
                        }
                        out = (char*)malloc_s(path_size + 1 + sz + nprefix);
                        memcpy(out, in, nprefix);
                        memcpy(out + nprefix, path, path_size);
                        out[nprefix + path_size] = PATHSEPSTRING[0];
                        memcpy(out + nprefix + path_size + 1, in + nprefix, sz);
                        free(path);
                    }
                }
                return out;
            }

    - summary: "Add jl_absrealpath declaration to julia_internal.h"
      component: "julia_internal.h"
      evidence:
        - source: "diff"
          path: "src/julia_internal.h"
          loc: "1911-1912"
          url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/julia_internal.h#L1911-L1912"
          snippet: |
            JL_DLLEXPORT int jl_isabspath(const char *in) JL_NOTSAFEPOINT;
            JL_DLLEXPORT char *jl_absrealpath(const char *in, int nprefix) JL_NOTSAFEPOINT;

    - summary: "Call jl_absrealpath in in_tracked_path lambda for symlink resolution"
      component: "Compiler.Codegen"
      evidence:
        - source: "diff"
          path: "src/codegen.cpp"
          loc: "8905-8912"
          url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/codegen.cpp#L8905-L8912"
          snippet: |
            auto in_tracked_path = [] (StringRef file) { // falls within an explicitly set file or directory
                if (jl_options.tracked_path == NULL)
                    return false;
                char *absfile = jl_absrealpath(file.data(), 0);
                bool match = StringRef(absfile).starts_with(jl_options.tracked_path);
                free(absfile);
                return match;
            };

  pipeline_impact:
    - stage: "Codegen"
      effect: "Coverage and allocation tracking instrumentation now correctly handles symlinked paths"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "9102-9113"
          url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/codegen.cpp#L9102-L9113"
          snippet: |
            auto do_coverage = [&] (bool in_user_code, bool is_tracked) {
                return (jl_generating_output() == 0 &&
                        (coverage_mode == JL_LOG_ALL ||
                        (in_user_code && coverage_mode == JL_LOG_USER) ||
                        (is_tracked && coverage_mode == JL_LOG_PATH)));
            };
            auto do_malloc_log = [&] (bool in_user_code, bool is_tracked) {
                return (jl_generating_output() == 0 &&
                        (malloc_log_mode == JL_LOG_ALL ||
                        (in_user_code && malloc_log_mode == JL_LOG_USER) ||
                        (is_tracked && malloc_log_mode == JL_LOG_PATH)));
            };

  secondary_effects:
    - effect: "Filesystem queries during codegen for path-specific coverage"
      mechanism: |
        The in_tracked_path lambda is called multiple times during codegen:

        1. Once at function entry for ctx.file  [codegen.cpp:8914]
           bool mod_is_tracked = in_tracked_path(ctx.file);

        2. For each line entry in coverageVisitStmt  [codegen.cpp:9124]
           bool is_tracked = in_tracked_path(newdbg.file);

        3. For each debug info in record_line_exists  [codegen.cpp:9163]
           bool is_tracked = in_tracked_path(file);

        Each call to in_tracked_path now invokes jl_absrealpath() which:
        1. Calls uv_fs_realpath() - a synchronous filesystem operation
        2. Allocates memory for the resolved path
        3. Frees the memory after comparison

        For a function with N line table entries, this is O(N) filesystem queries.
        Most entries likely have the same file, so this is redundant work.
      downstream_surfaces:
        - "Code coverage instrumentation performance"
        - "Compile time when using --code-coverage=@path"
      likelihood: "high"
      impact: "medium"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "8914"
          url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/codegen.cpp#L8914"
          snippet: |
            bool mod_is_tracked = in_tracked_path(ctx.file);
        - source: "code"
          path: "src/codegen.cpp"
          loc: "9122-9125"
          url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/codegen.cpp#L9122-L9125"
          snippet: |
            for (; dbg < new_lineinfo.size(); dbg++) {
                const auto &newdbg = new_lineinfo[dbg];
                bool is_tracked = in_tracked_path(newdbg.file);
                if (do_coverage(newdbg.is_user_code, is_tracked)) {
        - source: "code"
          path: "src/codegen.cpp"
          loc: "9163-9164"
          url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/codegen.cpp#L9163-L9164"
          snippet: |
            bool is_tracked = in_tracked_path(file);
            if (do_coverage(is_user_code, is_tracked)) {

    - effect: "Inconsistency between codegen path tracking and jl_is_file_tracked"
      mechanism: |
        There are now two different path comparison mechanisms:

        1. NEW (codegen.cpp): in_tracked_path uses jl_absrealpath on input
           char *absfile = jl_absrealpath(file.data(), 0);
           bool match = StringRef(absfile).starts_with(jl_options.tracked_path);

        2. OLD (init.c): jl_is_file_tracked does NOT use realpath
           int tpath_len = strlen(jl_options.tracked_path);
           return (strlen(path_) >= tpath_len) &&
                  (strncmp(path_, jl_options.tracked_path, tpath_len) == 0);

        The jl_is_file_tracked function is called from Julia code via:
        - base/options.jl:126:  ccall(:jl_is_file_tracked, Cint, (Any,), file) == 1
        - Compiler/src/inferencestate.jl:587:  _should_instrument(loc::Symbol) = is_file_tracked(loc)

        This means inference-time tracking decisions (for interpreter coverage) may differ
        from codegen-time decisions when symlinks are involved.
      downstream_surfaces:
        - "Interpreter coverage instrumentation"
        - "Compiler should_instrument decisions"
      likelihood: "medium"
      impact: "low"
      evidence:
        - source: "code"
          path: "src/init.c"
          loc: "543-548"
          url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/init.c#L543-L548"
          snippet: |
            JL_DLLEXPORT int jl_is_file_tracked(jl_sym_t *path)
            {
                const char* path_ = jl_symbol_name(path);
                int tpath_len = strlen(jl_options.tracked_path);
                return (strlen(path_) >= tpath_len) && (strncmp(path_, jl_options.tracked_path, tpath_len) == 0);
            }
        - source: "code"
          path: "Compiler/src/inferencestate.jl"
          loc: "580-597"
          url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/Compiler/src/inferencestate.jl#L580-L597"
          snippet: |
            function should_instrument(mod::Module, debuginfo::DebugInfo, only_if_affects_optimizer::Bool=false)
                instrumentation_enabled(mod, only_if_affects_optimizer) && return true
                JLOptions().code_coverage == 3 || JLOptions().malloc_log == 3 || return false
                # path-specific coverage mode: if any line falls in a tracked file enable coverage for all
                return _should_instrument(debuginfo)
            end

            _should_instrument(loc::Symbol) = is_file_tracked(loc)
            _should_instrument(loc::Method) = _should_instrument(loc.file)
            _should_instrument(loc::MethodInstance) = _should_instrument(loc.def)
            _should_instrument(::Module) = false
            _should_instrument(::Nothing) = false
            function _should_instrument(info::DebugInfo)
                linetable = info.linetable
                linetable === nothing || (_should_instrument(linetable) && return true)
                _should_instrument(info.def) && return true
                return false
            end

    - effect: "Memory allocation per path check"
      mechanism: |
        Each call to in_tracked_path allocates and frees memory:

        jl_absrealpath() -> malloc_s() to allocate result  [jlapi.c:1181,1190,1199]
        in_tracked_path  -> free(absfile) after comparison  [codegen.cpp:8910]

        For functions with many line entries, this creates allocation churn during codegen.
        A memoization cache keyed by file path would eliminate redundant allocations.
      downstream_surfaces:
        - "Codegen memory allocation patterns"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "8908-8910"
          url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/codegen.cpp#L8908-L8910"
          snippet: |
            char *absfile = jl_absrealpath(file.data(), 0);
            bool match = StringRef(absfile).starts_with(jl_options.tracked_path);
            free(absfile);

  compatibility:
    internal_api:
      - summary: "jl_absrealpath function now exported (JL_DLLEXPORT)"
        evidence:
          - source: "diff"
            path: "src/julia_internal.h"
            loc: "1912"
            url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/julia_internal.h#L1912"
            snippet: |
              JL_DLLEXPORT char *jl_absrealpath(const char *in, int nprefix) JL_NOTSAFEPOINT;
      - summary: "Function renamed from static absrealpath to exported jl_absrealpath"
        evidence:
          - source: "diff"
            path: "src/jlapi.c"
            loc: "1173"
            url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/jlapi.c#L1173"
            snippet: |
              JL_DLLEXPORT char *jl_absrealpath(const char *in, int nprefix)
    behavioral:
      - summary: "--code-coverage=@path now matches files through symlinks"
        evidence:
          - source: "discussion"
            path: "PR description"
            loc: "body"
            snippet: |
              This commit fixes an issue where `--code-coverage=@path` does not work if `path`
              has any symlinks in it (which happens e.g. when testing `Pkg` in tree - ref #60058).

  performance:
    compile_time:
      - summary: "ESTIMATED: O(N) filesystem queries per function with path-specific coverage"
        evidence:
          - source: "code"
            path: "src/codegen.cpp"
            loc: "8908"
            url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/codegen.cpp#L8908"
            snippet: |
              char *absfile = jl_absrealpath(file.data(), 0);
        details: |
          When using --code-coverage=@path, each function's codegen now performs:
          - 1 realpath call for ctx.file (function's source file)
          - N realpath calls in coverageVisitStmt (N = line table entries)
          - M realpath calls in record_line_exists (M = debug info entries)

          The PR author acknowledges this: "this is a bit awful, because, as currently
          structured, this requires us to do a file system query for every line table entry.
          Most of those line table entries will probably have the same file, so that's a lot
          of redundant (and depending on filesystem, potentially expensive work)."

          Impact varies by filesystem:
          - Local SSD: ~microseconds per realpath
          - NFS/network: ~milliseconds per realpath (could be significant)

          ESTIMATED: 5-20% compile time increase for path-specific coverage on local
          filesystems; potentially much higher on network filesystems.
    runtime:
      - summary: "None - coverage instrumentation is a codegen-time decision"
        evidence: []
        details: |
          This change only affects which lines get coverage instrumentation at codegen time.
          The actual coverage counting at runtime is unchanged.

  tests:
    changed_files: []
    new_behavior_assertions: []
    coverage_gaps:
      - "No tests added for symlink path resolution in coverage"
      - "No tests for --code-coverage=@path with symlinked directories"
      - "No performance benchmarks for coverage path resolution overhead"

  risk:
    level: "low"
    rationale:
      - "Fix is targeted and isolated to path-specific coverage mode (JL_LOG_PATH)"
      - "Only affects --code-coverage=@path usage, not default coverage modes"
      - "Author is a core Julia developer (Keno) familiar with codegen internals"
      - "The fix follows the same pattern already used for tracked_path CLI resolution"
      - "Memory is properly freed after each comparison (no leaks)"
      - "Performance overhead only applies when using path-specific coverage"
      - "Marked as temporary fix until larger coverage overhaul"

  open_questions:
    - question: "Should jl_is_file_tracked also use realpath for consistency?"
      resolved: false
      notes: |
        The jl_is_file_tracked function in src/init.c still uses direct string comparison
        without realpath resolution. This could cause inconsistent behavior between
        interpreter coverage and codegen coverage when symlinks are involved.

    - question: "Could path resolution be cached to avoid redundant filesystem queries?"
      resolved: false
      notes: |
        A simple cache mapping file paths to their realpath results could eliminate most
        redundant queries, since most line entries in a function share the same file.

    - question: "What is the planned timeline for the coverage overhaul mentioned in the PR?"
      resolved: false
      notes: |
        The PR author mentions: "At some point in the near future we need to completely
        overhaul all and move the filtering to the writer side (rather than during codegen),
        as well as making coverage cacheable and work in the interpreter."

  recommendations:
    - "No immediate action required for most users"
    - "Users of --code-coverage=@path may see slightly slower compilation"
    - "Network filesystem users should be aware of potential latency impact"
    - "Consider adding path resolution cache if coverage performance becomes an issue"

changelog_entry:
  category: "Codegen/Coverage"
  breaking: false
  summary: |
    Fixed `--code-coverage=@path` to correctly track files when the specified path contains
    symlinks. Previously, paths with symlinks would not match the tracked path because the
    comparison was done without resolving symlinks to their real paths.
  downstream_impact: |
    This is a bugfix with no breaking changes. Users of `--code-coverage=@path` with symlinked
    directories (such as Pkg testing scenarios) will now get correct coverage results.
    There may be a minor compile-time performance impact due to additional filesystem queries.

downstream_package_impact:
  Turing_jl: "none - coverage is a codegen feature, does not affect inference or AD"
  Enzyme_jl: "none - coverage is a codegen feature, does not affect differentiation"
  GPUCompiler: "none - coverage is a codegen feature, GPU code generation unaffected"
  JET: "none - coverage is orthogonal to static analysis"
  IRTools: "none - coverage is a codegen feature, IR manipulation unaffected"
  Cassette: "none - coverage is a codegen feature, code transformation unaffected"

code_path_trace:
  tracked_path_cli_resolution:
    description: "How the tracked_path CLI argument is resolved at startup"
    steps:
      - location: "src/jloptions.c:794-796"
        url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/jloptions.c#L794-L796"
        code: |
          else if (!strncmp(optarg, "@", 1)) {
              codecov = JL_LOG_PATH;
              jl_options.tracked_path = optarg + 1; // skip `@`
          }
        explanation: |
          When --code-coverage=@path is parsed, the path (after '@') is stored in
          jl_options.tracked_path and coverage mode is set to JL_LOG_PATH.

      - location: "src/jlapi.c:1281-1282"
        url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/jlapi.c#L1281-L1282"
        code: |
          if (jl_options.tracked_path)
              jl_options.tracked_path = jl_absrealpath(jl_options.tracked_path, 0);
        explanation: |
          During jl_resolve_sysimg_location, tracked_path is resolved to its absolute
          realpath (symlinks resolved). This is the path all subsequent comparisons use.

  codegen_path_comparison:
    description: "How file paths are compared during codegen (the PR's fix)"
    steps:
      - location: "src/codegen.cpp:8905-8912"
        url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/codegen.cpp#L8905-L8912"
        code: |
          auto in_tracked_path = [] (StringRef file) { // falls within an explicitly set file or directory
              if (jl_options.tracked_path == NULL)
                  return false;
              char *absfile = jl_absrealpath(file.data(), 0);
              bool match = StringRef(absfile).starts_with(jl_options.tracked_path);
              free(absfile);
              return match;
          };
        explanation: |
          NEW: The in_tracked_path lambda now resolves each file path to its realpath
          before comparing with jl_options.tracked_path. This ensures symlinked paths
          match the already-resolved tracked_path.

      - location: "src/codegen.cpp:9100-9106"
        url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/codegen.cpp#L9100-L9106"
        code: |
          auto do_coverage = [&] (bool in_user_code, bool is_tracked) {
              return (jl_generating_output() == 0 &&
                      (coverage_mode == JL_LOG_ALL ||
                      (in_user_code && coverage_mode == JL_LOG_USER) ||
                      (is_tracked && coverage_mode == JL_LOG_PATH)));
          };
        explanation: |
          The do_coverage lambda uses is_tracked (from in_tracked_path) when
          coverage_mode == JL_LOG_PATH (i.e., --code-coverage=@path).

  jl_absrealpath_implementation:
    description: "How jl_absrealpath resolves paths"
    steps:
      - location: "src/jlapi.c:1173-1208"
        url: "https://github.com/JuliaLang/julia/blob/03a9cf6c299ad71d9b53dd987334b53a6c312d6f/src/jlapi.c#L1173-L1208"
        code: |
          JL_DLLEXPORT char *jl_absrealpath(const char *in, int nprefix)
          { // compute an absolute realpath location, so that chdir doesn't change the file reference
            // ignores (copies directly over) nprefix characters at the start of abspath
              char *out;
              uv_fs_t req;
              int realpath_ret = uv_fs_realpath(NULL, &req, in + nprefix, NULL);
              if (realpath_ret >= 0) {
                  // Success: use resolved path from libuv
                  size_t sz = strlen((char*)(req.ptr)) + 1;
                  out = (char*)malloc_s(sz + nprefix);
                  memcpy(out, in, nprefix);
                  memcpy(out + nprefix, req.ptr, sz);
                  uv_fs_req_cleanup(&req);
              }
              else {
                  // Fallback: realpath failed, construct absolute path manually
                  uv_fs_req_cleanup(&req);
                  size_t sz = strlen(in + nprefix) + 1;
                  if (jl_isabspath(in + nprefix)) {
                      // Already absolute, just copy
                      out = (char*)malloc_s(sz + nprefix);
                      memcpy(out, in, sz + nprefix);
                  }
                  else {
                      // Relative path: prepend cwd
                      size_t path_size = JL_PATH_MAX;
                      char *path = (char*)malloc_s(JL_PATH_MAX);
                      if (uv_cwd(path, &path_size)) {
                          jl_error("fatal error: unexpected error while retrieving current working directory");
                      }
                      out = (char*)malloc_s(path_size + 1 + sz + nprefix);
                      memcpy(out, in, nprefix);
                      memcpy(out + nprefix, path, path_size);
                      out[nprefix + path_size] = PATHSEPSTRING[0];
                      memcpy(out + nprefix + path_size + 1, in + nprefix, sz);
                      free(path);
                  }
              }
              return out;
          }
        explanation: |
          Uses libuv's uv_fs_realpath for symlink resolution. Falls back to manual
          absolute path construction if realpath fails (e.g., file doesn't exist).
          Always allocates and returns a new string that caller must free.

test_coverage:
  new_tests: []
  missing_tests:
    - description: "No test for symlink path resolution in --code-coverage=@path"
      suggested_test: |
        # Create a symlinked directory structure
        # Run julia --code-coverage=@/symlink/path -e 'include("test.jl")'
        # Verify coverage is recorded correctly
    - description: "No performance test for realpath overhead"
      suggested_test: |
        # Benchmark compile time with and without --code-coverage=@path
        # on a project with many source files

reviewer_notes:
  initial_reviewer: "automated_analysis"
  initial_date: "2026-01-21"
  verification_method: |
    1. Read PR metadata from pr-archive/JuliaLang_julia/pr_60088.json
    2. Cloned Julia repo and checked out PR commit (03a9cf6c29)
    3. Read full source context of src/codegen.cpp around the in_tracked_path lambda
    4. Read jl_absrealpath implementation in src/jlapi.c
    5. Searched for all callers of in_tracked_path in codegen.cpp
    6. Found jl_is_file_tracked in init.c and traced its usage
    7. Identified potential inconsistency between codegen and interpreter path matching
    8. Verified memory management (malloc/free) in the new code path
  findings:
    - "The fix correctly resolves symlinks before path comparison"
    - "There is a known performance trade-off (redundant realpath calls)"
    - "jl_is_file_tracked in init.c does not use realpath - potential inconsistency"
    - "Memory is properly managed (freed after comparison)"
    - "This is acknowledged as a temporary fix pending larger overhaul"
    - "No tests were added for the fix"
  confidence: "high"
  rationale: |
    This is a targeted bugfix for a specific edge case (symlinks in coverage paths).
    The implementation is straightforward - resolve each path before comparison.
    The performance impact is acknowledged but acceptable as a temporary measure.
    The author notes plans for a larger coverage system overhaul that would
    address the performance concerns by moving filtering to the writer side.

  second_reviewer: "independent_verification"
  second_review_date: "2026-01-21"
  second_review_verification_method: |
    1. Independently checked out PR commit (03a9cf6c299ad71d9b53dd987334b53a6c312d6f)
    2. Verified all line numbers against actual source code
    3. Traced jl_debuginfo_file1() to confirm null-termination safety
    4. Searched for all usages of tracked_path across src/
    5. Reviewed existing tests in test/cmdlineargs.jl for coverage path handling
    6. Examined jl_absrealpath fallback behavior for non-existent files

  line_number_verification:
    codegen_cpp_in_tracked_path:
      documented: "8905-8912"
      actual: "8905-8912"
      status: "verified"
    codegen_cpp_do_coverage:
      documented: "9100-9106"
      actual: "9102-9107"
      status: "minor_offset"
      note: "Lambda starts at 9102, not 9100"
    codegen_cpp_coverageVisitStmt:
      documented: "9122-9125"
      actual: "9122-9130"
      status: "partial"
      note: "Full loop spans 9118-9131, inner body at 9122-9130"
    codegen_cpp_record_line_exists:
      documented: "9163-9164"
      actual: "9163-9164"
      status: "verified"
    jlapi_c_absrealpath:
      documented: "1173-1208"
      actual: "1173-1208"
      status: "verified"
    julia_internal_h:
      documented: "1911-1912"
      actual: "1911-1912"
      status: "verified"
    init_c_jl_is_file_tracked:
      documented: "543-548"
      actual: "543-548"
      status: "verified"
    inferencestate_jl:
      documented: "580-597"
      actual: "580-597"
      status: "verified"

  additional_findings:
    - finding: "Fix applies to both --code-coverage=@path AND --track-allocation=@path"
      evidence: |
        Both coverage and malloc_log use the same tracked_path variable.
        src/jloptions.c:795-796 sets tracked_path for code coverage
        src/jloptions.c:815-816 sets tracked_path for allocation tracking
        src/codegen.cpp:9106 uses is_tracked for JL_LOG_PATH coverage
        src/codegen.cpp:9112 uses is_tracked for JL_LOG_PATH malloc_log
      impact: "The PR description only mentions code coverage, but allocation tracking benefits too"

    - finding: "String null-termination is safe"
      evidence: |
        The file StringRef passed to jl_absrealpath comes from:
        1. jl_debuginfo_file1() which returns jl_symbol_name() (null-terminated) or "<unknown>"
        2. ctx.file which comes from jl_symbol_name() or jl_debuginfo_file()
        All paths return null-terminated C strings, so file.data() is safe for C string functions.
      impact: "No correctness concern - original analysis did not need to address this"

    - finding: "jl_absrealpath has fallback for non-existent files"
      evidence: |
        When uv_fs_realpath fails (file doesn't exist), jl_absrealpath falls back to:
        - If absolute path: copies path as-is (lines 1189-1191)
        - If relative path: prepends cwd (lines 1193-1204)
        This means symlinks in non-existent paths won't be resolved.
      impact: "Low - debug info typically references existing files"

    - finding: "Existing tests don't cover symlink edge case"
      evidence: |
        test/cmdlineargs.jl lines 567-626 test various --code-coverage=@path scenarios:
        - Specific file (line 568-574)
        - Directory (line 576-583)
        - Current directory (line 585-595)
        - Relative paths (line 597-617)
        - Non-matching directory (line 619-626)
        None create symlinks to test the specific bug this PR fixes.
      impact: "Medium - the exact bug scenario (Pkg testing with symlinks) is untested"

    - finding: "JL_LOG_PATH constant value is 3"
      evidence: "src/julia.h:2537: #define JL_LOG_PATH 3"
      impact: "Informational - explains the magic number 3 in JLOptions().code_coverage checks"

  corrections_to_original_analysis:
    - field: "pipeline_impact[0].evidence[0].loc"
      original: "9100-9106"
      corrected: "9102-9107"
      reason: "do_coverage lambda actually starts at line 9102"

  risk_assessment_confirmation: |
    CONFIRMED: Risk level is correctly assessed as LOW.

    Supporting evidence:
    1. Change is isolated to path-specific coverage mode (JL_LOG_PATH = 3)
    2. Default coverage modes (user, all) are unaffected
    3. jl_absrealpath was already battle-tested for CLI path resolution
    4. Memory management follows existing patterns (malloc_s/free pairs)
    5. Fallback behavior handles edge cases gracefully
    6. Performance impact only affects --code-coverage=@path users

    The only notable concern is the inconsistency with jl_is_file_tracked(),
    but this affects interpreter coverage which is noted as a future overhaul target.

  open_questions_status:
    - question: "Should jl_is_file_tracked also use realpath?"
      status: "still_open"
      note: "PR author acknowledges this will be addressed in future coverage overhaul"
    - question: "Could path resolution be cached?"
      status: "still_open"
      note: "Valid optimization opportunity; most line entries share same file"
    - question: "Timeline for coverage overhaul?"
      status: "still_open"
      note: "No timeline specified in PR"
