schema_version: "1.0"
pr:
  number: 60048
  title: "Backports for 1.13.0-alpha1"
  url: "https://github.com/JuliaLang/julia/pull/60048"
  author: "KristofferC"
  labels:
    - "release"
  merged_at: "2025-11-17T07:25:02Z"
  merge_commit_sha: "25da06e0cd4e808466066639fd4bb03c709829c6"
  diff_url: "https://github.com/JuliaLang/julia/pull/60048.diff"
scope:
  files_touched:
    - "Compiler/src/tfuncs.jl"
    - "Compiler/test/effects.jl"
  components:
    - "Compiler.Inference"
  pipeline_stages:
    - "TypeInference"
analysis:
  intent:
    summary: |
      Backport of PR #60011 to fix incorrect pointer arithmetic inference. The bug caused
      `Ptr{T}(C_NULL) + offset` inside functions to return the original null pointer instead
      of the offset pointer, because the compiler incorrectly preserved Const lattice elements
      for pointer arithmetic results.
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/60009"
      - "https://github.com/JuliaLang/julia/pull/60011"
  direct_changes:
    - summary: |
        Changed pointerarith_tfunc to return widenconst(ptr) instead of ptr. The old code
        returned the ptr argument directly, which preserved Const lattice elements even when
        the offset was non-constant, causing incorrect constant propagation.
      component: "Compiler.Inference"
      evidence:
        - source: "diff"
          path: "Compiler/src/tfuncs.jl"
          loc: "710-712"
          url: "https://github.com/JuliaLang/julia/blob/25da06e0cd4e808466066639fd4bb03c709829c6/Compiler/src/tfuncs.jl#L710-L712"
          snippet: |
            @nospecs function pointerarith_tfunc(L::AbstractLattice, ptr, offset)
                return widenconst(ptr)
            end
        - source: "diff"
          path: "Compiler/src/tfuncs.jl"
          loc: "756-757"
          url: "https://github.com/JuliaLang/julia/blob/25da06e0cd4e808466066639fd4bb03c709829c6/Compiler/src/tfuncs.jl#L756-L757"
          snippet: |
            add_tfunc(add_ptr, 2, 2, pointerarith_tfunc, 1)
            add_tfunc(sub_ptr, 2, 2, pointerarith_tfunc, 1)
    - summary: |
        Added regression test that verifies pointer arithmetic on C_NULL produces the
        correct offset pointer value.
      component: "Compiler.Inference"
      evidence:
        - source: "test"
          path: "Compiler/test/effects.jl"
          loc: "1491-1495"
          url: "https://github.com/JuliaLang/julia/blob/25da06e0cd4e808466066639fd4bb03c709829c6/Compiler/test/effects.jl#L1491-L1495"
          snippet: |
            # https://github.com/JuliaLang/julia/issues/60009
            function null_offset(offset)
                Ptr{UInt8}(C_NULL) + offset
            end
            @test null_offset(Int(100)) == Ptr{UInt8}(UInt(100))
  secondary_effects:
    - effect: |
        Pointer arithmetic inside functions now correctly computes offset pointers instead
        of incorrectly returning the original constant pointer value.
      mechanism: |
        builtin_tfunction(interp, f, argtypes, sv) [tfuncs.jl:2797]
          -> For non-pure or non-all-const args, looks up tfunc via T_IFUNC[add_ptr]
          -> calls pointerarith_tfunc(L, ptr, offset) [tfuncs.jl:710]
             OLD: return ptr  -- if ptr=Const(Ptr{UInt8}(0)), returns Const(Ptr{UInt8}(0))
             NEW: return widenconst(ptr)  -- returns Ptr{UInt8} (the type, not a constant)
          -> inference result propagates to optimization passes
          -> OLD behavior: optimizer sees Const result, replaces expression with constant
          -> NEW behavior: optimizer sees Ptr{UInt8} type, keeps the addition
      downstream_surfaces:
        - "Type inference for add_ptr and sub_ptr intrinsics"
        - "Constant propagation through pointer arithmetic"
        - "Optimization passes that fold constants"
      likelihood: "high"
      impact: "high"
      evidence:
        - source: "diff"
          path: "Compiler/src/tfuncs.jl"
          loc: "703"
          url: "https://github.com/JuliaLang/julia/blob/25da06e0cd4e808466066639fd4bb03c709829c6/Compiler/src/typelattice.jl#L703"
          snippet: |
            widenconst(c::Const) = (v = c.val; isa(v, Type) ? Type{v} : typeof(v))
        - source: "issue"
          path: "github.com/JuliaLang/julia/issues/60009"
          snippet: |
            function null_offset(offset)
                Ptr{UInt8}(C_NULL) + offset
            end
            @show Ptr{UInt8}(C_NULL) + Int(100)  # Works: 0x64
            @show null_offset(Int(100))          # Was broken: 0x0, now fixed: 0x64
    - effect: |
        Type inference for pointer arithmetic no longer preserves Const lattice precision
        when the pointer argument is constant but offset is not. This is a correctness fix,
        not a regression in precision.
      mechanism: |
        widenconst(Const(Ptr{UInt8}(0))) [typelattice.jl:703]
          -> returns typeof(Ptr{UInt8}(0)) = Ptr{UInt8}
        This ensures inference returns the correct type (Ptr{T}) rather than an incorrect
        constant value that would be wrong for any non-zero offset.
      downstream_surfaces:
        - "Core.Compiler type inference results"
      likelihood: "high"
      impact: "low"
      evidence:
        - source: "diff"
          path: "Compiler/src/typelattice.jl"
          loc: "701-710"
          url: "https://github.com/JuliaLang/julia/blob/25da06e0cd4e808466066639fd4bb03c709829c6/Compiler/src/typelattice.jl#L701-L710"
          snippet: |
            widenconst(::AnyConditional) = Bool
            widenconst(a::AnyMustAlias) = widenconst(widenmustalias(a))
            widenconst(c::Const) = (v = c.val; isa(v, Type) ? Type{v} : typeof(v))
            widenconst(::PartialTypeVar) = TypeVar
            widenconst(t::Core.PartialStruct) = t.typ
            widenconst(t::PartialOpaque) = t.typ
            @nospecializeinfer widenconst(@nospecialize t::Type) = t
            widenconst(::TypeVar) = error("unhandled TypeVar")
            widenconst(::Vararg) = error("unhandled Vararg")
            widenconst(::LimitedAccuracy) = error("unhandled LimitedAccuracy")
  compatibility:
    behavioral:
      - summary: |
          Pointer arithmetic now returns correct results. Code that previously produced
          incorrect null pointers (due to the bug) will now produce correct offset pointers.
          This is a bug fix with no backwards-incompatible behavior changes.
        evidence:
          - source: "test"
            path: "Compiler/test/effects.jl"
            loc: "1491-1495"
            snippet: |
              @test null_offset(Int(100)) == Ptr{UInt8}(UInt(100))
  performance:
    compile_time:
      - summary: "Negligible overhead from widenconst call (single typeof operation). ESTIMATED."
        evidence:
          - source: "diff"
            path: "Compiler/src/tfuncs.jl"
            loc: "710-712"
            snippet: |
              @nospecs function pointerarith_tfunc(L::AbstractLattice, ptr, offset)
                  return widenconst(ptr)
              end
    runtime:
      - summary: |
          May generate slightly more code for pointer arithmetic in functions where the
          pointer was previously (incorrectly) constant-folded. This is a correctness fix -
          the previous behavior was a bug that produced wrong results. ESTIMATED.
        evidence:
          - source: "issue"
            path: "github.com/JuliaLang/julia/issues/60009"
            snippet: |
              Previously: null_offset(Int(100)) returned 0x0 (wrong, due to constant folding)
              Now: null_offset(Int(100)) returns 0x64 (correct)
  tests:
    changed_files:
      - "Compiler/test/effects.jl"
    new_behavior_assertions:
      - "null_offset(Int(100)) == Ptr{UInt8}(UInt(100)) - verifies pointer arithmetic produces correct offset"
    coverage_gaps:
      - "No test for sub_ptr intrinsic (only add_ptr tested via + operator)"
      - "No test for non-null constant pointers"
  risk:
    level: "low"
    rationale:
      - "Change is a targeted bug fix to a single tfunc with clear semantics"
      - "The fix makes inference correct rather than changing working behavior"
      - "New regression test locks in the expected behavior"
      - "widenconst is a well-tested utility function used throughout the inference system"
  open_questions:
    - "Should sub_ptr be tested separately to ensure symmetry with add_ptr fix?"
  recommendations:
    - "The fix is correct and complete for the reported issue"
    - "Consider adding a test case for sub_ptr to improve coverage"
