schema_version: "1.0"
pr:
  number: 55045
  title: "implement `sret_union` ABI for pointer-ful types"
  url: "https://github.com/JuliaLang/julia/pull/55045"
  author: "topolarity"
  labels:
    - "performance"
    - "compiler:codegen"
  created_at: "2024-07-05T18:01:49Z"
  closed_at: "2025-12-08T16:29:02Z"
  merged_at: null
  merge_commit_sha: null
  head_sha: "95c412a8058d723d2f1632fba005ed6dfbd5901f"
  status: "closed_unmerged"
  diff_url: "https://github.com/JuliaLang/julia/pull/55045.diff"

scope:
  files_touched:
    - "doc/src/devdocs/compiler.md"
    - "src/ccall.cpp"
    - "src/cgutils.cpp"
    - "src/codegen.cpp"
    - "src/intrinsics.cpp"
    - "src/llvm-codegen-shared.h"
    - "src/llvm-late-gc-lowering.cpp"
    - "test/llvmpasses/late-lower-gc-sret.ll"
    - "test/llvmpasses/late-lower-gc.ll"
  components:
    - "Compiler.codegen"
    - "Compiler.gc_lowering"
  pipeline_stages:
    - "Codegen"
    - "GC_Lowering"
  lines_changed:
    insertions: 1040
    deletions: 786

analysis:
  intent:
    summary: |
      Extends Julia's union ABI to support stack-allocation of pointer-ful types.
      Previously, the `sret` ABI could stack-allocate a single pointer-ful type,
      and the `union` ABI could stack-allocate many pointer-free types. This PR
      unifies these into `sret_union` which can stack-allocate any union members
      including those containing pointers by separating inline GC roots from
      the value data.
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/53584"
    motivation: |
      The stated goal is to eliminate heap allocations for temporary "wrappers"
      like `Some{T}` where T contains pointers. The benchmark shows a reduction
      from 968750 allocations (14.78 MiB) to 0 allocations for a loop returning
      `Union{Some{Vector}, Nothing}`.

  direct_changes:
    - summary: "Add `inline_roots` field to `jl_cgval_t` for tracking GC roots separately"
      component: "Compiler.codegen"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "1729"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/codegen.cpp#L1729"
          snippet: |
            SmallVector<Value*,0> inline_roots; // if present, `V` is a pointer, but not in canonical layout

    - summary: "Add `inline_roots` handling in jl_cgval_t copy constructor for type narrowing"
      component: "Compiler.codegen"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "1824-1851"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/codegen.cpp#L1824-L1851"
          snippet: |
            // discard roots that do not apply anymore
            // or drop this whole value if there are not enough roots to populate it
            if (!inline_roots.empty()) {
                size_t inline_roots_count;
                bool justpointers = false;
                if (tindex) {
                    bool allunbox;
                    size_t nbytes, align, min_align;
                    union_alloca_type((jl_uniontype_t*)typ, allunbox, nbytes, align, min_align, inline_roots_count);
                    justpointers = allpointers(nbytes, inline_roots_count);
                    if (inline_roots_count > inline_roots.size())
                        inline_roots_count = inline_roots.size();
                }
                else if (!deserves_stack(typ)) {
                    inline_roots_count = 0;
                }
                else {
                    const jl_datatype_layout_t *layout = ((jl_datatype_t*)typ)->layout;
                    inline_roots_count = layout ? layout->npointers : 0;
                    justpointers = layout ? allpointers((jl_datatype_t*)typ) : 0;
                }
                assert(v.TIndex || inline_roots.size() == inline_roots_count);
                if (V == nullptr && constant == nullptr && !isghost && (inline_roots_count == 0 || (!tindex && !justpointers)))
                    *this = jl_cgval_t(); // no data to populate this value
                else if (inline_roots_count < inline_roots.size())
                    inline_roots.truncate(inline_roots_count);
                else if (inline_roots_count > inline_roots.size())
                    *this = jl_cgval_t(); // not enough roots to populate this value
                // drop data if all of the content is in the roots
                if (inline_roots_count > 0 && justpointers && Vboxed == nullptr)
                    V = nullptr;
            }

    - summary: "Add `allpointers()` helper to check if type is entirely pointers"
      component: "Compiler.codegen"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "1598-1610"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/codegen.cpp#L1598-L1610"
          snippet: |
            static bool allpointers(size_t size, size_t npointers)
            {
                return size == npointers * sizeof(void*);
            }

            static bool allpointers(jl_datatype_t *typ)
            {
                return allpointers(jl_datatype_size(typ), typ->layout->npointers);
            }

    - summary: "Add `deserves_unionbox()` function to determine if type needs boxing in union"
      component: "Compiler.codegen"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "1632-1635"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/codegen.cpp#L1632-L1635"
          snippet: |
            static bool deserves_unionbox(jl_value_t* t)
            {
                return !deserves_stack(t);
            }

    - summary: "Change `for_each_uniontype_small` to use `deserves_unionbox` instead of `jl_is_pointerfree`"
      component: "Compiler.cgutils"
      evidence:
        - source: "code"
          path: "src/cgutils.cpp"
          loc: "1099"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/cgutils.cpp#L1099"
          snippet: |
            else if (!deserves_unionbox(ty)) {
                f(++counter, (jl_datatype_t*)ty);
                return true;
            }

    - summary: "Remove assertion that `isboxed` and `TIndex` cannot both be set in `jl_cgval_t`"
      component: "Compiler.codegen"
      critical_invariant_change: true
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "1777"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/codegen.cpp#L1777"
          snippet: |
            // REMOVED: assert(!(isboxed && TIndex != nullptr));
            // This allows unions containing pointer-ful types to have both
            // a TIndex (for type tagging) and be boxed (for GC safety)

    - summary: "Add `inline_roots_count` field to `jl_varinfo_t`"
      component: "Compiler.codegen"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "1876-1877"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/codegen.cpp#L1876-L1877"
          snippet: |
            AllocaInst *inline_roots; // stack roots for the inline_roots array, if needed
            size_t inline_roots_count;

    - summary: "Add `ExtractTrackedValues()` function to extract GC roots from LLVM aggregates"
      component: "Compiler.cgutils"
      evidence:
        - source: "code"
          path: "src/cgutils.cpp"
          loc: "419-465"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/cgutils.cpp#L419-L465"
          snippet: |
            static SmallVector<Value*, 0> ExtractTrackedValues(jl_codectx_t &ctx, Value *Src, ArrayRef<unsigned> perm_offsets={}) {
                Type *STy = Src->getType();
                auto Tracked = TrackCompositeType(STy);
                SmallVector<Value*, 0> Ptrs;
                unsigned perm_idx = 0;
                auto ignore_field = [&] (ArrayRef<unsigned> Idxs) {
                    if (perm_idx >= perm_offsets.size())
                        return false;
                    auto offset = getFieldOffset(ctx.builder.GetInsertBlock()->getModule()->getDataLayout(),
                                                 STy, Idxs);
                    do {
                        auto perm_offset = perm_offsets[perm_idx];
                        if (perm_offset > offset)
                            return false;
                        perm_idx++;
                        if (perm_offset == offset) {
                            return true;
                        }
                    } while (perm_idx < perm_offsets.size());
                    return false;
                };
                for (unsigned i = 0; i < Tracked.size(); ++i) {
                    auto Idxs = ArrayRef<unsigned>(Tracked[i]);
                    if (ignore_field(Idxs))
                        continue;
                    Value *Elem = ExtractScalar(ctx, Src, STy, Idxs);
                    if (isTrackedValue(Elem)) // ignore addrspace Loaded when it appears
                        Ptrs.push_back(Elem);
                }
                return Ptrs;
            }

    - summary: "Add `extract_gc_roots()` functions to extract GC roots from values"
      component: "Compiler.cgutils"
      evidence:
        - source: "code"
          path: "src/cgutils.cpp"
          loc: "467-500"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/cgutils.cpp#L467-L500"
          snippet: |
            static llvm::SmallVector<Value*,0> extract_gc_roots(jl_codectx_t &ctx, Value *data_pointer, jl_datatype_t *typ, size_t npointers, MDNode *tbaa, bool isVolatile=false)
            {
                SmallVector<Value*,0> gcroots(npointers);
                if (npointers) {
                    Type *T_prjlvalue = ctx.types().T_prjlvalue;
                    auto roots_ai = jl_aliasinfo_t::fromTBAA(ctx, tbaa);
                    bool isstack = isa<AllocaInst>(data_pointer->stripInBoundsOffsets()) || tbaa == ctx.tbaa().tbaa_stack || tbaa == ctx.tbaa().tbaa_gcframe || tbaa == ctx.tbaa().tbaa_const;
                    for (size_t i = 0; i < npointers; i++) {
                        Value *field_ptr = emit_ptrgep(ctx, data_pointer, jl_ptr_offset(typ, i) * sizeof(jl_value_t*));
                        LoadInst *root = ctx.builder.CreateAlignedLoad(T_prjlvalue, field_ptr, Align(sizeof(void*)), isVolatile);
                        if (!isstack)
                            root->setOrdering(AtomicOrdering::Unordered);
                        roots_ai.decorateInst(root);
                        gcroots[i] = root;
                    }
                }
                return gcroots;
            }

    - summary: "Simplify `emit_unbox()` signature by removing `jltype` parameter"
      component: "Compiler.intrinsics"
      evidence:
        - source: "code"
          path: "src/intrinsics.cpp"
          loc: "436-441"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/intrinsics.cpp#L436-L441"
          snippet: |
            -static Value *emit_unbox(jl_codectx_t &ctx, Type *to, const jl_cgval_t &x, jl_value_t *jt)
            +static Value *emit_unbox(jl_codectx_t &ctx, Type *to, const jl_cgval_t &x)
             {
                 assert(to != getVoidTy(ctx.builder.getContext()));
            -    // TODO: fully validate that x.typ == jt?

    - summary: "Add `voidpointer_update()` helper for ccall pointer conversions"
      component: "Compiler.ccall"
      evidence:
        - source: "code"
          path: "src/ccall.cpp"
          loc: "529-542"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/ccall.cpp#L529-L542"
          snippet: |
            static jl_cgval_t voidpointer_update(jl_codectx_t &ctx, const jl_cgval_t &x)
            {
                if (x.typ == (jl_value_t*)jl_voidpointer_type)
                    return x;
                if (jl_type_intersection(x.typ, (jl_value_t*)jl_pointer_type) == jl_bottom_type)
                    return jl_cgval_t();
                if (x.constant)
                    return mark_julia_type(ctx, julia_const_to_llvm(ctx, x.constant), false, jl_voidpointer_type);
                if (x.V == nullptr)
                    return jl_cgval_t();
                if (!x.inline_roots.empty() || x.ispointer())
                    return mark_julia_slot(x.V, (jl_value_t*)jl_voidpointer_type, NULL, x.tbaa);
                return mark_julia_type(ctx, x.V, false, jl_voidpointer_type);
            }

    - summary: "Add `data_pointer()` helper for extracting data pointer from cgval"
      component: "Compiler.cgutils"
      evidence:
        - source: "code"
          path: "src/cgutils.cpp"
          loc: "84-104"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/cgutils.cpp#L84-L104"
          snippet: |
            static Value *data_pointer(jl_codectx_t &ctx, const jl_cgval_t &x)
            {
                assert(x.ispointer());
                Value *data;
                if (x.constant) {
                    Constant *val = julia_const_to_llvm(ctx, x.constant);
                    if (val && !type_is_ghost(val->getType()))
                        data = get_pointer_to_constant(ctx.emission_context, val, Align(julia_alignment(jl_typeof(x.constant))), "_j_const", *jl_Module);
                    else
                        data = literal_pointer_val(ctx, x.constant);
                }
                else if (x.V == NULL) {
                    data = ConstantPointerNull::get(ctx.types().T_ptr);
                }
                else {
                    data = maybe_decay_tracked(ctx, x.V);
                }
                return data;
            }

    - summary: "Implement split value representation with separate bits and roots storage"
      component: "Compiler.cgutils"
      evidence:
        - source: "code"
          path: "src/cgutils.cpp"
          loc: "1180-1204"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/cgutils.cpp#L1180-L1204"
          snippet: |
            // compute the space required by split_value_into, by simulating it
            // returns (sizeof(split_value), n_pointers)
            static std::pair<size_t,size_t> split_value_size(jl_datatype_t *typ)
            {
                assert(jl_is_datatype(typ));
                size_t dst_off = 0;
                bool hasptr = typ->layout->first_ptr >= 0;
                size_t npointers = hasptr ? typ->layout->npointers : 0;
                // drop the data pointer if the entire structure is just pointers
                bool nodata = allpointers(typ);
                if (nodata)
                    dst_off = 0;
                else
                    dst_off = jl_datatype_size(typ);
                return std::make_pair(dst_off, npointers);
            }

    - summary: "Rewrite `convert_julia_type_to_union()` for new union representation"
      component: "Compiler.codegen"
      evidence:
        - source: "code"
          path: "src/codegen.cpp"
          loc: "2503-2800"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/codegen.cpp#L2503-L2800"
          snippet: |
            static jl_cgval_t convert_julia_type_to_union(jl_codectx_t &ctx, const jl_cgval_t &v, jl_value_t *typ, bool allow_mismatch)
            {
                if (v.typ == jl_bottom_type || (v.TIndex && jl_egal(v.typ, typ)))
                    return v; // fast-path
                assert(jl_is_uniontype(typ));

                Value *union_box_tindex = ConstantInt::get(getInt8Ty(ctx.builder.getContext()), UNION_BOX_MARKER);
                Value *new_tindex = union_box_tindex;
                bool computed_new_index_early = v.TIndex == nullptr;
                if (computed_new_index_early) {
                    if (jl_is_concrete_type(v.typ) || v.constant) {
                        unsigned new_idx = get_box_tindex((jl_datatype_t*)(v.constant ? jl_typeof(v.constant) : v.typ), typ);
                        if (new_idx) {
                            new_tindex = ConstantInt::get(getInt8Ty(ctx.builder.getContext()), new_idx);

    - summary: "Change GC lowering from `sret` attribute to `julia.return_roots` attribute"
      component: "Compiler.gc_lowering"
      evidence:
        - source: "code"
          path: "src/llvm-late-gc-lowering.cpp"
          loc: "1254-1278"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/llvm-late-gc-lowering.cpp#L1254-L1278"
          snippet: |
            // Loop over all arguments to find those with "julia.return_roots" attribute
            AttributeList Attrs = CI->getAttributes();
            for (unsigned i = 0; i < CI->arg_size(); ++i) {
                Attribute RetRootsAttr = Attrs.getParamAttr(i, "julia.return_roots");
                if (RetRootsAttr.isValid()) {
                    size_t return_roots = atol(RetRootsAttr.getValueAsString().data());
                    assert(return_roots);
                    HasDefBefore = true;
                    auto gc_allocas = FindSretAllocas(CI->getArgOperand(i)->stripInBoundsOffsets());
                    if (gc_allocas.size() == 0) {
                        llvm_dump(&F);
                        abort();
                    }
                    for (AllocaInst *SRet_gc : gc_allocas) {
                        Type *ElT = SRet_gc->getAllocatedType();
                        if (!(SRet_gc->isStaticAlloca() && isa<PointerType>(ElT) && ElT->getPointerAddressSpace() == AddressSpace::Tracked)) {
                            auto &live_roots = S.ArrayAllocas[SRet_gc];
                            if (live_roots < return_roots)
                                live_roots = return_roots;
                        }
                    }
                }
            }

    - summary: "Export `TrackCompositeType` function in header"
      component: "Compiler.codegen_shared"
      evidence:
        - source: "code"
          path: "src/llvm-codegen-shared.h"
          loc: "106"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/src/llvm-codegen-shared.h#L106"
          snippet: |
            llvm::SmallVector<llvm::SmallVector<unsigned, 0>, 0> TrackCompositeType(llvm::Type *T);

    - summary: "Update LLVM test for new julia.return_roots attribute"
      component: "Compiler.tests"
      evidence:
        - source: "test"
          path: "test/llvmpasses/late-lower-gc-sret.ll"
          loc: "7-23"
          url: "https://github.com/JuliaLang/julia/blob/95c412a8058d/test/llvmpasses/late-lower-gc-sret.ll#L7-L23"
          snippet: |
            declare swiftcc void @sret_call(ptr noalias nocapture noundef nonnull "julia.return_roots"="3" sret([3 x ptr addrspace(10)]), ptr nonnull swiftself, ptr addrspace(10) nonnull)

            define hidden swiftcc nonnull ptr addrspace(10) @sret_select(ptr nonnull swiftself "gcstack" %0, ptr addrspace(10) noundef nonnull align 8 dereferenceable(88) %1, i1 %unpredictable) {
              ; CHECK-LABEL: @sret_select
              ; CHECK: %gcframe = call ptr @julia.new_gc_frame(i32 6)
              ; CHECK: call ptr @julia.get_gc_frame_slot(ptr %gcframe, i32 3)
              ; CHECK: call ptr @julia.get_gc_frame_slot(ptr %gcframe, i32 0)

  secondary_effects:
    - effect: "PHI node handling requires dynamic root extraction for pointer-ful union transitions"
      mechanism: |
        When converting values to union type where the incoming Union{...} type has
        pointer-containing types that weren't previously tracked, the code must
        dynamically extract roots at runtime.

        Call chain with file:line:
        convert_julia_type_to_union() [codegen.cpp:2503]
          -> checks v.TIndex for existing union representation [codegen.cpp:2515]
          -> for_each_uniontype_small() iterates union members [codegen.cpp:2696]
          -> creates BasicBlock for each new pointer-ful type [codegen.cpp:2760]
          -> extract_gc_roots(ctx, Vboxed, jt, npointers, v.tbaa) [codegen.cpp:2763]
          -> PHI nodes merge inline_roots from different branches [codegen.cpp:2738-2744]

        The PR author noted as a TODO (codegen.cpp:2524):
        "remove this branch once all consumers of v.TIndex understand how to
        handle a non-ispointer value"
      downstream_surfaces:
        - "Compiler.ssa_ir"
        - "Compiler.optimization"
        - "Union type conversions at function boundaries"
      likelihood: "high"
      impact: "medium"

    - effect: "jl_cgval_t invariants changed - isboxed and TIndex can now coexist"
      mechanism: |
        Previously, the assertion `assert(!(isboxed && TIndex != nullptr))` enforced
        that boxed values could not have a type index. This restriction is removed
        to allow unions containing pointer-ful types to track both:
        - TIndex: the runtime type tag for union discrimination
        - isboxed: whether the value is heap-allocated (for GC)

        This affects all code that assumed `isboxed` implies `TIndex==nullptr`.

        Call chain:
        jl_cgval_t constructor [codegen.cpp:1764-1780]
          -> validates V, Vboxed, TIndex, tbaa
          -> REMOVED: assert(!(isboxed && TIndex != nullptr)) [codegen.cpp:1777]
          -> Now allows both flags simultaneously for pointer-ful unions

        Downstream code must now check TIndex independently of isboxed status.
      downstream_surfaces:
        - "All jl_cgval_t consumers"
        - "Type conversion functions"
        - "Value emission functions"
      likelihood: "high"
      impact: "high"

    - effect: "GC root tracking changes from sret attribute to julia.return_roots"
      mechanism: |
        Previously, GC roots in sret returns were tracked via the LLVM sret
        attribute and CountTrackedPointers. Now they use a custom "julia.return_roots"
        attribute that explicitly specifies the count, allowing finer control
        over root tracking for split union values.

        Call chain:
        LocalScan() [llvm-late-gc-lowering.cpp:1254]
          -> iterates CI->arg_size() [llvm-late-gc-lowering.cpp:1256]
          -> checks Attrs.getParamAttr(i, "julia.return_roots") [llvm-late-gc-lowering.cpp:1257]
          -> atol(RetRootsAttr.getValueAsString().data()) to get count [llvm-late-gc-lowering.cpp:1259]
          -> FindSretAllocas() to locate stack allocations [llvm-late-gc-lowering.cpp:1262]
          -> Updates S.ArrayAllocas[SRet_gc] with live_roots count [llvm-late-gc-lowering.cpp:1274]
      downstream_surfaces:
        - "LLVM pass pipeline"
        - "GC safepoint insertion"
        - "GPUCompiler (inspects LLVM IR attributes)"
        - "Enzyme (custom LLVM pass pipeline)"
      likelihood: "high"
      impact: "medium"

    - effect: "Split value representation separates bits storage from pointer roots"
      mechanism: |
        The split_value_into() function now handles inline_roots separately from
        the value data, enabling stack allocation of pointer-ful types.

        Call chain:
        split_value_size(typ) [cgutils.cpp:1182]
          -> computes (data_size, npointers) for split representation
          -> if allpointers(typ): data_size = 0 (all content in roots)

        split_value_into() [cgutils.cpp:1216]
          -> if x.inline_roots not empty: copy from existing roots [cgutils.cpp:1228-1233]
          -> else: extract pointers from memory, storing undef markers [cgutils.cpp:1268-1277]
          -> store_all_roots() writes roots to separate inline_roots_ptr [cgutils.cpp:1232]

        This enables types like Some{Vector} to be stack-allocated by:
        1. Storing the Vector pointer in inline_roots (GC-tracked)
        2. Storing remaining bits (if any) in the data portion
      downstream_surfaces:
        - "Struct return handling"
        - "Union field access"
        - "Variable assignment"
      likelihood: "high"
      impact: "medium"

    - effect: "Removal of jltype parameter from emit_unbox changes call sites"
      mechanism: |
        emit_unbox() now uses x.typ internally instead of a separate jltype
        parameter. This simplifies the API but requires all callers to ensure
        x.typ is correctly set.

        Before: emit_unbox(ctx, to, x, jltype)
        After:  emit_unbox(ctx, to, x)

        The function now derives alignment from x.typ:
        -    unsigned alignment = julia_alignment(jt);
        +    unsigned alignment = julia_alignment(x.typ);

        All 15+ call sites in ccall.cpp, codegen.cpp, intrinsics.cpp are updated.
      downstream_surfaces:
        - "All emit_unbox callers in ccall.cpp, codegen.cpp, intrinsics.cpp"
      likelihood: "high"
      impact: "low"

    - effect: "Variable slot allocation now tracks inline_roots_count"
      mechanism: |
        jl_varinfo_t gains inline_roots and inline_roots_count fields to track
        GC roots for local variables containing pointer-ful union types.

        Allocation path [codegen.cpp:8768-8804]:
        union_alloca_type(ut, allunbox, align, nbytes, inline_roots) [codegen.cpp:8769]
        if (inline_roots):
          AllocaInst *roots = emit_static_roots(ctx, inline_roots) [codegen.cpp:8789]
          varinfo.inline_roots = roots [codegen.cpp:8790]
          varinfo.inline_roots_count = inline_roots [codegen.cpp:8791]

        Assignment path [codegen.cpp:5859-5866]:
        SmallVector<Value*,0> inline_roots(vi.inline_roots_count, Vnull) [codegen.cpp:5859]
        store_all_roots(ctx, inline_roots, vi.inline_roots, ...) [codegen.cpp:5862]
      downstream_surfaces:
        - "Local variable handling"
        - "SSA value tracking"
      likelihood: "high"
      impact: "medium"

    - effect: "update_julia_type behavior changed for union types with TIndex"
      mechanism: |
        The update_julia_type function now handles the case where v.TIndex is set
        differently, checking for sufficient inline_roots before allowing type
        narrowing.

        Key change [codegen.cpp:2422]:
        if (v.V == NULL && v.inline_roots.empty()) {
            // type mismatch (there weren't any non-ghost values in the union)
            if (!allow_mismatch)
                CreateTrap(ctx.builder);
            return jl_cgval_t();
        }

        Previously, v.V == NULL alone was sufficient to detect this case.
      downstream_surfaces:
        - "Type narrowing operations"
        - "Union discrimination"
      likelihood: "medium"
      impact: "low"

  compatibility:
    internal_api:
      - field: "jl_cgval_t.inline_roots"
        change: "New SmallVector<Value*,0> field for tracking GC roots separately from value data"
        affected_tools:
          - tool: "GPUCompiler"
            usage: "May need to handle inline_roots when inspecting jl_cgval_t values"
          - tool: "Enzyme"
            usage: "Custom derivative rules may need to account for split value representation"

      - field: "jl_cgval_t invariants (isboxed && TIndex)"
        change: "Removed assertion that isboxed and TIndex cannot both be set"
        affected_tools:
          - tool: "Any code assuming isboxed implies TIndex==nullptr"
            usage: "Must now check TIndex independently of boxed status"

      - field: "jl_varinfo_t.inline_roots and inline_roots_count"
        change: "New fields for tracking GC roots in local variables"
        affected_tools:
          - tool: "Debuggers inspecting stack frames"
            usage: "Need to account for split root storage"

      - field: "emit_unbox() signature"
        change: "Removed jltype parameter; now uses x.typ internally"
        affected_tools:
          - tool: "Any external code calling emit_unbox directly"
            usage: "Must update call sites to remove jltype argument"

      - field: "TrackCompositeType()"
        change: "Now exported in llvm-codegen-shared.h, returns SmallVector<SmallVector<unsigned,0>,0>"
        affected_tools:
          - tool: "LLVM passes that track GC roots"
            usage: "Can use TrackCompositeType to find tracked pointers in composite types"

      - field: "julia.return_roots attribute"
        change: "New LLVM function attribute for GC root tracking in sret-like returns"
        affected_tools:
          - tool: "GPUCompiler"
            usage: "Must handle julia.return_roots when processing LLVM IR"
          - tool: "Enzyme"
            usage: "Must propagate julia.return_roots through AD transformations"

    behavioral:
      - area: "Union stack allocation"
        change: "Unions containing pointer-ful types may now be stack-allocated instead of heap-allocated"
        user_visible: true
        expected_impact: "Performance improvement for patterns like Union{Some{Vector}, Nothing}"

      - area: "PHI node boxing"
        change: "Some PHI nodes may now require boxing that didn't before (regression noted in PR)"
        user_visible: false
        expected_impact: "Potential regression in some union-heavy code paths"

  performance:
    compile_time:
      - area: "Union type analysis"
        description: |
          Additional work in for_each_uniontype_small to check deserves_unionbox
          instead of jl_is_pointerfree. ESTIMATED: negligible overhead since
          deserves_unionbox simply calls deserves_stack which checks:
          - jl_is_concrete_immutable(t)
          - jl_is_datatype_singleton(dt) || jl_datatype_isinlinealloc(dt, 0)

      - area: "inline_roots management"
        description: |
          Additional bookkeeping for inline_roots in jl_cgval_t copy constructor
          and value operations. ESTIMATED: O(n) where n = number of pointers in type,
          typically small (1-10). May add ~1-5% overhead to codegen for code using
          pointer-ful unions.

    runtime:
      - area: "Stack allocation of pointer-ful unions"
        description: |
          MEASURED (from PR description):
          - Before: 6.877 ms (968750 allocations: 14.78 MiB)
          - After:  1.675 ms (0 allocations: 0 bytes)

          For the benchmark:
          const v = Any[]
          @noinline maybe_wrapped(i) = (i % 32 != 0) ? Some(v) : nothing
          function foo()
              count = 0
              for i = 1:1_000_000
                  count += (maybe_wrapped(i) !== nothing) ? 1 : 0
              end
              return count
          end
        expected_improvement: "4x speedup, elimination of allocations for union wrappers"

  risk:
    level: "medium"
    rationale:
      - "PR was closed without merging after 17 months of development, suggesting unresolved issues"
      - "Author noted PHI node handling introduces new boxing where none existed before"
      - "Critical invariant change: isboxed && TIndex can now both be set in jl_cgval_t"
      - "Significant changes to core codegen structures (jl_cgval_t, jl_varinfo_t, emit_unbox)"
      - "Changes to GC lowering pass require careful verification for correctness"
      - "Multiple TODO comments in code indicating incomplete implementation"
      - "New julia.return_roots attribute must be handled by all LLVM consumers"

  open_questions:
    - "How to handle PHI nodes where incoming Union type has pointer-containing type but runtime value is pointer-free?"
    - "Was issue #53584 resolved by alternative means, or does it remain open?"
    - "What specific issues caused the PR to be closed after 17 months without merging?"
    - "Are there performance regressions in other benchmarks that offset the gains shown?"
    - "How should downstream packages (GPUCompiler, Enzyme) handle the new julia.return_roots attribute?"
    - "Is the split value representation compatible with all existing codegen paths?"

  recommendations:
    - "If this PR is reopened, focus on resolving the PHI node boxing regression first"
    - "Consider a more incremental approach that separates the ABI changes from the GC lowering changes"
    - "Add comprehensive tests for union types containing various pointer patterns"
    - "Benchmark common Julia patterns to ensure no unexpected regressions"
    - "GPUCompiler must be updated to handle julia.return_roots attribute before this PR lands"
    - "Enzyme must verify AD correctness with split value representation"
    - "Document the new jl_cgval_t invariants clearly for downstream consumers"
    - "Add assertions to verify inline_roots consistency in debug builds"
