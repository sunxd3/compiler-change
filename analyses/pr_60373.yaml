schema_version: "1.0"
pr:
  number: 60373
  title: "`Expr`/`SyntaxTree` parity: trivial conversions"
  url: "https://github.com/JuliaLang/julia/pull/60373"
  author: "mlechu"
  labels: ["JuliaLowering"]
  merged_at: "2025-12-16T23:39:38Z"
  merge_commit_sha: "1cff13010c1abd587d603c76394db6f00ef62a12"
  diff_url: "https://github.com/JuliaLang/julia/pull/60373.diff"
scope:
  files_touched:
    - "JuliaLowering/src/compat.jl"
    - "JuliaLowering/src/kinds.jl"
    - "JuliaLowering/test/compat.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Lowering"
    - "MacroExpansion"
analysis:
  intent:
    summary: |
      Add trivial conversions between Expr and the new Expr-like SyntaxTree (EST)
      so round-tripping is possible and future syntax-evolution steps can build on
      a stable conversion layer.
    issue_links: []
  direct_changes:
    - summary: "Introduce Expr -> EST conversion with explicit handling for symbols, QuoteNode, scope layers, and unknown heads."
      component: "JuliaLowering/src/compat.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/compat.jl"
          loc: "633-707"
          url: "https://github.com/JuliaLang/julia/blob/1cff13010c1abd587d603c76394db6f00ef62a12/JuliaLowering/src/compat.jl#L633-L707"
          snippet: |
            function expr_to_est(@nospecialize(e), lnn::LineNumberNode=LineNumberNode(0, :none))
                graph = ensure_attributes!(
                    SyntaxGraph(),
                    kind=Kind, syntax_flags=UInt16,
                    source=SourceAttrType, var_id=Int, value=Any,
                    name_val=String, is_toplevel_thunk=Bool,
                    scope_layer=LayerId, meta=CompileHints,
                    toplevel_pure=Bool)
                SyntaxTree(graph, _expr_to_est(graph, e, lnn)[1])
            end

            function _expr_to_est(graph::SyntaxGraph, @nospecialize(e), src::LineNumberNode)
                st = if e === Core.nothing
                    setattr!(makeleaf(graph, src, K"core"), :name_val, "nothing")
                elseif e isa Symbol
                    setattr!(makeleaf(graph, src, K"Identifier"), :name_val, String(e))
                elseif e isa QuoteNode
                    cid, _ = _expr_to_est(graph, e.value, src)
                    makenode(graph, src, K"inert", NodeId[cid])
                elseif e isa Expr && e.head === :scope_layer
                    @assert length(e.args) === 2 && e.args[1] isa Symbol
                    ident = makeleaf(graph, src, K"Identifier")
                    setattr!(ident, :name_val, String(e.args[1]))
                    setattr!(ident, :scope_layer, e.args[2])
                elseif e isa Expr
                    head_s = string(e.head)
                    st_k = find_kind(head_s)
                    old_src = _get_inner_lnn(e, src)
                    cs = NodeId[]
                    rm_linenodes = e.head in (:block, :toplevel)
                    for arg in e.args
                        if rm_linenodes && arg isa LineNumberNode
                            src = arg
                        else
                            cid, src = _expr_to_est(graph, arg, src)
                            push!(cs, cid)
                        end
                    end
                    if isnothing(st_k)
                        setattr!(makenode(graph, src, K"unknown_head", cs), :name_val, head_s)
                    else
                        makenode(graph, old_src, st_k, cs)
                    end
                else
                    @assert !isa_lowering_ast_node(e)
                    if e isa LineNumberNode
                        src = e
                    end
                    setattr!(makeleaf(graph, src, K"Value"), :value, e)
                end

                return st._id, src
            end
    - summary: "Introduce EST -> Expr conversion, including special handling for K\"Value\" and unknown heads." 
      component: "JuliaLowering/src/compat.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/compat.jl"
          loc: "709-745"
          url: "https://github.com/JuliaLang/julia/blob/1cff13010c1abd587d603c76394db6f00ef62a12/JuliaLowering/src/compat.jl#L709-L745"
          snippet: |
            function est_to_expr(st::SyntaxTree)
                k = kind(st)
                return if k === K"Identifier"
                    n = Symbol(st.name_val)
                    hasattr(st, :scope_layer) ? Expr(:scope_layer, n, st.scope_layer) : n
                elseif k === K"Value"
                    v = st.value
                    isa_lowering_ast_node(v) ? QuoteNode(v) : v
                elseif k === K"core" && numchildren(st) === 0 && st.name_val === "nothing"
                    nothing
                elseif k === K"inert"
                    QuoteNode(est_to_expr(st[1]))
                else
                    @assert !is_leaf(st)
                    head = Symbol(k === K"unknown_head" ? st.name_val : untokenize(k))
                    need_lnns = head in (:block, :toplevel)
                    out = Expr(head)
                    for c in children(st)
                        need_lnns && push!(out.args, source_location(LineNumberNode, c))
                        push!(out.args, est_to_expr(c))
                    end
                    n = length(out.args)
                    if (k === K"module" && 3 <= n <= 4 && kind(st[end]) === K"block") ||
                        (k in KSet"function macro" && n === 2 && kind(st[end]) === K"block")
                        pushfirst!(out.args[end].args, source_location(LineNumberNode, st))
                    end
                    out
                end
            end
    - summary: "Register a new extension kind (unknown_head) so EST can represent Expr heads without a known SyntaxKind." 
      component: "JuliaLowering/src/kinds.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/kinds.jl"
          loc: "3-28"
          url: "https://github.com/JuliaLang/julia/blob/1cff13010c1abd587d603c76394db6f00ef62a12/JuliaLowering/src/kinds.jl#L3-L28"
          snippet: |
            function _register_kinds()
                JuliaSyntax.register_kinds!(JuliaLowering, 1, [
                    "BEGIN_EXTENSION_KINDS"
                        "atomic"
                        "generated"
                        "gc_preserve"
                        "gc_preserve_begin"
                        "gc_preserve_end"
                        "Value"
                        "Symbol"
                        "inert"
                        "unknown_head"
                        "inbounds"
                        "boundscheck"
                        "inline"
                        "noinline"
                        "loopinfo"
                        "foreigncall"
                        "cfunction"
                        "opaque_closure"
                        "isdefined"
                        "throw_undef_if_not"
                        "symbolic_label"
                        "symbolic_goto"
                        "new"
                        "splatnew"
                        "escape"
                        "hygienic_scope"
                        "static_eval"
                        "extension"
                    "END_EXTENSION_KINDS"
    - summary: "Add round-trip tests for Expr<->EST, including bulk parsing and special Value quoting behavior." 
      component: "JuliaLowering/test/compat.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/test/compat.jl"
          loc: "636-775"
          url: "https://github.com/JuliaLang/julia/blob/1cff13010c1abd587d603c76394db6f00ef62a12/JuliaLowering/test/compat.jl#L636-L775"
          snippet: |
            @testset "Expr<->EST" begin

                local roundtrip = e->JuliaLowering.est_to_expr(JuliaLowering.expr_to_est(e))

                local expr_syntax = Any[
                    LineNumberNode(1)
                    :foo
                    Expr(:foo, 1)
                    GlobalRef(Core, :nothing)
                    nothing
                ]

                @testset "special cases: Value implicitly quotes AST nodes" begin
                    @test JL.est_to_expr(@ast_ :foo::K"Value") ==
                        JL.est_to_expr(@ast_ [K"inert" "foo"::K"Identifier"]) ==
                        QuoteNode(:foo)
                end

                @testset "bulk parsed code, no linenodes" begin
                    jl_dir = joinpath(@__DIR__, "..")
                    test_each_in_path(roundtrip, jl_dir)
                end

                @testset "linenodes equal (modules and functions have extra)" begin
                    e = JuliaSyntax.parseall(Expr, """
                    module M
                    function f()
                        if x
                            j
                        elseif y
                            let
                                y
                            end
                        end
                    end
                    begin
                        1
                    end
                    end
                    """; filename="foo")

                    @test e == roundtrip(e)
                end
            end
  secondary_effects:
    - effect: "Round-tripping preserves unknown Expr heads by storing the head string in K\"unknown_head\" nodes."
      mechanism: |
        _expr_to_est(graph, e, src) [compat.jl:659]
          uses find_kind(head_s) [compat.jl:675]
          -> when nothing, makenode(..., K"unknown_head", cs) and setattr! :name_val [compat.jl:687-688]
        est_to_expr(st) [compat.jl:709]
          -> head = Symbol(k === K"unknown_head" ? st.name_val : untokenize(k)) [compat.jl:731]
      downstream_surfaces:
        - "Tools that inspect SyntaxTree kinds (JuliaSyntax-based tooling, macro tools)"
      likelihood: "high"
      impact: "low"
    - effect: "K\"Value\" nodes containing AST nodes now round-trip as QuoteNode to preserve quotation semantics."
      mechanism: |
        est_to_expr(st) [compat.jl:709]
          when k === K"Value", v = st.value [compat.jl:714-716]
          -> isa_lowering_ast_node(v) ? QuoteNode(v) : v [compat.jl:722]
        Tests enforce Value-quoted AST behavior [test/compat.jl:677-686].
      downstream_surfaces:
        - "Macro tooling that embeds Expr/Symbol inside SyntaxTree values"
      likelihood: "medium"
      impact: "medium"
    - effect: "Block/toplevel conversions drop embedded LineNumberNode children and re-insert them on EST->Expr conversion."
      mechanism: |
        _expr_to_est(graph, e, src) [compat.jl:659]
          rm_linenodes = e.head in (:block, :toplevel) [compat.jl:678]
          -> LineNumberNode children update src but are not converted [compat.jl:679-685]
        est_to_expr(st) [compat.jl:709]
          need_lnns = head in (:block, :toplevel) [compat.jl:732]
          -> push source_location(LineNumberNode, c) before each child [compat.jl:735]
      downstream_surfaces:
        - "Tools that compare Expr trees with or without line nodes"
      likelihood: "medium"
      impact: "low"
  compatibility:
    internal_api:
      - field: "Kind registry extension list"
        change: "Adds K\"unknown_head\" to extension kinds to represent Expr heads without a known SyntaxKind."
        affected_tools:
          - tool: "JuliaSyntax-based tooling"
            usage: "Tools enumerating known Kinds or matching on extension kinds should account for K\"unknown_head\"." 
        evidence:
          - source: "code"
            path: "JuliaLowering/src/kinds.jl"
            loc: "3-28"
            url: "https://github.com/JuliaLang/julia/blob/1cff13010c1abd587d603c76394db6f00ef62a12/JuliaLowering/src/kinds.jl#L3-L28"
            snippet: |
              function _register_kinds()
                  JuliaSyntax.register_kinds!(JuliaLowering, 1, [
                      "BEGIN_EXTENSION_KINDS"
                          "Value"
                          "Symbol"
                          "inert"
                          "unknown_head"
                          "inbounds"
                      "END_EXTENSION_KINDS"
    behavioral:
      - change: "Expr <-> SyntaxTree round-trips now normalize AST nodes embedded in K\"Value\" to QuoteNode in the resulting Expr."
        evidence:
          - source: "code"
            path: "JuliaLowering/src/compat.jl"
            loc: "714-723"
            url: "https://github.com/JuliaLang/julia/blob/1cff13010c1abd587d603c76394db6f00ef62a12/JuliaLowering/src/compat.jl#L714-L723"
            snippet: |
              elseif k === K"Value"
                  v = st.value
                  isa_lowering_ast_node(v) ? QuoteNode(v) : v
          - source: "test"
            path: "JuliaLowering/test/compat.jl"
            loc: "677-686"
            url: "https://github.com/JuliaLang/julia/blob/1cff13010c1abd587d603c76394db6f00ef62a12/JuliaLowering/test/compat.jl#L677-L686"
            snippet: |
              @test JL.est_to_expr(@ast_ :foo::K"Value") ==
                  JL.est_to_expr(@ast_ [K"inert" "foo"::K"Identifier"]) ==
                  QuoteNode(:foo)
              @test JL.est_to_expr(@ast_ Expr(:call, 1)::K"Value") ==
                  JL.est_to_expr(@ast_ [K"inert" [K"call" 1::K"Value"]]) ==
                  QuoteNode(Expr(:call, 1))
  performance:
    compile_time:
      - impact: "ESTIMATED: O(n) traversal per Expr<->EST conversion where n = number of AST nodes, due to recursive traversal in _expr_to_est/est_to_expr."
        evidence:
          - source: "code"
            path: "JuliaLowering/src/compat.jl"
            loc: "659-737"
            url: "https://github.com/JuliaLang/julia/blob/1cff13010c1abd587d603c76394db6f00ef62a12/JuliaLowering/src/compat.jl#L659-L737"
            snippet: |
              elseif e isa Expr
                  cs = NodeId[]
                  for arg in e.args
                      cid, src = _expr_to_est(graph, arg, src)
                      push!(cs, cid)
                  end
              end

              for c in children(st)
                  need_lnns && push!(out.args, source_location(LineNumberNode, c))
                  push!(out.args, est_to_expr(c))
              end
    runtime:
      - impact: "No runtime execution impact; conversions are tooling/lowering utilities only."
  risk:
    level: "low"
    rationale:
      - "Changes are additive conversion utilities and tests within JuliaLowering."
      - "Behavioral differences are limited to EST/Expr round-tripping, not core execution semantics."
  open_questions:
    - "GlobalRef handling is still TODO in _expr_to_est; should GlobalRef map to a dedicated kind (e.g., K\"globalref\")?" 
  recommendations:
    - "Downstream tooling that pattern-matches on SyntaxTree kinds should add a fallback for K\"unknown_head\"."
    - "When storing Expr/Symbol inside K\"Value\", expect est_to_expr to return QuoteNode for AST nodes, per tests."
