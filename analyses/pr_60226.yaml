schema_version: "1.0"
pr:
  number: 60226
  title: "[JuliaLowering] Fix handling of unnamed args in `@generated` functions"
  url: "https://github.com/JuliaLang/julia/pull/60226"
  author: "topolarity"
  labels:
    - "compiler:lowering"
  merged_at: "2025-11-24T23:23:21Z"
  merge_commit_sha: "47c627152131e11562fef655d4d329c3fb001300"
  diff_url: "https://github.com/JuliaLang/julia/pull/60226.diff"
scope:
  files_touched:
    - "JuliaLowering/src/desugaring.jl"
    - "JuliaLowering/src/runtime.jl"
    - "JuliaLowering/test/functions.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "MacroExpansion"
    - "Lowering"
    - "ScopeResolution"
analysis:
  intent:
    summary: "Ensure JuliaLowering can lower @generated methods that include unnamed arguments by synthesizing stable, unique stub names and preserving source references for non-syntax return values."
    issue_links: []
  direct_changes:
    - summary: 'Introduce a helper that assigns deterministic placeholder names ("#arg{i}#") to unnamed arguments (BindingId) so generated-function stubs avoid repeated "#unused#" names.'
      component: "JuliaLowering/src/desugaring.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/desugaring.jl"
          loc: "2537-2576"
          url: "https://github.com/JuliaLang/julia/blob/47c627152131e11562fef655d4d329c3fb001300/JuliaLowering/src/desugaring.jl#L2537-L2576"
          snippet: |
            function stub_argname(n::SyntaxTree, i)
                if kind(n) == K"Identifier"
                    return n.name_val::String
                elseif kind(n) == K"BindingId"
                    # flisp lowering calls these unnamed arguments "#unused#", but JL does
                    # not accept that as a repeated argument name
                    return "#arg" * string(i) * "#"
                else @assert false "Unexpected argument kind: $(kind(n))" end
            end
            [K"call"
                "svec"::K"core"
                "#self#"::K"Symbol"
                (stub_argname(n,i)::K"Symbol"(n) for (i,n) in enumerate(arg_names[2:end]))...
            ]
    - summary: "Preserve the generated function stub source reference when the generator returns a non-SyntaxTree value, improving provenance for later macro expansion and lowering steps."
      component: "JuliaLowering/src/runtime.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/runtime.jl"
          loc: "332-343"
          url: "https://github.com/JuliaLang/julia/blob/47c627152131e11562fef655d4d329c3fb001300/JuliaLowering/src/runtime.jl#L332-L343"
          snippet: |
            mctx = MacroContext(syntax_graph(ctx1), g.srcref, layer, false)
            ex0 = g.gen(mctx, args...)
            if ex0 isa SyntaxTree
                if !is_compatible_graph(ctx1, ex0)
                    ex0 = copy_ast(ctx1, ex0)
                end
            else
                ex0 = @ast ctx1 g.srcref ex0::K"Value"
            end
    - summary: "Add a regression test ensuring generated functions with unnamed arguments execute correctly under JuliaLowering."
      component: "JuliaLowering/test/functions.jl"
      evidence:
        - source: "test"
          path: "JuliaLowering/test/functions.jl"
          loc: "503-524"
          url: "https://github.com/JuliaLang/julia/blob/47c627152131e11562fef655d4d329c3fb001300/JuliaLowering/test/functions.jl#L503-L524"
          snippet: |
            @testset "Generated functions" begin
                @test JuliaLowering.include_string(test_mod, """
                begin
                    @generated function f_gen_unnamed_args(::Type{T}, y, ::Type{U}) where {T, U}
                        return (T, y, U)
                    end
            
                    f_gen_unnamed_args(Int, UInt8(3), Float64)
                end
                """) == (Int, UInt8, Float64)
            end
  secondary_effects:
    - effect: 'Unnamed arguments in @generated methods no longer collide on "#unused#" and can be lowered without duplicate-argument errors.'
      mechanism: |
        expand_function_generator(...)  [desugaring.jl:2490]
          -> stub_argname(n,i)  [desugaring.jl:2537-2544]
            returns "#arg{i}#" for BindingId unnamed args
          -> GeneratedFunctionStub(argnames = svec("#self#", stub_argname(...)))  [desugaring.jl:2571-2576]
          -> GeneratedFunctionStub runtime uses g.argnames to synthesize lambda binders
             in lowering scope resolution  [runtime.jl:354-360]
      downstream_surfaces:
        - "@generated functions in Base/stdlib and packages that include unnamed Type parameters"
        - "JuliaLowering users that precompile stdlibs (e.g., Dates)"
      likelihood: "high"
      impact: "medium"
  compatibility:
    internal_api:
      - field: "GeneratedFunctionStub.argnames"
        change: 'Unnamed arguments now appear as synthesized "#arg{i}#" placeholders instead of repeated "#unused#".'
        affected_tools:
          - tool: "JuliaLowering internal lowering"
            usage: "runtime.jl uses g.argnames to create lambda argument bindings via adopt_scope."
        evidence:
          - source: "code"
            path: "JuliaLowering/src/runtime.jl"
            loc: "354-360"
            url: "https://github.com/JuliaLang/julia/blob/47c627152131e11562fef655d4d329c3fb001300/JuliaLowering/src/runtime.jl#L354-L360"
            snippet: |
              ex2 = @ast ctx2 ex0 [K"lambda"(is_toplevel_thunk=false, toplevel_pure=true)
                  [K"block"
                      (adopt_scope(string(n)::K"Identifier", layer) for n in g.argnames)...
                  ]
                  [K"block"
                      (adopt_scope(string(n)::K"Identifier", layer) for n in g.spnames)...
                  ]
                  ex2
              ]
    behavioral:
      - change: "Generated functions with unnamed arguments are accepted by JuliaLowering and evaluate correctly."
        evidence:
          - source: "test"
            path: "JuliaLowering/test/functions.jl"
            loc: "503-524"
            url: "https://github.com/JuliaLang/julia/blob/47c627152131e11562fef655d4d329c3fb001300/JuliaLowering/test/functions.jl#L503-L524"
            snippet: |
              @test JuliaLowering.include_string(test_mod, """
              begin
                  @generated function f_gen_unnamed_args(::Type{T}, y, ::Type{U}) where {T, U}
                      return (T, y, U)
                  end
              
                  f_gen_unnamed_args(Int, UInt8(3), Float64)
              end
              """) == (Int, UInt8, Float64)
  performance:
    compile_time: []
    runtime: []
  risk:
    level: "low"
    rationale:
      - "Change is localized to generated-function stub argument naming and source provenance in JuliaLowering."
      - "New test exercises the previously failing case of unnamed arguments in @generated methods."
  open_questions: []
  recommendations:
    - 'Downstream tooling that inspects GeneratedFunctionStub.argnames should tolerate synthesized "#arg{i}#" placeholders for unnamed arguments.'
    - "If diagnostic tooling depends on source locations for generated code, validate that g.srcref is now propagated for non-SyntaxTree returns."
