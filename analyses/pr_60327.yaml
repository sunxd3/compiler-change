schema_version: "1.0"
pr:
  number: 60327
  title: "Allow `K\"error\"` when parsing to SyntaxTree"
  url: "https://github.com/JuliaLang/julia/pull/60327"
  author: "mlechu"
  labels:
    - "parser"
    - "JuliaLowering"
  merged_at: "2025-12-05T22:26:59Z"
  merge_commit_sha: "2ec05d5734ce268e75bc29126e3e2f1455e5fa49"
  diff_url: "https://github.com/JuliaLang/julia/pull/60327.diff"
scope:
  files_touched:
    - "JuliaLowering/src/syntax_graph.jl"
    - "JuliaLowering/test/syntax_graph.jl"
  components:
    - "JuliaLowering"
  pipeline_stages:
    - "Parsing"
    - "Lowering"
analysis:
  intent:
    summary: "Allow SyntaxTree construction to tolerate parse errors (notably for ignore_errors parsing used by tooling like JETLS) instead of asserting on unexpected shapes."
    issue_links: []
  direct_changes:
    - summary: "`_green_to_ast` now preserves `parens`, `var`, and `char` nodes with multiple children instead of asserting they must contain exactly one child."
      component: "JuliaLowering/src/syntax_graph.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/syntax_graph.jl"
          loc: "861-883"
          url: "https://github.com/JuliaLang/julia/blob/2ec05d5734ce268e75bc29126e3e2f1455e5fa49/JuliaLowering/src/syntax_graph.jl#L861-L883"
          snippet: |
            function _green_to_ast(parent::Kind, ex::SyntaxTree; eq_to_kw=false)
                is_trivia(ex) && !is_error(ex) && return nothing
                graph = syntax_graph(ex)
                k = kind(ex)
                if k === K"ref" ||
                    (k in KSet"call dotcall" && (
                        is_prefix_call(ex) || is_prefix_op_call(ex) && numchildren(ex) > 2))
                    cs = SyntaxList(ex)
                    for c in children(ex)
                        c2 = _green_to_ast(k, c; eq_to_kw=length(cs)>0)
                        !isnothing(c2) && push!(cs, c2)
                    end
                    makenode(graph, ex, ex, cs)
                elseif k === K"parameters"
                    eq_to_kw = parent != K"vect"   && parent != K"curly" &&
                               parent != K"braces" && parent != K"ref"
                    makenode(graph, ex, ex, _map_green_to_ast(k, children(ex); eq_to_kw))
                elseif k === K"parens"
                    cs = _map_green_to_ast(parent, children(ex); eq_to_kw)
                    length(cs) === 1 ? cs[1] : makenode(graph, ex, ex, cs)
                elseif k in KSet"var char"
                    cs = _map_green_to_ast(parent, children(ex))
                    length(cs) === 1 ? cs[1] : makenode(graph, ex, ex, cs)
        - source: "rg"
          path: "JuliaLowering/src/syntax_graph.jl"
          loc: "826-919"
          url: "https://github.com/JuliaLang/julia/blob/2ec05d5734ce268e75bc29126e3e2f1455e5fa49/JuliaLowering/src/syntax_graph.jl#L826-L919"
          snippet: |
            JuliaLowering/src/syntax_graph.jl
            826:    out = _green_to_ast(K"None", SyntaxTree(graph, green_id))
            861:function _green_to_ast(parent::Kind, ex::SyntaxTree; eq_to_kw=false)
            870:            c2 = _green_to_ast(k, c; eq_to_kw=length(cs)>0)
            877:        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex); eq_to_kw))
            879:        cs = _map_green_to_ast(parent, children(ex); eq_to_kw)
            882:        cs = _map_green_to_ast(parent, children(ex))
            885:        setattr!(makenode(graph, ex, ex, _map_green_to_ast(k, children(ex))),
            895:        cs = _map_green_to_ast(k, children(ex))
            911:        makenode(graph, ex, ex, _map_green_to_ast(k, children(ex)))
            915:function _map_green_to_ast(parent::Kind, cs::SyntaxList; eq_to_kw=false)
            918:        c2 = _green_to_ast(parent, c; eq_to_kw)
    - summary: "`macro_name` handling now falls back to a regular node when the expected single Identifier or dotted Identifier shape is not present."
      component: "JuliaLowering/src/syntax_graph.jl"
      evidence:
        - source: "code"
          path: "JuliaLowering/src/syntax_graph.jl"
          loc: "891-907"
          url: "https://github.com/JuliaLang/julia/blob/2ec05d5734ce268e75bc29126e3e2f1455e5fa49/JuliaLowering/src/syntax_graph.jl#L891-L907"
          snippet: |
            elseif k === K"macro_name"
                # M.@x parses to (. M (macro_name x))
                # @M.x parses to (macro_name (. M x))
                # We want (. M @x) (both identifiers) in either case
                cs = _map_green_to_ast(k, children(ex))
                if length(cs) !== 1 || !(kind(cs[1]) in KSet". Identifier")
                    return makenode(graph, ex, ex, cs)
                end
                id = cs[1]
                mname_raw = (kind(id) === K"." ? id[2] : id).name_val
                mac_id = setattr!(makeleaf(graph, ex, K"Identifier"), :name_val,
                                  lower_identifier_name(mname_raw, K"macro_name"))
                if kind(id) === K"."
                    makenode(graph, ex, ex, NodeId[id[1]._id, mac_id._id])
                else
                    mac_id
                end
    - summary: "Tests now assert that parsing with `ignore_errors=true` returns a SyntaxTree for malformed inputs like lone `@` or bad parenthesized forms."
      component: "JuliaLowering/test/syntax_graph.jl"
      evidence:
        - source: "test"
          path: "JuliaLowering/test/syntax_graph.jl"
          loc: "43-52"
          url: "https://github.com/JuliaLang/julia/blob/2ec05d5734ce268e75bc29126e3e2f1455e5fa49/JuliaLowering/test/syntax_graph.jl#L43-L52"
          snippet: |
            @testset "SyntaxTree" begin
                # Expr conversion
                @test Expr(parsestmt(SyntaxTree, "begin a + b ; c end", filename="none")) ==
                    Meta.parse("begin a + b ; c end")

                # Parsing to SyntaxTree: errors should fall through
                @test parsestmt(SyntaxTree, "@"; ignore_errors=true) isa SyntaxTree
                @test parsestmt(SyntaxTree, "@@@"; ignore_errors=true) isa SyntaxTree
                @test parsestmt(SyntaxTree, "(a b c)"; ignore_errors=true) isa SyntaxTree
                @test parsestmt(SyntaxTree, "'a b c'"; ignore_errors=true) isa SyntaxTree
  secondary_effects:
    - effect: "Malformed inputs that previously tripped assertions now survive as SyntaxTree nodes, allowing editor/LS tooling to keep a tree for error recovery."
      mechanism: |
        JuliaSyntax.build_tree(::Type{SyntaxTree}, stream)  [syntax_graph.jl:799-815]
          -> SyntaxTree(graph, sf, cursor)  [syntax_graph.jl:818-828]
            -> _insert_green(...)  [syntax_graph.jl:833-855]
            -> _green_to_ast(K"None", SyntaxTree(graph, green_id))  [syntax_graph.jl:861-911]
               - For K"parens" and KSet"var char", length(cs) != 1 now returns makenode(...) instead of asserting
               - For K"macro_name" with unexpected shape, returns makenode(...) instead of asserting
      downstream_surfaces:
        - "JETLS and other tooling parsing with ignore_errors=true"
        - "Downstream SyntaxTree walkers that assumed single-child parens/var/char nodes"
      likelihood: "high"
      impact: "medium"
    - effect: "Macro-name rewriting is skipped for malformed macro syntax, preserving raw subtrees instead of emitting an Identifier/macroname pair."
      mechanism: |
        _green_to_ast(..., k == K"macro_name")  [syntax_graph.jl:891-907]
          -> if length(cs) !== 1 or kind(cs[1]) not in KSet". Identifier"
               returns makenode(graph, ex, ex, cs)
          -> otherwise continues rewriting into Identifier/macro_name form
      downstream_surfaces:
        - "Macro-introspection tooling that expects normalized macro_name nodes"
      likelihood: "medium"
      impact: "low"
  compatibility:
    internal_api:
      - field: "SyntaxTree shapes for K\"parens\" / KSet\"var char\""
        change: "No longer guaranteed to collapse to a single child when parsing error nodes; callers may now see wrapper nodes with multiple children."
        affected_tools:
          - tool: "JETLS"
            usage: "JETLS parses with ignore_errors=true and walks SyntaxTree nodes for diagnostics; it can now receive wrapper nodes instead of assertion failures."
      - field: "SyntaxTree K\"macro_name\" normalization"
        change: "Malformed macro syntax now yields a node with raw children instead of raising assertion or producing Identifier/macroname rewrite."
        affected_tools:
          - tool: "Macro tooling"
            usage: "Tools that pattern-match on normalized macro_name nodes should accept unnormalized nodes when parse errors are present."
    behavioral:
      - field: "parsestmt(SyntaxTree, ..., ignore_errors=true)"
        change: "Returns a SyntaxTree even for inputs like '@' or '(a b c)' instead of triggering assertions during conversion."
        affected_tools:
          - tool: "Parser consumers"
            usage: "Editor integrations and diagnostics that rely on error-tolerant parsing should now receive a tree instead of crashing."
  performance:
    compile_time:
      - impact: "ESTIMATED: negligible extra branching in _green_to_ast for error cases only; no new passes or traversals."
    runtime:
      - impact: "ESTIMATED: no measurable runtime impact; changes are confined to parsing/SyntaxTree construction."
  risk:
    level: "low"
    rationale:
      - "Changes only affect error-handling paths in SyntaxTree conversion; normal well-formed trees follow the same fast paths."
      - "Tests added to lock in error-tolerant parsing behavior."
  open_questions:
    - "Do any downstream tools rely on macro_name normalization even when parse errors exist, and should they be updated to handle unnormalized nodes?"
  recommendations:
    - "Downstream SyntaxTree consumers should treat K\"parens\", K\"var\", and K\"char\" nodes as potentially multi-child in error-tolerant parsing modes."
    - "Consider adding dedicated error-node invariants or documentation for SyntaxTree shape under ignore_errors parsing to guide tooling."
