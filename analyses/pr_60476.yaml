schema_version: "1.0"
pr:
  number: 60476
  title: "[JuliaSyntax] Add type-asserts to the results of `parse_brackets()`"
  url: "https://github.com/JuliaLang/julia/pull/60476"
  author: "JamesWrigley"
  labels:
    - "backport 1.12"
    - "backport 1.13"
  merged_at: "2026-01-05T04:25:26Z"
  merge_commit_sha: "05c973aa9bf85995b92ac5675d61913c2deb98a7"
  diff_url: "https://github.com/JuliaLang/julia/pull/60476.diff"
scope:
  files_touched:
    - "JuliaSyntax/src/julia/parser.jl"
  components:
    - "JuliaSyntax"
  pipeline_stages:
    - "Parsing"
analysis:
  intent:
    summary: "Enforce concrete NamedTuple return types from parse_brackets callbacks to stabilize parser option handling and address JuliaSyntax issue 600 regressions."
    issue_links:
      - "https://github.com/JuliaLang/JuliaSyntax.jl/issues/600"
      - "https://github.com/JuliaLang/JuliaSyntax.jl/pull/615"
  direct_changes:
    - summary: "Type-assert parse_brackets callback results in parse_unary/parse_function_signature/parse_paren/parse_string so option tuples have fixed fields and RawFlags delimiter metadata."
      component: "JuliaSyntax parser"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/julia/parser.jl"
          loc: "1272-1283"
          url: "https://github.com/JuliaLang/julia/blob/05c973aa9bf85995b92ac5675d61913c2deb98a7/JuliaSyntax/src/julia/parser.jl#L1272-L1283"
          snippet: |
            mark_before_paren = position(ps)
            bump(ps, TRIVIA_FLAG) # (
            initial_semi = peek(ps, skip_newlines=true) == K";"
            opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
                is_paren_call = had_commas || had_splat               ||
                                (initial_semi && num_subexprs > 0)    ||
                                (initial_semi && num_semis == 1)      ||
                                (num_semis == 0 && num_subexprs == 0)
                return (needs_parameters=is_paren_call,
                        is_paren_call=is_paren_call,
                        is_block=!is_paren_call && num_semis > 0)
            end::NamedTuple{(:needs_parameters, :is_paren_call, :is_block, :delim_flags), Tuple{Bool, Bool, Bool, RawFlags}}
        - source: "code"
          path: "JuliaSyntax/src/julia/parser.jl"
          loc: "2218-2246"
          url: "https://github.com/JuliaLang/julia/blob/05c973aa9bf85995b92ac5675d61913c2deb98a7/JuliaSyntax/src/julia/parser.jl#L2218-L2246"
          snippet: |
            opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
                _parsed_call = was_eventually_call(ps)
                _maybe_grouping_parens = !had_commas && !had_splat && num_semis == 0 && num_subexprs == 1
                next_token_pos = if peek(ps, 1, skip_newlines=false) == K")"
                    2
                else
                    3
                end
                token_after_paren = peek(ps, next_token_pos, skip_newlines=false)
                has_newline_after_paren = _maybe_grouping_parens && token_after_paren == K"NewlineWs"
                next_kind = peek(ps, 2, skip_newlines=_maybe_grouping_parens && !has_newline_after_paren)
                _needs_parse_call = next_kind âˆˆ KSet"( ."
                _is_anon_func = (!_needs_parse_call && !_parsed_call) || had_commas
                return (needs_parameters      = _is_anon_func,
                        is_anon_func          = _is_anon_func,
                        parsed_call           = _parsed_call,
                        needs_parse_call      = _needs_parse_call,
                        maybe_grouping_parens = _maybe_grouping_parens)
            end::NamedTuple{(:needs_parameters, :is_anon_func, :parsed_call, :needs_parse_call, :maybe_grouping_parens, :delim_flags),
                            Tuple{Bool, Bool, Bool, Bool, Bool, RawFlags}}
        - source: "code"
          path: "JuliaSyntax/src/julia/parser.jl"
          loc: "3318-3333"
          url: "https://github.com/JuliaLang/julia/blob/05c973aa9bf85995b92ac5675d61913c2deb98a7/JuliaSyntax/src/julia/parser.jl#L3318-L3333"
          snippet: |
            if prev_chunk_newline
                indent_ref_i = first_byte(t)
                indent_ref_len = 0
            end
            bump(ps, TRIVIA_FLAG)
            k = peek(ps)
            if k == K"("
                m = position(ps)
                bump(ps, TRIVIA_FLAG)
                opts = parse_brackets(ps, K")") do had_commas, had_splat, num_semis, num_subexprs
                    return (needs_parameters=false,
                            simple_interp=!had_commas && num_semis == 0 && num_subexprs == 1)
                end::NamedTuple{(:needs_parameters, :simple_interp, :delim_flags), Tuple{Bool, Bool, RawFlags}}
    - summary: "Assert NamedTuple shapes for parse_call_arglist and parse_vect bracket parsing to keep needs_parameters/num_subexprs types concrete."
      component: "JuliaSyntax parser"
      evidence:
        - source: "code"
          path: "JuliaSyntax/src/julia/parser.jl"
          loc: "2775-2798"
          url: "https://github.com/JuliaLang/julia/blob/05c973aa9bf85995b92ac5675d61913c2deb98a7/JuliaSyntax/src/julia/parser.jl#L2775-L2798"
          snippet: |
            function parse_call_arglist(ps::ParseState, closer)
                ps = ParseState(ps, for_generator=true)

                parse_brackets(ps, closer, false) do _, _, _, _
                    return (needs_parameters=true,)
                end::NamedTuple{(:needs_parameters, :delim_flags), Tuple{Bool, RawFlags}}
            end

            function parse_vect(ps::ParseState, closer, prefix_trailing_comma)
                opts = parse_brackets(ps, closer) do _, _, _, num_subexprs
                    return (needs_parameters=true,
                            num_subexprs=num_subexprs)
                end::NamedTuple{(:needs_parameters, :num_subexprs, :delim_flags), Tuple{Bool, Int, RawFlags}}
                delim_flags = opts.delim_flags
    - summary: "Parser tests continue to assert expected AST for prefix operator calls and bracketed argument lists; these serve as concrete before/after behavior references."
      component: "JuliaSyntax tests"
      evidence:
        - source: "test"
          path: "JuliaSyntax/test/parser.jl"
          loc: "204-245"
          url: "https://github.com/JuliaLang/julia/blob/05c973aa9bf85995b92ac5675d61913c2deb98a7/JuliaSyntax/test/parser.jl#L204-L245"
          snippet: |
            JuliaSyntax.parse_unary => [
                ":T"       => "(quote-: T)"
                "in::T"    => "(::-i in T)"
                "isa::T"   => "(::-i isa T)"
                "-2^x"     => "(call-pre - (call-i 2 ^ x))"
                "-2[1, 3]" => "(call-pre - (ref 2 1 3))"
                "+{T}(x::T)"  =>  "(call (curly + T) (::-i x T))"
                "*(x)"        =>  "(call * x)"
                ".*(x)"       =>  "(call (. *) x)"
                "+(a,b)"   =>  "(call + a b)"
                "+(a,)"    =>  "(call-, + a)"
                ".+(a,)"   =>  "(call-, (. +) a)"
                "(.+)(a)"  =>  "(call (parens (. +)) a)"
                "(.~(a))"  =>  "(parens (dotcall-pre ~ (parens a)))"
                "+(a=1,)"  =>  "(call-, + (= a 1))"
                "+(a...)"  =>  "(call + (... a))"
                "+(a;b,c)" =>  "(call + a (parameters b c))"
                "+(;a)"    =>  "(call + (parameters a))"
                "+(;;a)"   =>  "(call + (parameters) (parameters a))"
                "+()"      =>  "(call +)"
                "+(\n;a)"  =>  "(call + (parameters a))"
                "+(;)"     =>  "(call + (parameters))"
  secondary_effects:
    - effect: "Invalid parse_brackets option tuples now fail fast with a TypeError, rather than propagating loosely-typed opts fields into later parse logic."
      mechanism: |
        parse_unary(...) [parser.jl:1272-1311]
          -> parse_brackets(...) [parser.jl:1275]
            -> after_parse(...) returns NamedTuple
            -> result asserted to NamedTuple{(:needs_parameters,:is_paren_call,:is_block,:delim_flags),Tuple{Bool,Bool,Bool,RawFlags}} [parser.jl:1283]
          -> opts.delim_flags used in emit(...) [parser.jl:1307-1311]
        parse_brackets(...) itself appends delim_flags before returning [parser.jl:3272-3281].
      downstream_surfaces:
        - "JuliaSyntax.parse_unary/parse_paren/parse_string callers"
        - "SyntaxTree/SyntaxNode parse output consumers"
      likelihood: "low"
      impact: "low"
    - effect: "More stable type inference for opts NamedTuples in parser hot paths, potentially reducing dynamic dispatch during parsing (ESTIMATED)."
      mechanism: |
        parse_call_arglist(...) [parser.jl:2775-2780]
          -> parse_brackets(...) [parser.jl:2778]
            -> return asserted NamedTuple{(:needs_parameters,:delim_flags),Tuple{Bool,RawFlags}}
        This keeps needs_parameters/delim_flags concrete for subsequent code paths, improving compiler specialization for parsing routines.
      downstream_surfaces:
        - "Parser throughput for code with heavy bracket syntax"
      likelihood: "medium"
      impact: "low"
  compatibility:
    internal_api:
      - field: "parse_brackets after_parse return tuple fields"
        change: "Call sites now assert exact NamedTuple field sets and types (Bool fields plus RawFlags delim_flags)."
        affected_tools:
          - tool: "JuliaSyntax internal parser helpers"
            usage: "parse_unary/parse_paren/parse_function_signature/parse_string expect opts NamedTuple with fixed field names and RawFlags delim_flags."
    behavioral:
      - change: "If an after_parse callback returns a NamedTuple with unexpected fields or non-Bool/RawFlags types, parsing throws a TypeError instead of silently proceeding."
        affected_surface: "JuliaSyntax internal parsing routines"
        impact: "low"
  performance:
    compile_time:
      - change: "ESTIMATED: improved type inference for parse_brackets option tuples in parsing hot paths; no algorithmic complexity changes."
        impact: "low"
    runtime:
      - change: "No expected runtime behavior changes for successful parses; only error paths are stricter."
        impact: "low"
  risk:
    level: "low"
    rationale:
      - "Changes are limited to type assertions on internal NamedTuple shapes and do not alter parsing logic for valid inputs."
      - "Potential failures only occur if internal callbacks return malformed option tuples."
  open_questions:
    - "Are there any downstream forks that override parser.jl functions and return non-matching NamedTuple shapes from parse_brackets callbacks?"
  recommendations:
    - "If downstream tooling patches JuliaSyntax parser helpers, ensure parse_brackets callbacks return NamedTuples with the asserted fields and RawFlags delim_flags."
    - "Consider adding a small parser test that exercises a parse_brackets path and validates delim_flags presence to prevent regressions."
