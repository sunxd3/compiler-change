schema_version: "1.0"

pr:
  number: 60171
  title: "Add uninitialized multi-versioning trampoline for autoinit support"
  url: "https://github.com/JuliaLang/julia/pull/60171"
  author: "topolarity"
  labels: []
  merged_at: "2025-11-19T20:17:52Z"
  merge_commit_sha: "d8bb729c4daebe3571539ad300d52064709ce80f"
  diff_url: "https://github.com/JuliaLang/julia/pull/60171.diff"
  issue_links:
    - "https://github.com/JuliaLang/julia/issues/58952#issuecomment-3076371765"

scope:
  files_touched:
    - "src/llvm-multiversioning.cpp"
    - "test/llvmpasses/multiversioning-clone-only.ll"
    - "test/llvmpasses/multiversioning-x86.ll"
  components:
    - "Codegen"
    - "LLVM Passes"
    - "Multiversioning"
  pipeline_stages:
    - "Codegen"
    - "Runtime Initialization"

analysis:
  intent:
    summary: |
      Adds an autoinit trampoline for multi-versioned function entrypoints so that
      auto-initialization works correctly when external code calls multi-versioned
      Julia functions before Julia has been initialized. Previously, relocation slots
      for multi-versioned functions were initialized to NULL, which would crash if
      called before runtime initialization. Now they are initialized with a trampoline
      that first calls jl_autoinit_and_adopt_thread() before dispatching to the
      architecture-specific implementation.
    issue_links:
      - "https://github.com/JuliaLang/julia/issues/58952"

  direct_changes:
    - summary: "New create_trampoline() method extracted and generalized from rewrite_alias()"
      component: "llvm-multiversioning.cpp"
      evidence:
        - source: "code"
          path: "src/llvm-multiversioning.cpp"
          loc: "498-543"
          url: "https://github.com/JuliaLang/julia/blob/d8bb729c4daebe3571539ad300d52064709ce80f/src/llvm-multiversioning.cpp#L498-L543"
          snippet: |
            Function *CloneCtx::create_trampoline(Function *F, GlobalVariable *slot, bool autoinit)
            {
                Function *trampoline =
                    Function::Create(F->getFunctionType(), GlobalValue::ExternalLinkage, "", &M);

                trampoline->copyAttributesFrom(F);
                trampoline->setVisibility(GlobalValue::HiddenVisibility);
                trampoline->setDSOLocal(true);

                // drop multiversioning attributes
                trampoline->removeFnAttr("julia.mv.reloc");
                trampoline->removeFnAttr("julia.mv.clones");

                auto BB = BasicBlock::Create(F->getContext(), "top", trampoline);
                IRBuilder<> irbuilder(BB);

                if (autoinit) {
                    irbuilder.CreateCall(F->getParent()->getOrInsertFunction(
                        XSTR(jl_autoinit_and_adopt_thread),
                        PointerType::get(F->getContext(), 0)
                    ));
                }

                auto ptr = irbuilder.CreateLoad(F->getType(), slot);
                ptr->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);
                ptr->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(F->getContext(), {}));

                SmallVector<Value *, 0> Args;
                for (auto &arg : trampoline->args())
                    Args.push_back(&arg);
                auto call = irbuilder.CreateCall(F->getFunctionType(), ptr, ArrayRef<Value *>(Args));
                if (F->isVarArg()) {
                    assert(!TT.isARM() && !TT.isPPC() && "musttail not supported on ARM/PPC!");
                    call->setTailCallKind(CallInst::TCK_MustTail);
                } else {
                    call->setTailCallKind(CallInst::TCK_Tail);
                }

                if (F->getReturnType() == Type::getVoidTy(F->getContext()))
                    irbuilder.CreateRetVoid();
                else
                    irbuilder.CreateRet(call);

                return trampoline;
            }
          notes: |
            Key implementation details:
            1. XSTR(jl_autoinit_and_adopt_thread) expands to "ijl_autoinit_and_adopt_thread"
               (with 'i' prefix) via the macro in julia_internal.h:25
            2. The autoinit call returns a pointer (gcstack) but the return value is ignored
            3. TCK_Tail vs TCK_MustTail: MustTail required for varargs to forward all args
            4. invariant_load metadata enables LLVM to hoist/CSE repeated slot loads

    - summary: "Relocation slots now initialized with autoinit trampoline instead of NULL"
      component: "llvm-multiversioning.cpp"
      evidence:
        - source: "code"
          path: "src/llvm-multiversioning.cpp"
          loc: "556-565"
          url: "https://github.com/JuliaLang/julia/blob/d8bb729c4daebe3571539ad300d52064709ce80f/src/llvm-multiversioning.cpp#L556-L565"
          snippet: |
            else {
                auto id = get_func_id(F);
                const_relocs[id] = GV;

                // Initialize with a single-use trampoline that calls `jl_autoinit_and_adopt_thread`,
                // so that auto-initialization works with multi-versioned entrypoints.
                Function *trampoline = create_trampoline(F, GV, /* autoinit */ true);
                trampoline->setName(F->getName() + ".autoinit_trampoline");
                GV->setInitializer(trampoline);
            }
        - source: "diff"
          path: "src/llvm-multiversioning.cpp"
          loc: "prepare_slots"
          snippet: |
            # BEFORE (old code):
            GV->setInitializer(Constant::getNullValue(F->getType()));

            # AFTER (new code):
            Function *trampoline = create_trampoline(F, GV, /* autoinit */ true);
            trampoline->setName(F->getName() + ".autoinit_trampoline");
            GV->setInitializer(trampoline);

    - summary: "rewrite_alias() simplified by delegating to create_trampoline()"
      component: "llvm-multiversioning.cpp"
      evidence:
        - source: "code"
          path: "src/llvm-multiversioning.cpp"
          loc: "718-737"
          url: "https://github.com/JuliaLang/julia/blob/d8bb729c4daebe3571539ad300d52064709ce80f/src/llvm-multiversioning.cpp#L718-L737"
          snippet: |
            void CloneCtx::rewrite_alias(GlobalAlias *alias, Function *F)
            {
                assert(!is_vector(F->getFunctionType()));

                uint32_t id;
                GlobalVariable *slot;
                std::tie(id, slot) = get_reloc_slot(F);
                assert(slot);

                Function *trampoline = create_trampoline(F, slot, /* autoinit */ false);
                trampoline->addFnAttr("julia.mv.alias"); // add alias attribute for testing purposes

                trampoline->takeName(alias);
                trampoline->setLinkage(alias->getLinkage());
                trampoline->setVisibility(alias->getVisibility());
                trampoline->setDSOLocal(alias->isDSOLocal());
                trampoline->setDLLStorageClass(alias->getDLLStorageClass());

                alias->eraseFromParent();
            }

  secondary_effects:
    - effect: "First call to multi-versioned functions now triggers Julia initialization if needed"
      mechanism: |
        prepare_slots() [llvm-multiversioning.cpp:545]
          creates reloc_slot global variable for multi-versioned function
          -> create_trampoline(F, GV, true) [llvm-multiversioning.cpp:562]
            generates autoinit trampoline with jl_autoinit_and_adopt_thread() call
          -> GV->setInitializer(trampoline) [llvm-multiversioning.cpp:564]
            initializes slot with autoinit trampoline instead of NULL

        At runtime, first call sequence:
          external caller -> reloc_slot (points to autoinit_trampoline)
            -> autoinit_trampoline calls jl_autoinit_and_adopt_thread()
            -> jl_autoinit_and_adopt_thread() initializes Julia if needed [threading.c:454]
            -> autoinit_trampoline loads from reloc_slot (now updated to real func)
            -> tail call to architecture-specific implementation

        Subsequent calls (after runtime initialization updates slot):
          external caller -> reloc_slot (now points to real implementation)
            -> direct call to architecture-specific function
      downstream_surfaces:
        - "External C callers of multi-versioned Julia functions"
        - "juliac-compiled shared libraries"
        - "Embedded Julia applications"
      likelihood: "high"
      impact: "high"

    - effect: "Runtime slot update semantics unchanged but initial value changed"
      mechanism: |
        parse_sysimg() [processor.cpp:637-768]
          iterates reloc_slots and updates them with correct function pointers
          -> const char *data_base = (const char*)shard.clone_slots [line 747]
          -> auto slot = (const void**)(data_base + reloc_slots[reloc_i * 2 + 1]) [line 748]
          -> *slot = fptr [line 750]
        This overwrites the initial autoinit trampoline with the real function pointer.
        The autoinit trampoline is single-use: it is only called if the slot hasn't
        been updated by the runtime initialization yet.
      downstream_surfaces:
        - "Runtime function dispatch"
        - "Multi-versioning target selection"
      likelihood: "medium"
      impact: "low"

    - effect: "Extern declarations do not receive autoinit trampolines"
      mechanism: |
        prepare_slots() [llvm-multiversioning.cpp:545-568]
          For functions that are declarations (F->isDeclaration() is true):
            -> extern_relocs[F] = GV [line 554]
            No trampoline is created - the slot is stored for later use
          For functions with definitions:
            -> create_trampoline(F, GV, true) is called [line 562]
            -> autoinit trampoline is created and used as initializer

        This means external function calls through multi-versioned trampolines
        do NOT trigger autoinit. Only defined functions in the module get the
        autoinit behavior.
      downstream_surfaces:
        - "External library calls through multi-versioned functions"
        - "Cross-module function references"
      likelihood: "low"
      impact: "low"

    - effect: "Varargs functions on ARM/PPC have platform restrictions"
      mechanism: |
        create_trampoline() [llvm-multiversioning.cpp:529-531]
          if (F->isVarArg()) {
              assert(!TT.isARM() && !TT.isPPC() && "musttail not supported on ARM/PPC!");
              call->setTailCallKind(CallInst::TCK_MustTail);
          }
        For varargs functions, musttail is required to correctly forward all arguments.
        This is not supported on ARM/PPC, which will trigger an assertion failure
        if a varargs multi-versioned function is processed on these platforms.
      downstream_surfaces:
        - "ARM builds with varargs multi-versioned functions"
        - "PPC builds with varargs multi-versioned functions"
      likelihood: "low"
      impact: "medium"

    - effect: "LLVM metadata marks slot loads as invariant after initialization"
      mechanism: |
        create_trampoline() [llvm-multiversioning.cpp:521-523]
          auto ptr = irbuilder.CreateLoad(F->getType(), slot);
          ptr->setMetadata(llvm::LLVMContext::MD_tbaa, tbaa_const);
          ptr->setMetadata(llvm::LLVMContext::MD_invariant_load, MDNode::get(F->getContext(), {}));

        The !invariant.load metadata tells LLVM that once the slot is loaded, its
        value will not change. This enables aggressive optimization (CSE, hoisting)
        but relies on the runtime updating the slot before any subsequent calls.
        The !tbaa !jtbaa_const metadata further reinforces constant-ness for TBAA.
      downstream_surfaces:
        - "LLVM optimization passes"
        - "Code motion and CSE"
      likelihood: "high"
      impact: "low"

  compatibility:
    internal_api:
      - field: "reloc_slot global variable initial value"
        change: "Changed from NULL to autoinit trampoline function pointer"
        affected_tools:
          - tool: "juliac"
            usage: "Creates shared libraries with multi-versioned entrypoints"
          - tool: "PackageCompiler.jl"
            usage: "Uses multi-versioning for compiled applications"

    behavioral:
      - area: "First call to multi-versioned function before Julia init"
        change: "Previously would crash (NULL dereference), now triggers auto-initialization"
        affected_packages:
          - "Any package using juliac with multi-versioning and external callers"

  performance:
    compile_time:
      - impact: "Negligible increase"
        details: |
          ESTIMATED: <1% increase in codegen time
          Creates one additional small trampoline function per multi-versioned
          function that has a reloc_slot. Trampoline is ~10 LLVM IR instructions.

    runtime:
      - impact: "First call overhead, subsequent calls unchanged"
        details: |
          First call: Additional function call overhead (~10-20 cycles) for
          jl_autoinit_and_adopt_thread() check (which early-exits if already
          initialized via jl_is_initialized() check).

          Subsequent calls: Zero overhead - slot is updated to point directly
          to architecture-specific implementation after runtime init.

          ESTIMATED based on code analysis, not measured.

  risk:
    level: "low"
    rationale:
      - "Change is additive - adds initialization path, doesn't remove existing functionality"
      - "Autoinit trampoline is single-use and replaced at runtime"
      - "jl_autoinit_and_adopt_thread() is an existing, well-tested function"
      - "Test coverage added for autoinit trampoline generation"
      - "Refactoring of rewrite_alias() preserves existing behavior (autoinit=false)"

  test_coverage:
    - test_file: "test/llvmpasses/multiversioning-clone-only.ll"
      description: "Verifies autoinit trampoline is generated correctly"
      key_assertions:
        - "reloc_slot initialized to autoinit_trampoline instead of null"
        - "autoinit_trampoline calls ijl_autoinit_and_adopt_thread()"
        - "autoinit_trampoline loads from reloc_slot and tail calls"
      snippet: |
        ; OPAQUE: @subtarget_cloned.reloc_slot = hidden global ptr @subtarget_cloned.autoinit_trampoline

        ; COM: check that the autoinit trampoline is generated correctly
        ; CHECK: define{{.*}}@subtarget_cloned.autoinit_trampoline({{.*}}
        ; CHECK-NEXT: top:
        ; CHECK-NEXT: call ptr @ijl_autoinit_and_adopt_thread()
        ; CHECK-NEXT: [[FUNC_PTR:%[0-9]+]] = load ptr, ptr @subtarget_cloned.reloc_slot{{.*}}!tbaa ![[TBAA_CONST_METADATA]], !invariant.load
        ; CHECK-NEXT: call{{.*}}[[FUNC_PTR]]({{.*}})
        ; CHECK: ret i32

    - test_file: "test/llvmpasses/multiversioning-x86.ll"
      description: "Verifies x86-specific multiversioning with autoinit"
      key_assertions:
        - "simd_test.reloc_slot initialized to simd_test.autoinit_trampoline"
      snippet: |
        ; OPAQUE: @simd_test.reloc_slot = hidden global ptr @simd_test.autoinit_trampoline

  open_questions:
    - "What happens if jl_autoinit_and_adopt_thread() fails? It calls exit(1) after printing error. See threading.c:460-462."
    - "Is there potential for race conditions if multiple threads call autoinit trampoline simultaneously? jl_autoinit_and_adopt_thread() handles this - if already initialized, calls jl_adopt_thread() instead."
    - "Could the invariant_load metadata cause issues if a slot is read before runtime updates it? No - the autoinit trampoline ensures initialization happens first."
    - "What happens on ARM/PPC with varargs multi-versioned functions? An assertion failure occurs at compile time. This is a pre-existing limitation, not introduced by this PR."

  recommendations:
    - "Downstream tools generating multi-versioned code should not assume reloc_slots are NULL-initialized"
    - "Tools inspecting LLVM IR should expect .autoinit_trampoline suffix on generated trampolines"
    - "No action needed for typical Julia users - change is transparent"
    - "When building shared libraries with juliac that expose multi-versioned functions, callers can now safely invoke them before Julia initialization"
    - "For ARM/PPC targets, avoid varargs in multi-versioned exported functions due to musttail limitations"

call_chain_analysis:
  entry_points:
    - function: "prepare_slots()"
      file: "src/llvm-multiversioning.cpp"
      line: 545
      description: "Creates reloc_slot globals and initializes with autoinit trampolines"

  call_graph: |
    runMultiVersioning() [llvm-multiversioning.cpp:1067]
      -> CloneCtx::prepare_slots() [llvm-multiversioning.cpp:545]
        -> create_trampoline(F, GV, true) [llvm-multiversioning.cpp:562]
          generates autoinit trampoline
        -> GV->setInitializer(trampoline) [llvm-multiversioning.cpp:564]

      -> CloneCtx::fix_gv_uses() [llvm-multiversioning.cpp:739]
        -> rewrite_alias(alias, F) [llvm-multiversioning.cpp:718]
          -> create_trampoline(F, slot, false) [llvm-multiversioning.cpp:727]
            generates non-autoinit trampoline for aliases

  runtime_call_chain: |
    External caller (before Julia init)
      -> multi_versioned_func.reloc_slot
        -> multi_versioned_func.autoinit_trampoline [generated]
          -> jl_autoinit_and_adopt_thread() [threading.c:454-469]
            -> jl_is_initialized() check [line 456]
            -> if not initialized:
              -> jl_find_dynamic_library_by_addr(retaddr) [line 458]
              -> jl_init_with_image_handle(handle) [line 464]
                -> triggers parse_sysimg() [processor.cpp:637]
                  -> updates reloc_slots with actual function pointers [line 750]
              -> returns &jl_get_current_task()->gcstack [line 465]
            -> if already initialized:
              -> jl_adopt_thread() [line 468]
          -> load from reloc_slot (now updated to real func)
          -> tail call to architecture-specific implementation

    Note: The jl_find_dynamic_library_by_addr uses __builtin_return_address(0) to
    determine which shared library the call originated from, enabling auto-detection
    of the correct sysimage to initialize.

downstream_impact:
  affected_packages:
    - name: "juliac / PackageCompiler.jl"
      impact: "Positive - fixes crash when multi-versioned functions called before init"
      action_required: "None"

    - name: "GPUCompiler.jl"
      impact: "None - GPU code doesn't use CPU multi-versioning"
      action_required: "None"

    - name: "Enzyme.jl"
      impact: "Minimal - doesn't directly interact with multi-versioning trampolines"
      action_required: "None"

    - name: "JET.jl"
      impact: "None - operates at IR level before codegen"
      action_required: "None"

  breaking_changes: []

  new_capabilities:
    - "Multi-versioned Julia functions can now be safely called from external code before Julia runtime initialization"
    - "Auto-initialization works correctly for all CPU target variants"
