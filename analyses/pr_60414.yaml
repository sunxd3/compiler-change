schema_version: "1.0"
pr:
  number: 60414
  title: "compiler: Fix typo in `abstract_invoke`"
  url: "https://github.com/JuliaLang/julia/pull/60414"
  author: "aviatesk"
  labels: []
  merged_at: "2025-12-19T08:22:40Z"
  merge_commit_sha: "ea7dbfc6a1b9d9b2e677c8af34079380244a65be"
  diff_url: "https://github.com/JuliaLang/julia/pull/60414.diff"
scope:
  files_touched:
    - "Compiler/src/abstractinterpretation.jl"
  components:
    - "Compiler.AbstractInterpretation"
  pipeline_stages:
    - "TypeInference"
analysis:
  intent:
    summary: "Fix a typo in abstract_invoke so the CodeInstance path checks method_or_ci instead of a misspelled variable, restoring proper exception-effect accounting for invoke." 
    issue_links: []
  direct_changes:
    - summary: "Corrected the CodeInstance branch in abstract_invoke to reference method_or_ci (not the misspelled method_ir_ci) when determining whether to union ErrorException into the call's exception set." 
      component: "Compiler/abstractinterpretation"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "2225-2245"
          url: "https://github.com/JuliaLang/julia/blob/ea7dbfc6a1b9d9b2e677c8af34079380244a65be/Compiler/src/abstractinterpretation.jl#L2225-L2245"
          snippet: |
            if !hasintersect(argtype, specsig)
                return Future(CallMeta(Bottom, TypeError, EFFECTS_THROWS, NoCallInfo()))
            elseif !(argtype <: specsig) || ((!isa(method_or_ci.def, ABIOverride) && isa(defdef, Method)) && !(argtype <: defdef.sig))
                exct = Union{exct, TypeError}
            end
            callee_valid_range = WorldRange(method_or_ci.min_world, method_or_ci.max_world)
            if !(our_world in callee_valid_range)
                if our_world < first(callee_valid_range)
                    update_valid_age!(sv, our_world, WorldRange(first(sv.valid_worlds), first(callee_valid_range)-1))
                else
                    update_valid_age!(sv, our_world, WorldRange(last(callee_valid_range)+1, last(sv.valid_worlds)))
                end
                return Future(CallMeta(Bottom, ErrorException, EFFECTS_THROWS, NoCallInfo()))
            end
            # TODO: When we add curing, we may want to assume this is nothrow
            if (method_or_ci.owner === Nothing && method_or_ci.def.def isa Method)
                exct = Union{exct, ErrorException}
            end
            update_valid_age!(sv, our_world, callee_valid_range)
            return Future(CallMeta(method_or_ci.rettype, exct, Effects(decode_effects(method_or_ci.ipo_purity_bits), nothrow=(exct===Bottom)),
                InvokeCICallInfo(method_or_ci)))
        - source: "test"
          path: "Compiler/test/inference.jl"
          loc: "5241-5243"
          url: "https://github.com/JuliaLang/julia/blob/ea7dbfc6a1b9d9b2e677c8af34079380244a65be/Compiler/test/inference.jl#L5241-L5243"
          snippet: |
            # Issue #46839: `abstract_invoke` should handle incorrect call type
            @test only(Base.return_types(()->invoke(BitSet, Any, x), ())) === Union{}
            @test only(Base.return_types(()->invoke(BitSet, Union{Tuple{Int32},Tuple{Int64}}, 1), ())) === Union{}
    - summary: "abstract_invoke is reached from abstract_call_known when the inferred callee is the invoke builtin, making the typo a potential inference-time error on that path." 
      component: "Compiler/abstractinterpretation"
      evidence:
        - source: "code"
          path: "Compiler/src/abstractinterpretation.jl"
          loc: "2637-2652"
          url: "https://github.com/JuliaLang/julia/blob/ea7dbfc6a1b9d9b2e677c8af34079380244a65be/Compiler/src/abstractinterpretation.jl#L2637-L2652"
          snippet: |
            # call where the function is known exactly
            function abstract_call_known(interp::AbstractInterpreter, @nospecialize(f),
                    arginfo::ArgInfo, si::StmtInfo, sv::AbsIntState,
                    max_methods::Int = get_max_methods(interp, f, sv))
                (; fargs, argtypes) = arginfo
                argtypes::Vector{Any} = arginfo.argtypes  # declare type because the closure below captures `argtypes`
                fargs = arginfo.fargs
                la = length(argtypes)
                ð•ƒáµ¢ = typeinf_lattice(interp)
                if isa(f, Builtin)
                    if f === _apply_iterate
                        return abstract_apply(interp, argtypes, si, sv, max_methods)
                    elseif f === invoke
                        return abstract_invoke(interp, arginfo, si, sv)
                    elseif f === modifyfield! || f === Core.modifyglobal! ||
        - source: "rg"
          path: "rg output"
          loc: "abstract_invoke"
          url: "https://github.com/JuliaLang/julia/blob/ea7dbfc6a1b9d9b2e677c8af34079380244a65be/Compiler/src/abstractinterpretation.jl#L2211"
          snippet: |
            Compiler/test/inference.jl
            5241:# Issue #46839: `abstract_invoke` should handle incorrect call type
            
            Compiler/src/tfuncs.jl
            3196:# a simplified model of abstract_invoke for Core._hasmethod
            
            Compiler/src/abstractinterpretation.jl
            2211:function abstract_invoke(interp::AbstractInterpreter, arginfo::ArgInfo, si::StmtInfo, sv::AbsIntState)
            2650:            return abstract_invoke(interp, arginfo, si, sv)
  secondary_effects:
    - effect: "Avoids an inference-time UndefVarError in the CodeInstance branch of abstract_invoke, allowing the exception union logic to run and propagate ErrorException into the call's effects." 
      mechanism: |
        abstract_call_known(..., f === invoke) dispatches to abstract_invoke  [abstractinterpretation.jl:2637-2651]
          -> abstract_invoke CodeInstance path evaluates method_or_ci.owner and method_or_ci.def.def  [abstractinterpretation.jl:2225-2241]
          -> exct = Union{exct, ErrorException} updates nothrow computation for CallMeta  [abstractinterpretation.jl:2239-2244]
      downstream_surfaces:
        - "Base.return_types and other inference queries involving invoke"
        - "Effect inference (nothrow flag) for invoke callsites"
      likelihood: "medium"
      impact: "low"
  compatibility:
    internal_api: []
    behavioral:
      - change: "invoke effect modeling for CodeInstance paths no longer risks an UndefVarError from a misspelled variable, improving robustness of inference-time error handling." 
        evidence:
          - source: "code"
            path: "Compiler/src/abstractinterpretation.jl"
            loc: "2239-2244"
            url: "https://github.com/JuliaLang/julia/blob/ea7dbfc6a1b9d9b2e677c8af34079380244a65be/Compiler/src/abstractinterpretation.jl#L2239-L2244"
            snippet: |
              # TODO: When we add curing, we may want to assume this is nothrow
              if (method_or_ci.owner === Nothing && method_or_ci.def.def isa Method)
                  exct = Union{exct, ErrorException}
              end
              update_valid_age!(sv, our_world, callee_valid_range)
  performance:
    compile_time:
      - impact: "ESTIMATED: No measurable change; the fix is a corrected variable reference in an existing conditional." 
        evidence:
          - source: "code"
            path: "Compiler/src/abstractinterpretation.jl"
            loc: "2239-2244"
            url: "https://github.com/JuliaLang/julia/blob/ea7dbfc6a1b9d9b2e677c8af34079380244a65be/Compiler/src/abstractinterpretation.jl#L2239-L2244"
            snippet: |
              # TODO: When we add curing, we may want to assume this is nothrow
              if (method_or_ci.owner === Nothing && method_or_ci.def.def isa Method)
                  exct = Union{exct, ErrorException}
              end
              update_valid_age!(sv, our_world, callee_valid_range)
    runtime:
      - impact: "ESTIMATED: No runtime changes; impacts are limited to inference-time exception bookkeeping for invoke." 
        evidence:
          - source: "code"
            path: "Compiler/src/abstractinterpretation.jl"
            loc: "2239-2244"
            url: "https://github.com/JuliaLang/julia/blob/ea7dbfc6a1b9d9b2e677c8af34079380244a65be/Compiler/src/abstractinterpretation.jl#L2239-L2244"
            snippet: |
              # TODO: When we add curing, we may want to assume this is nothrow
              if (method_or_ci.owner === Nothing && method_or_ci.def.def isa Method)
                  exct = Union{exct, ErrorException}
              end
              update_valid_age!(sv, our_world, callee_valid_range)
  risk:
    level: "low"
    rationale:
      - "One-line typo fix in an existing conditional; no new control flow or data structures added."
      - "Change only affects exception-effect modeling for invoke with CodeInstance inputs."
  open_questions: []
  recommendations:
    - "Downstream tooling that depends on inference effects for invoke should retest against this change to confirm ErrorException is surfaced for CodeInstance calls where owner === Nothing."
